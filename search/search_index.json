{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Yaz\u0131l\u0131m Tasar\u0131m Dok\u00fcman\u0131: Clonify Labs Proje Ad\u0131 : Medikal Sekt\u00f6rde 3 Boyutlu Tarama ile Ki\u015fiye \u00d6zel H\u0131zl\u0131 Kal\u0131p \u00dcretimi \u00dcr\u00fcn Ad\u0131 : Clonify Labs Modelleme Yaz\u0131l\u0131m\u0131 Versiyon : 0.2 Tarih : 15.08.2025 \u0130\u00e7indekiler Y\u00f6netici \u00d6zeti Giri\u015f 2.1. Dok\u00fcman\u0131n Amac\u0131 2.2. Projenin Kapsam\u0131 2.3. Tan\u0131mlar ve K\u0131saltmalar Hedefler ve Ama\u00e7lar Payda\u015flar \u00dcst D\u00fczey Mimari 5.1. Katmanl\u0131 Mimari Yakla\u015f\u0131m\u0131 5.2. Katmanlar\u0131n Detayl\u0131 Analizi Mod\u00fcl Envanteri Kullan\u0131lan Teknolojiler ve K\u00fct\u00fcphaneler \u00c7ekirdek Fonksiyonlar\u0131n Mant\u0131ksal Ak\u0131\u015f\u0131 8.1. Fonksiyon: Mesh Y\u00fckleme 8.2. Fonksiyon: Bas\u0131n\u00e7 Boyama 8.3. Fonksiyon: Is\u0131 Haritas\u0131 Olu\u015fturma (Asenkron) 8.4. Fonksiyon: Kal\u0131p Olu\u015fturma 8.5. Fonksiyon: Tarama Temizleme 8.6. Fonksiyon: Anatomik Hizalama 8.7. Fonksiyon: Hacimsel Deformasyon Kullan\u0131c\u0131 Etkile\u015fim Tasar\u0131m\u0131 9.1. Mod\u00fcler Etkile\u015fim Stilleri 9.2. \u0130leti\u015fim Desenleri \u00c7ekirdek Alan Modelleri Hizmet Katman\u0131: VTKProcessor Arka U\u00e7 Ara\u00e7lar\u0131 (Backend Tooling) Asenkron \u0130\u015fleme Render (G\u00f6rselle\u015ftirme) Hatt\u0131 Mesh \u0130\u015flemleri (Temsili) Performans Stratejileri Loglama ve Hata Y\u00f6netimi Konfig\u00fcrasyon ve Ortam Derleme ve Ba\u011f\u0131ml\u0131l\u0131k Y\u00f6netimi Kodlama Standartlar\u0131 Test Stratejisi Kalite Kontrolleri G\u00fcvenlik ve Gizlilik Riskler ve Azaltma Y\u00f6ntemleri Gelecek Geli\u015ftirmeler ve Geni\u015fletme Noktalar\u0131 S\u00f6zl\u00fck 1. Giri\u015f ClonifyCad , medikal sekt\u00f6rde, \u00f6zellikle ortopedi ve protez alan\u0131nda, 3 boyutlu tarama verileri kullanarak ki\u015fiye \u00f6zel protez ve uzuv kal\u0131plar\u0131 haz\u0131rlama, bas\u0131nca dayal\u0131 modifikasyonlar yapma ve kal\u0131p \u00fcretimi i\u00e7in tasarlanm\u0131\u015f bir masa\u00fcst\u00fc CAD (Bilgisayar Destekli Tasar\u0131m) yaz\u0131l\u0131m\u0131d\u0131r. Kullan\u0131c\u0131 aray\u00fcz\u00fc i\u00e7in PyQt5 ve 3D mesh i\u015flemleri i\u00e7in VTK'y\u0131 birle\u015ftirerek, etkile\u015fimli \u015fekillendirme, y\u00fcksek performans ve geni\u015fletilebilirlik \u00fczerine odaklanm\u0131\u015ft\u0131r. Yaz\u0131l\u0131m, 3D taray\u0131c\u0131dan gelen STL, OBJ, PLY gibi veri dosyalar\u0131n\u0131 manip\u00fcle edip ki\u015fiye \u00f6zel kal\u0131plar haz\u0131rlayarak bu kal\u0131plar\u0131n STL format\u0131nda 3B bask\u0131 al\u0131nmas\u0131n\u0131 sa\u011flar. Protez kal\u0131p rektifikasyonu (d\u00fczeltme/\u015fekillendirme) s\u00fcreci, ad\u0131m ad\u0131m ilerleyen rehberli bir i\u015f ak\u0131\u015f\u0131 (workflow) ile kullan\u0131c\u0131ya sunulur. 1.1. Dok\u00fcman\u0131n Amac\u0131 Bu dok\u00fcman\u0131n temel amac\u0131, ClonifyCad yaz\u0131l\u0131m\u0131n\u0131n teknik mimarisini, tasar\u0131m kararlar\u0131n\u0131, temel bile\u015fenlerini ve bu bile\u015fenler aras\u0131ndaki etkile\u015fimi detayl\u0131 bir \u015fekilde a\u00e7\u0131klamakt\u0131r. Bu belge, projenin mevcut ve gelecekteki geli\u015ftiricileri i\u00e7in bir referans kayna\u011f\u0131 olarak hizmet edecek, kodun s\u00fcrd\u00fcr\u00fclebilirli\u011fini ve geni\u015fletilebilirli\u011fini sa\u011flamak i\u00e7in bir yol haritas\u0131 sunacakt\u0131r. 1.2. Projenin Kapsam\u0131 Bu dok\u00fcman, yaz\u0131l\u0131m\u0131n a\u015fa\u011f\u0131daki \u00e7ekirdek i\u015flevselliklerini ve planlanan mod\u00fcllerini kapsar: Planlanan \u00d6zellikler: - STL, PLY, OBJ formatlar\u0131nda 3D model y\u00fckleme ve g\u00f6rselle\u015ftirme. - 2D se\u00e7imle 3D g\u00fcr\u00fclt\u00fc temizleme. - Model y\u00fczeyindeki deliklerin otomatik doldurulmas\u0131. - Etkile\u015fimli kesit bantlar\u0131 ile radyal deformasyon. - \"Bulge/Smooth\" f\u0131r\u00e7alar\u0131 ile serbest form modelleme. - Geri Al/\u0130leri Al (Undo/Redo) yetene\u011fi. - \u00c7oklu pencerede (multi-view) anatomik hizalama. - Otomatik \u00f6l\u00e7\u00fcm ve analiz ara\u00e7lar\u0131. - Bask\u0131 i\u00e7in 3D \u00e7\u0131kt\u0131 alma se\u00e7enekleri. Yaz\u0131l\u0131m\u0131n temel hedefleri: - Hastan\u0131n taranm\u0131\u015f uzuv verilerini dijital ortamda hassas bir \u015fekilde modellemek. - Protez kal\u0131plar\u0131n\u0131 dijital ortamda hassas bir \u015fekilde modellemek. - Ortopedi uzmanlar\u0131n\u0131n klinik bilgi ve deneyimlerini dijital s\u00fcrece entegre etmelerini sa\u011flamak. - Ki\u015fiye \u00f6zel, konforlu ve performansl\u0131 protezlerin \u00fcretimini h\u0131zland\u0131rmak ve kolayla\u015ft\u0131rmak. - Geleneksel kal\u0131plama y\u00f6ntemlerinin zorluklar\u0131n\u0131 (y\u00fcksek kilolu hasta, \u00e7ift tarafl\u0131 amputasyon, tekrarlanan d\u00fczeltmeler vb.) dijital \u00e7\u00f6z\u00fcmlerle a\u015fmak. 1.3. Tan\u0131mlar ve K\u0131saltmalar GUI : Grafiksel Kullan\u0131c\u0131 Aray\u00fcz\u00fc (Graphical User Interface) VTK : The Visualization Toolkit STL : Stereolithography (3D dosya format\u0131) PolyData : VTK'da poligon a\u011f\u0131n\u0131 (noktalar, h\u00fccreler) temsil eden temel veri yap\u0131s\u0131. Pipeline : Veri ak\u0131\u015f hatt\u0131. VTK'da verinin bir dizi filtreden ge\u00e7erek i\u015flenmesi. Frustum : Kesik piramit. 3D'de bir kamera g\u00f6r\u00fc\u015f alan\u0131n\u0131 tan\u0131mlayan geometrik hacim. PHI : (Personal Health Information) Ki\u015fisel Sa\u011fl\u0131k Bilgileri CAD : Bilgisayar Destekli Tasar\u0131m (Computer-Aided Design) CAM : Bilgisayar Destekli \u00dcretim (Computer-Aided Manufacturing) 3D : \u00dc\u00e7 Boyutlu (Three-Dimensional) Dimension Sheet : Boyut Tablosu 1.4. Uygulama \u0130\u015f Ak\u0131\u015f\u0131 Ad\u0131mlar\u0131 (Workflow Steps) Clonify Labs Modelleme Yaz\u0131l\u0131m\u0131, planlanan \u00f6zellikler do\u011frultusunda, kullan\u0131c\u0131y\u0131 ad\u0131m ad\u0131m y\u00f6nlendiren mant\u0131ksal bir i\u015f ak\u0131\u015f\u0131 sunar. Bu ak\u0131\u015f, ham tarama verisinden bask\u0131ya haz\u0131r 3D modele kadar olan s\u00fcreci kapsar ve her ad\u0131mda Geri Al/\u0130leri Al (Undo/Redo) yetene\u011fi ile desteklenir. Ad\u0131m 1: Veri Y\u00fckleme ve G\u00f6rselle\u015ftirme (Data Loading & Visualization) Amac\u0131: Hastadan al\u0131nan ham 3D tarama verisinin sisteme aktar\u0131lmas\u0131 ve incelenmesi. \u0130\u015flevselli\u011fi: Model \u0130\u00e7e Aktarma: Kullan\u0131c\u0131, STL , PLY , veya OBJ formatlar\u0131ndaki 3D modelleri yaz\u0131l\u0131ma y\u00fckler. 3D G\u00f6r\u00fcnt\u00fcleme: Y\u00fcklenen model, 3D g\u00f6r\u00fcnt\u00fcleme penceresinde serbest\u00e7e d\u00f6nd\u00fcr\u00fclebilir, kayd\u0131r\u0131labilir ve yak\u0131nla\u015ft\u0131r\u0131labilir bir \u015fekilde sunulur. Bu, modelin ilk genel de\u011ferlendirmesi i\u00e7in temel olu\u015fturur. Ad\u0131m 2: \u00c7oklu Tarama Birle\u015ftirme (Multi-Scan Registration)(Not Priority) Amac\u0131: Hastan\u0131n farkl\u0131 a\u00e7\u0131lardan veya zamanlarda yap\u0131lm\u0131\u015f birden fazla 3D taramas\u0131n\u0131 tek, b\u00fct\u00fcnsel bir modelde birle\u015ftirmek. Bu, eksik verileri tamamlamak ve daha eksiksiz bir anatomi olu\u015fturmak i\u00e7in gereklidir. \u0130\u015flevselli\u011fi: Otomatik Hizalama (Automated Registration): Yaz\u0131l\u0131m, ortak geometrik \u00f6zellikleri veya kullan\u0131c\u0131 taraf\u0131ndan belirlenen referans noktalar\u0131n\u0131 kullanarak birden fazla taramay\u0131 otomatik olarak hizalar. Manuel \u0130nce Ayar: Otomatik hizalaman\u0131n ard\u0131ndan, kullan\u0131c\u0131ya hizalamay\u0131 manuel olarak hassas bir \u015fekilde ayarlama imkan\u0131 sunulu, gerekirse. Model Birle\u015ftirme (Merging): Hizalanan taramalar, tek ve tutarl\u0131 bir 3D model olu\u015fturmak i\u00e7in birle\u015ftirilir. Bu birle\u015fik model, sonraki ad\u0131mlarda kullan\u0131lacak olan ana model haline gelir. Ad\u0131m 3: Tarama Temizleme ve Onar\u0131m (Scan Cleaning & Repair) Amac\u0131: Tarama s\u00fcrecinden kaynaklanan g\u00fcr\u00fclt\u00fc, artefakt ve geometrik kusurlar\u0131n giderilmesi. \u0130\u015flevselli\u011fi: 2D Se\u00e7imle G\u00fcr\u00fclt\u00fc Temizleme: Kullan\u0131c\u0131, 2D g\u00f6r\u00fcnt\u00fcleme d\u00fczleminde istenmeyen alanlar\u0131 (\u00f6rne\u011fin, tarama masas\u0131, destek yap\u0131lar\u0131, ilgisiz uzuvlar) se\u00e7erek 3D modelden kolayca kald\u0131r\u0131r. Otomatik Delik Doldurma: Yaz\u0131l\u0131m, model y\u00fczeyindeki istenmeyen delikleri ve bo\u015fluklar\u0131 ak\u0131ll\u0131 algoritmalarla tespit eder ve otomatik olarak kapatarak su ge\u00e7irmez (manifold) bir model olu\u015fturur. Ad\u0131m 4: Anatomik Hizalama (Anatomical Alignment) Amac\u0131: Modelin, standart bir anatomik referans sistemine g\u00f6re do\u011fru bir \u015fekilde konumland\u0131r\u0131lmas\u0131 ve y\u00f6nlendirilmesi. \u0130\u015flevselli\u011fi: \u00c7oklu Pencerede Hizalama: Kullan\u0131c\u0131, farkl\u0131 a\u00e7\u0131lardan (\u00f6n, yan, \u00fcst) g\u00f6sterilen model \u00fczerinde anatomik referans noktalar\u0131 belirler. Otomatik Y\u00f6nlendirme: Belirlenen noktalara g\u00f6re yaz\u0131l\u0131m, modeli otomatik olarak standart anatomik d\u00fczleme (\u00f6rne\u011fin, uzun ekseni Z eksenine paralel olacak \u015fekilde) hizalar. Ad\u0131m 5: Serbest Form Modelleme ve Deformasyon (Free-form Modeling & Deformation) Amac\u0131: Protez kal\u0131b\u0131n\u0131n hasta i\u00e7in en uygun ve konforlu hale getirilmesi amac\u0131yla model \u00fczerinde hassas geometrik de\u011fi\u015fiklikler yap\u0131lmas\u0131. \u0130\u015flevselli\u011fi: \"Bulge/Smooth\" F\u0131r\u00e7alar\u0131: Kullan\u0131c\u0131, f\u0131r\u00e7a benzeri ara\u00e7larla model y\u00fczeyinde sezgisel olarak hacim ekleme (\u015fi\u015firme), \u00e7\u0131karma (a\u015f\u0131nd\u0131rma) ve p\u00fcr\u00fczs\u00fczle\u015ftirme i\u015flemleri yapar. Bu, \u00f6zellikle bas\u0131n\u00e7 noktalar\u0131n\u0131 rahatlatmak veya destek alanlar\u0131 olu\u015fturmak i\u00e7in kullan\u0131l\u0131r. Etkile\u015fimli Kesit Bantlar\u0131 ile Radyal Deformasyon: Model \u00fczerine yerle\u015ftirilen kesit bantlar\u0131 arac\u0131l\u0131\u011f\u0131yla, belirli b\u00f6lgelerde dairesel (radyal) olarak hassas boyutland\u0131rma (geni\u015fletme/daraltma) yap\u0131l\u0131r. Bu, uzvun \u00e7evresel \u00f6l\u00e7\u00fclerine tam uyum sa\u011flamak i\u00e7in kritiktir. Ad\u0131m 6: \u00d6l\u00e7\u00fcm ve Analiz (Measurement & Analysis) Amac\u0131: Yap\u0131lan modifikasyonlar\u0131n do\u011frulu\u011funu teyit etmek ve klinik gereksinimlere uygunlu\u011funu kontrol etmek. \u0130\u015flevselli\u011fi: Otomatik \u00d6l\u00e7\u00fcm Ara\u00e7lar\u0131: Yaz\u0131l\u0131m, model \u00fczerinde uzunluk, \u00e7evre, a\u00e7\u0131 ve hacim gibi kritik \u00f6l\u00e7\u00fcmleri otomatik olarak yapabilir. Bu, tasar\u0131m\u0131n say\u0131sal verilerle do\u011frulanmas\u0131n\u0131 sa\u011flar. Analiz: \u0130ki model aras\u0131ndaki farklar\u0131 veya belirli b\u00f6lgelerdeki de\u011fi\u015fiklikleri g\u00f6rsel ve say\u0131sal olarak analiz etme imkan\u0131 sunar. Ad\u0131m 7: Bask\u0131ya Haz\u0131rl\u0131k ve \u00c7\u0131kt\u0131 (Print Preparation & Export) Amac\u0131: Tamamlanan modelin 3D yaz\u0131c\u0131da bas\u0131lmak \u00fczere haz\u0131rlanmas\u0131. \u0130\u015flevselli\u011fi: Model Sonland\u0131rma: Modelin bask\u0131ya uygunlu\u011fu (\u00f6rne\u011fin, duvar kal\u0131nl\u0131\u011f\u0131 kontrol\u00fc) son kez denetlenir. 3D \u00c7\u0131kt\u0131 Alma: Nihai model, 3D bask\u0131 i\u00e7in yayg\u0131n olarak kullan\u0131lan STL veya di\u011fer formatlarda d\u0131\u015fa aktar\u0131l\u0131r. 3. Hedefler ve Ama\u00e7lar Klinisyenlere/teknisyenlere anatomik mesh'leri hassas bir \u015fekilde d\u00fczeltmek i\u00e7in ara\u00e7lar sa\u011flamak. G\u00f6rsel geri bildirim (\u0131s\u0131 haritas\u0131) ile bas\u0131nca dayal\u0131 ayarlamalar\u0131 desteklemek. Tekrarlanabilir bir \u015fekilde deplasman tabanl\u0131 kal\u0131plar \u00fcretmek (\u00f6rn. ayn\u0131 bas\u0131n\u00e7 haritas\u0131 ve parametrelerle, deterministik test mesh'leri ve prosed\u00fcrel kaynaklar kullan\u0131larak her seferinde ayn\u0131 sonu\u00e7lar\u0131n elde edilmesi; \u00f6rnek i\u00e7in bkz. \"Test Stratejisi\" ve \"\u00c7ekirdek Alan Modelleri\" b\u00f6l\u00fcmleri). Yo\u011fun geometri operasyonlar\u0131 s\u0131ras\u0131nda duyarl\u0131 bir kullan\u0131c\u0131 aray\u00fcz\u00fc s\u00fcrd\u00fcrmek. Gelecekteki ara\u00e7lar (kesme desenleri, \u015fekillendirme, i\u015faretleme, GPU h\u0131zland\u0131rma) i\u00e7in mod\u00fcler bir arka u\u00e7 sunmak. Tekrarlanabilirli\u011fi sa\u011flamak (deterministik test mesh'leri, prosed\u00fcrel kaynaklar). 4. Payda\u015flar Klinik protez teknisyenleri (birincil kullan\u0131c\u0131lar). Hastane merkezleri. Dahili geli\u015ftiriciler (ara\u00e7 zinciri geni\u015fletme). QA/test personeli (do\u011frulama senaryolar\u0131). 5. \u00dcst D\u00fczey Mimari Yaz\u0131l\u0131m, katmanl\u0131 mimari yakla\u015f\u0131m\u0131n\u0131 benimseyerek mod\u00fcler, s\u00fcrd\u00fcr\u00fclebilir ve geni\u015fletilebilir bir yap\u0131 sunmaktad\u0131r. Bu mimari, g\u00f6revleri net bir \u015fekilde ay\u0131rarak kodun karma\u015f\u0131kl\u0131\u011f\u0131n\u0131 azalt\u0131r. 5.1. Katmanl\u0131 Mimari Yakla\u015f\u0131m\u0131 Yaz\u0131l\u0131m, kodun y\u00f6netilebilirli\u011fini ve mod\u00fclerli\u011fini sa\u011flamak amac\u0131yla, g\u00f6revleri net bir \u015fekilde ayr\u0131\u015ft\u0131ran \u00fc\u00e7 katmanl\u0131 bir mimari \u00fczerine in\u015fa edilmi\u015ftir. Bu yap\u0131, Model-View-Controller (MVC) tasar\u0131m deseninden g\u00fc\u00e7l\u00fc bir \u015fekilde ilham alm\u0131\u015ft\u0131r. 5.2. Katmanlar\u0131n Detayl\u0131 Analizi Katman Sorumluluk Teknolojiler / Bile\u015fenler Sunum (Presentation) Kullan\u0131c\u0131 etkile\u015fimini y\u00f6netir, g\u00f6rsel bile\u015fenleri sunar ve kullan\u0131c\u0131 girdilerini al\u0131r. PyQt (Widget'lar, Sinyaller/Slotlar), VTK (3D Render Penceresi) Uygulama (Application) Aray\u00fczden gelen istekleri i\u015fler, i\u015f mant\u0131\u011f\u0131n\u0131 koordine eder ve servisleri \u00e7a\u011f\u0131r\u0131r. Ana uygulama s\u0131n\u0131f\u0131, olay y\u00f6neticileri, UI ve servisler aras\u0131 k\u00f6pr\u00fc. Servisler (Services) Belirli i\u015flevleri (\u00f6rn: dosya I/O, mesh i\u015fleme) kaps\u00fclleyen senkron veya asenkron operasyonlar\u0131 y\u00fcr\u00fct\u00fcr. VTKProcessor , AsyncMeshProcessor , API istemcileri. Arka U\u00e7 (Backend) Yo\u011fun hesaplama gerektiren \u00f6zel alan operasyonlar\u0131n\u0131 ve algoritmalar\u0131 i\u00e7erir. Bas\u0131n\u00e7 haritalama, kal\u0131p olu\u015fturma, hizalama algoritmalar\u0131. Alan Modelleri (Domain) Uygulaman\u0131n durumunu ve temel veri yap\u0131lar\u0131n\u0131 (\u00f6rn: mesh, oturum bilgileri, geri alma y\u0131\u011f\u0131n\u0131) temsil eder. AnatomySession , vtkPolyData , PressureDict . Altyap\u0131 (Infrastructure) Veri depolama, loglama, konfig\u00fcrasyon ve harici sistemlerle ileti\u015fimi y\u00f6netir. Dosya sistemi, veritaban\u0131 ba\u011flant\u0131lar\u0131, loglama k\u00fct\u00fcphanesi. 7. Kullan\u0131lan Teknolojiler ve K\u00fct\u00fcphaneler Projenin geli\u015ftirilmesinde, a\u00e7\u0131k kaynak kodlu, end\u00fcstri standard\u0131, y\u00fcksek performansl\u0131 ve geni\u015f topluluk deste\u011fine sahip teknolojiler tercih edilecektir. 7.1. Ana Programlama Dili: Python 3.10 Python , h\u0131zl\u0131 prototipleme, temiz s\u00f6zdizimi ve zengin k\u00fct\u00fcphane deste\u011fi sayesinde projenin ana dili olarak se\u00e7ilmi\u015ftir. \u00d6zellikle bilimsel hesaplama ve veri analizi alanlar\u0131ndaki g\u00fcc\u00fc, medikal veri i\u015fleme do\u011fas\u0131yla \u00f6rt\u00fc\u015fmektedir. Python'un \"yap\u0131\u015ft\u0131r\u0131c\u0131 dil\" \u00f6zelli\u011fi, VTK gibi C++ k\u00fct\u00fcphanelerinin kolayca entegre edilmesini sa\u011flam\u0131\u015ft\u0131r. 7.2. Grafiksel Kullan\u0131c\u0131 Aray\u00fcz\u00fc (GUI): PyQt5 PyQt5 , platformdan ba\u011f\u0131ms\u0131z masa\u00fcst\u00fc uygulamalar\u0131 geli\u015ftirmek i\u00e7in kullan\u0131lan, Qt C++ k\u00fct\u00fcphanesinin Python versiyonudur. - Olgunluk ve Kararl\u0131l\u0131k: Kararl\u0131 ve g\u00fcvenilir bir aray\u00fcz \u00e7at\u0131s\u0131d\u0131r. - Sinyal ve Slot Mekanizmas\u0131: Aray\u00fcz elemanlar\u0131 ile program mant\u0131\u011f\u0131 aras\u0131nda esnek ve ayr\u0131\u015ft\u0131r\u0131lm\u0131\u015f ileti\u015fim sa\u011flar. - Geni\u015f Widget Seti: Karma\u015f\u0131k ve profesyonel bir kullan\u0131c\u0131 aray\u00fcz\u00fcn\u00fcn h\u0131zl\u0131ca olu\u015fturulmas\u0131na olanak tan\u0131r. - VTK Entegrasyonu: QVTKRenderWindowInteractor widget'\u0131 sayesinde, VTK 'n\u0131n 3D render pencerelerinin bir Qt uygulamas\u0131 i\u00e7ine sorunsuz entegrasyonu sa\u011flar. 7.3. 3D G\u00f6rselle\u015ftirme ve \u0130\u015fleme Motoru: VTK (The Visualization Toolkit) VTK , bilimsel ve medikal verilerin 3 boyutlu olarak i\u015flenmesi, g\u00f6rselle\u015ftirilmesi ve analizi i\u00e7in tasarlanm\u0131\u015f, C++ tabanl\u0131, y\u00fcksek performansl\u0131 bir k\u00fct\u00fcphanedir. Projenin 3D ile ilgili t\u00fcm a\u011f\u0131r i\u015flerini VTK \u00fcstlenir. - Veri Ak\u0131\u015f Hatt\u0131 Mimarisi (Pipeline Architecture): Source -> Filter -> Mapper -> Actor \u015feklindeki veri ak\u0131\u015f modeli, karma\u015f\u0131k 3D veri i\u015fleme zincirlerinin mod\u00fcler ve verimli bir \u015fekilde olu\u015fturulmas\u0131n\u0131 sa\u011flar. - Zengin Filtre K\u00fct\u00fcphanesi: vtkClipPolyData , vtkTransformPolyDataFilter ve vtkSTLReader gibi y\u00fczlerce haz\u0131r algoritma i\u00e7erir. Gelecekte vtkFillHolesFilter , vtkSmoothPolyDataFilter gibi filtreler de kullan\u0131lacakt\u0131r. - Geli\u015fmi\u015f Etkile\u015fim Mekanizmalar\u0131: vtkRenderWindowInteractor ve vtkInteractorStyle alt s\u0131n\u0131flar\u0131, fare ve klavye ile karma\u015f\u0131k 3D sahne etkile\u015fimleri olu\u015fturmak i\u00e7in g\u00fc\u00e7l\u00fc bir altyap\u0131 sunar. 7.4. Matematiksel ve Bilimsel Hesaplama: NumPy NumPy , Python'da bilimsel hesaplamalar i\u00e7in temel pakettir. \u00c7ok boyutlu diziler \u00fczerinde y\u00fcksek performansl\u0131 matematiksel i\u015flemler i\u00e7in kullan\u0131l\u0131r. - Performans: B\u00fcy\u00fck veri k\u00fcmeleri \u00fczerinde h\u0131zl\u0131 hesaplamalar sa\u011flar. - Vekt\u00f6r Matemati\u011fi: Anatomik hizalama ve deformasyon algoritmalar\u0131nda vekt\u00f6r ve matris i\u015flemleri i\u00e7in kullan\u0131l\u0131r. - VTK Uyumlulu\u011fu: vtk.util.numpy_support mod\u00fcl\u00fc, NumPy dizileri ile VTK veri dizileri aras\u0131nda verimli veri al\u0131\u015fveri\u015fi sa\u011flar. 8. \u00c7ekirdek Fonksiyonlar\u0131n Mant\u0131ksal Ak\u0131\u015f\u0131 8.1. Fonksiyon: Mesh Y\u00fckleme Ama\u00e7: Harici bir dosyadan (\u00f6rn: .stl, .ply) 3D mesh verilerini uygulamaya y\u00fcklemek ve g\u00f6rselle\u015ftirmek. Mant\u0131ksal Ak\u0131\u015f: 1. UI Talebi: Kullan\u0131c\u0131, UI sayfas\u0131ndan bir mesh y\u00fckleme iste\u011fi ba\u015flat\u0131r (dosya yolu ile). 2. \u0130\u015flem Ba\u015flang\u0131c\u0131 Sinyali: Kontrol Katman\u0131, UI'a bir \"processingStarted\" sinyali g\u00f6nderir. 3. Dosya Okuma: VTKProcessor (Hizmet Katman\u0131), dosya uzant\u0131s\u0131na g\u00f6re uygun VTK okuyucusunu ( vtkSTLReader , vtkPLYReader ) se\u00e7er. 4. Mesh Y\u00fckleme: Okuyucu, 3D mesh verilerini ( vtkPolyData ) belle\u011fe y\u00fckler. 5. Orijinal Veri Kopyas\u0131: Y\u00fcklenen mesh'in derin bir kopyas\u0131 original_poly_data olarak saklan\u0131r. 6. Aktif Veri Ayar\u0131: Y\u00fcklenen mesh, active_poly_data olarak ayarlan\u0131r. 7. Ge\u00e7mi\u015f Y\u0131\u011f\u0131n\u0131na Ekleme: Uygulaman\u0131n ba\u015flang\u0131\u00e7 durumu, HistoryStack 'e ilk \"i\u015flem\" olarak eklenir. 8. Mesh Y\u00fcklendi Sinyali: VTKProcessor , y\u00fcklendi\u011fini ve active_poly_data 'y\u0131 referans alarak \"meshLoaded\" sinyali g\u00f6nderir. 9. \u0130\u015flem Tamamland\u0131 Sinyali: Son olarak, \"processingFinished\" sinyali g\u00f6nderilir. 10. UI G\u00fcncelleme: UI, update_renderer metoduyla yeni active_poly_data 'y\u0131 g\u00f6rselle\u015ftirmek \u00fczere g\u00fcncellenir. 11. MESH kalitesi artt\u0131rma : Y\u00fcklenen mesh verileri, VTKProcessor taraf\u0131ndan \u00e7e\u015fitli iyile\u015ftirme teknikleri (\u00f6rn: y\u00fczey p\u00fcr\u00fczs\u00fczle\u015ftirme, kenar keskinle\u015ftirme) ile i\u015flenir. 8.2. Fonksiyon: Bas\u0131n\u00e7 Boyama Ama\u00e7: Kullan\u0131c\u0131n\u0131n 3D mesh \u00fczerinde fare ile \u00e7izim yaparak her bir noktaya (vertex) bir bas\u0131n\u00e7 de\u011feri atamas\u0131n\u0131 sa\u011flamak ve bunu g\u00f6rselle\u015ftirmek (\u0131s\u0131 haritas\u0131). Mant\u0131ksal Ak\u0131\u015f: 1. F\u0131r\u00e7a Se\u00e7imi: Kullan\u0131c\u0131 UI'dan bir f\u0131r\u00e7a (boyut, sertlik, g\u00fc\u00e7) se\u00e7er. 2. Uzamsal Sorgu Ba\u015flatma: vtkStaticPointLocator nesnesi (h\u0131zl\u0131 uzamsal sorgular i\u00e7in \u00f6nceden olu\u015fturulmu\u015f/\u00f6nbelle\u011fe al\u0131nm\u0131\u015f) ba\u015flat\u0131l\u0131r. 3. \u00c7izim Ba\u015flang\u0131c\u0131: Kullan\u0131c\u0131 fareyi mesh \u00fczerinde s\u00fcr\u00fcklemeye ba\u015flad\u0131\u011f\u0131nda, ge\u00e7erli f\u0131r\u00e7a vuru\u015fu i\u00e7in bir tampon (buffer) temizlenir. 4. F\u0131r\u00e7a Hareketi: Kullan\u0131c\u0131 farenin bas\u0131l\u0131 tutarak mesh \u00fczerinde hareket etmesiyle ( mouse_moved olay\u0131), PressureTool \u015fu ad\u0131mlar\u0131 izler: - F\u0131r\u00e7a merkezi \u00e7evresindeki noktalar (radius) bir uzamsal sorgu ile bulunur. - Her etkilenen nokta i\u00e7in, f\u0131r\u00e7a merkezine olan uzakl\u0131\u011fa g\u00f6re bir \"a\u011f\u0131rl\u0131k\" (weight) veya etki d\u00fc\u015f\u00fc\u015f\u00fc (falloff) hesaplan\u0131r. - Yeni bas\u0131n\u00e7 de\u011feri (\u00f6rn: yeni_basinc = mevcut_basinc + guc * agirlik ) hesaplan\u0131r ve -100 ile 100 aras\u0131nda bir de\u011fere clamped edilir. - Noktan\u0131n ID'si, eski de\u011feri ve yeni de\u011feri bir vuru\u015f tamponuna ( stroke buffer ) kaydedilir (bu nokta ilk kez de\u011fi\u015ftiriliyorsa). - Bas\u0131n\u00e7 de\u011ferleri, haf\u0131zadaki pressure_dict 'te g\u00fcncellenir. - Bu de\u011fi\u015fiklikler, vtkFloatArray olan PressureValues skaler dizisine yans\u0131t\u0131l\u0131r ve render iste\u011fi, UI'da ger\u00e7ek zamanl\u0131 g\u00f6rsel geri bildirim sa\u011flamak i\u00e7in gruplan\u0131r (throttled). 5. \u00c7izim Sonu: Kullan\u0131c\u0131 fareyi b\u0131rakt\u0131\u011f\u0131nda ( mouse_released olay\u0131), t\u00fcm vuru\u015f tamponu, geri alma/ileri alma y\u0131\u011f\u0131n\u0131na ( HistoryStack ) bir \"i\u015flem\" olarak eklenir. 8.3. Fonksiyon: Is\u0131 Haritas\u0131 Olu\u015fturma (Asenkron) Ama\u00e7: pressure_dict 'teki bas\u0131n\u00e7 de\u011ferlerini mesh \u00fczerinde g\u00f6rsel olarak bir \u0131s\u0131 haritas\u0131 olarak g\u00f6stermek. Performans i\u00e7in asenkron (arka planda) olarak \u00e7al\u0131\u015f\u0131r. Mant\u0131ksal Ak\u0131\u015f: 1. UI \u0130ste\u011fi: Kullan\u0131c\u0131, UI'dan \u0131s\u0131 haritas\u0131 olu\u015fturma talebini tetikler. 2. Asenkron Kuyruk: Kontrol Katman\u0131, bu operasyonu AsyncMeshProcessor 'a (ayr\u0131 bir thread) s\u0131raya al\u0131r. 3. Thread Ba\u015flatma: Ayr\u0131 bir thread'de (i\u015flemciyi dondurmamak i\u00e7in) AsyncMeshProcessor \u00e7al\u0131\u015fmaya ba\u015flar. 4. Skaler Dizi Olu\u015fturma/G\u00fcncelleme: Thread, pressure_dict 'teki de\u011ferleri kullanarak veya g\u00fcncelleyerek vtkFloatArray tipinde bir PressureValues skaler dizisi olu\u015fturur/g\u00fcnceller. 5. Tamamlanma Sinyali: \u0130\u015flem tamamland\u0131\u011f\u0131nda, thread, sonu\u00e7 meta verileriyle (\u00f6rn: de\u011fer aral\u0131\u011f\u0131) bir processing_complete sinyali g\u00f6nderir. 6. UI G\u00fcncelleme: Kontrol Katman\u0131, bu sinyali ana thread'de yakalar. Is\u0131 haritas\u0131n\u0131n renk d\u00f6n\u00fc\u015f\u00fcm\u00fc i\u00e7in vtkLookupTable (LUT) yap\u0131land\u0131r\u0131l\u0131r ve bu LUT'ye g\u00f6re renderer g\u00fcncellenir. 8.4. Fonksiyon: Kal\u0131p Olu\u015fturma Ama\u00e7: Mesh'in PressureValues '\u0131na dayal\u0131 olarak protez kal\u0131b\u0131n\u0131 (deforme edilmi\u015f mesh) olu\u015fturmak. Mant\u0131ksal Ak\u0131\u015f: 1. Is\u0131 Haritas\u0131 Garantisi: \u0130\u015flem ba\u015flamadan \u00f6nce PressureValues '\u0131n do\u011fru bir \u015fekilde hesaplanm\u0131\u015f ve meshe atanm\u0131\u015f oldu\u011fundan emin olunur. 2. Deplasman Skaleri Hesaplama: Her bir nokta i\u00e7in bir deplasman skaleri ( displacement_scalar ) hesaplan\u0131r. Bu genellikle atanm\u0131\u015f bas\u0131n\u00e7 de\u011ferinin ( pressure_value ) bir warp_scale fakt\u00f6r\u00fc ile \u00e7arp\u0131lmas\u0131yla elde edilir (\u00f6rn: displacement_scalar = -pressure_value * warp_scale ). Negatif de\u011ferler, materyalin d\u0131\u015far\u0131 do\u011fru itilmesi anlam\u0131na gelir. 3. Geometri Deformasyonu: - Modeldeki her bir noktan\u0131n normal vekt\u00f6r\u00fc al\u0131n\u0131r. - Noktan\u0131n yeni konumu, yeni_konum = mevcut_konum + deplasman_skaleri * normal_vekt\u00f6r form\u00fcl\u00fcyle hesaplan\u0131r. - Bu, vtkWarpVector filtresi veya manuel nokta deplasman\u0131 algoritmalar\u0131 kullan\u0131larak ger\u00e7ekle\u015ftirilebilir. 4. MoldDisplacement Kayd\u0131: Hesaplanan deplasman de\u011ferleri, daha sonra tekrarlanabilirlik ve analiz i\u00e7in MoldDisplacement ad\u0131nda yeni bir skaler dizi olarak meshe atanabilir. 5. G\u00fcncelleme: Deforme olmu\u015f PolyData , active_poly_data olarak ayarlan\u0131r ve HistoryStack 'e eklenir. Render g\u00fcncellenir. 6. Meta Veri: Olu\u015fturulan kal\u0131b\u0131n \u00f6l\u00e7e\u011fi, minimum/maksimum deplasman gibi meta veriler, daha sonra raporlama veya analiz i\u00e7in kaydedilir. 8.5. Fonksiyon: Tarama Temizleme Ama\u00e7: Kullan\u0131c\u0131n\u0131n 2D bir se\u00e7imle 3D modelin istenmeyen k\u0131s\u0131mlar\u0131n\u0131 (\u00f6rn: tarama g\u00fcr\u00fclt\u00fcs\u00fc, gereksiz arka plan) silmesi. Mant\u0131ksal Ak\u0131\u015f: 1. Giri\u015f: Kullan\u0131c\u0131, 3D g\u00f6r\u00fcnt\u00fcleme penceresinde 2D bir dikd\u00f6rtgen veya serbest form bir alan \u00e7izer (fare s\u00fcr\u00fcklemesi ile). 2. 2D -> 3D D\u00f6n\u00fc\u015f\u00fcm: Sistem (VTK Picker ve Frustum s\u0131n\u0131flar\u0131), bu 2D se\u00e7im alan\u0131n\u0131, 3D uzayda bir se\u00e7im hacmine (frustum veya bounding box) d\u00f6n\u00fc\u015ft\u00fcr\u00fcr. Bu hacim, kameran\u0131n bak\u0131\u015f a\u00e7\u0131s\u0131 ve derinli\u011fi dikkate al\u0131narak olu\u015fturulur. 3. Kesme \u0130\u015flemi: Se\u00e7ilen 3D hacmin i\u00e7inde veya d\u0131\u015f\u0131nda kalan (kullan\u0131c\u0131n\u0131n se\u00e7imine ba\u011fl\u0131 olarak) t\u00fcm 3D geometri ( PolyData 'n\u0131n noktalar\u0131 ve h\u00fccreleri), vtkClipPolyData veya benzeri bir filtre kullan\u0131larak modelden \u00e7\u0131kar\u0131l\u0131r. 4. G\u00fcncelleme: Temizlenmi\u015f PolyData nesnesi, yeni \"Aktif Veri\" olarak ayarlan\u0131r ve HistoryStack 'e yeni bir i\u015flem olarak eklenir. Aray\u00fcz g\u00fcncellenir. 8.6. Fonksiyon: Anatomik Hizalama Ama\u00e7: 3D modeli (\u00f6rne\u011fin, ampute uzuv taramas\u0131), standart bir anatomik koordinat sistemine g\u00f6re yeniden y\u00f6nlendirmek (\u00f6rn: uzvun uzun eksenini Z eksenine, \u00f6n-arka y\u00f6n\u00fcn\u00fc Y eksenine hizalamak). Mant\u0131ksal Ak\u0131\u015f: 1. Giri\u015f: Kullan\u0131c\u0131, model \u00fczerinde stratejik anatomik referans noktalar\u0131n\u0131 i\u015faretler (\u00f6rn: b\u00fcy\u00fck trokanter, lateral/medial epikondil, distal u\u00e7). Bu noktalar, 3D uzayda vtkPointPicker gibi ara\u00e7larla se\u00e7ilir ve koordinatlar\u0131 saklan\u0131r. 2. Koordinat Sistemi Hesaplama: Sistem ( NumPy ve lineer cebir fonksiyonlar\u0131 kullanarak), i\u015faretlenen bu noktalardan yola \u00e7\u0131karak yeni bir anatomik koordinat sistemi (yeni X, Y, Z eksenleri) hesaplar. \u00d6rne\u011fin, uzvun uzun ekseni iki nokta aras\u0131ndaki vekt\u00f6rden, \u00f6n-arka ekseni ise di\u011fer noktalar\u0131n konumlar\u0131na g\u00f6re belirlenir. 3. D\u00f6n\u00fc\u015f\u00fcm Matrisi Olu\u015fturma: Modelin mevcut koordinat sistemi ile yeni hesaplanan anatomik koordinat sistemi aras\u0131nda ge\u00e7i\u015fi sa\u011flayacak bir d\u00f6n\u00fc\u015f\u00fcm (rotasyon ve translasyon) matrisi ( vtkTransform ) olu\u015fturulur. 4. Model Hizalama: vtkTransformPolyDataFilter kullan\u0131larak, t\u00fcm PolyData bu matris ile d\u00f6nd\u00fcr\u00fcl\u00fcr ve hizalanm\u0131\u015f olur. 5. G\u00fcncelleme: Hizalanm\u0131\u015f PolyData nesnesi \"Aktif Veri\" olarak kaydedilir ve HistoryStack g\u00fcncellenir. 8.7. Fonksiyon: Hacimsel Deformasyon Ama\u00e7: Protez soketinin belirli b\u00f6lgelerinde (\u00f6rn: y\u00fck ta\u015f\u0131yan alanlar, hassas kemik b\u00f6lgeleri) \u00f6l\u00e7\u00fcleri hassas bir \u015fekilde art\u0131rmak (hacim ekleme) veya azaltmak (hacim \u00e7\u0131karma/s\u0131k\u0131\u015ft\u0131rma). Mant\u0131ksal Ak\u0131\u015f: 1. Giri\u015f: Kullan\u0131c\u0131, model \u00fczerinde deforme etmek istedi\u011fi bir b\u00f6lgeyi (\u00f6rn: kesit bantlar\u0131 ile, veya manuel f\u0131r\u00e7a ile) ve uygulanacak deformasyon miktar\u0131n\u0131 (+/- mm) tan\u0131mlar. 2. Nokta Se\u00e7imi ve Etki Alan\u0131: Sistem, tan\u0131mlanan b\u00f6lge i\u00e7indeki t\u00fcm 3D noktalar\u0131 belirler. Bir f\u0131r\u00e7a kullan\u0131l\u0131yorsa, f\u0131r\u00e7a merkezine olan uzakl\u0131\u011fa g\u00f6re bir \"etki d\u00fc\u015f\u00fc\u015f\u00fc\" (falloff) fonksiyonu hesaplan\u0131r. 3. Deformasyon Uygulama: - Her bir se\u00e7ili nokta i\u00e7in, noktan\u0131n y\u00fczey normal vekt\u00f6r\u00fc hesaplan\u0131r. - Nokta, belirlenen deformasyon miktar\u0131 ve falloff fonksiyonuna g\u00f6re (y\u00fczey normali boyunca) i\u00e7e (azaltma) veya d\u0131\u015fa (art\u0131rma) do\u011fru hareket ettirilir. - Bu i\u015flem, PolyData 'n\u0131n nokta koordinatlar\u0131n\u0131 do\u011frudan de\u011fi\u015ftirerek ger\u00e7ekle\u015ftirilir. 4. G\u00fcncelleme: Deforme olmu\u015f PolyData nesnesi \"Aktif Veri\" olarak ayarlan\u0131r ve HistoryStack 'e eklenir. 9. Kullan\u0131c\u0131 Etkile\u015fim Tasar\u0131m\u0131 9.1. Mod\u00fcler Etkile\u015fim Stilleri Uygulama, farkl\u0131 g\u00f6revler i\u00e7in farkl\u0131 fare ve klavye davran\u0131\u015flar\u0131 gerektirir. Bu, VTK 'n\u0131n vtkInteractorStyle s\u0131n\u0131f\u0131ndan t\u00fcretilen \"Etkile\u015fim Stilleri\" ad\u0131 verilen de\u011fi\u015ftirilebilir mod\u00fcllerle y\u00f6netilir. MainWindow (Controller), kullan\u0131c\u0131n\u0131n se\u00e7ti\u011fi araca g\u00f6re bu stiller aras\u0131nda dinamik olarak ge\u00e7i\u015f yapar. Kamera Stili (Varsay\u0131lan): Varsay\u0131lan mod. Kullan\u0131c\u0131n\u0131n 3D sahneyi serbest\u00e7e d\u00f6nd\u00fcrme, kayd\u0131rma ve yak\u0131nla\u015ft\u0131rma i\u015flemlerini (fare tekerle\u011fi, sol/orta/sa\u011f t\u0131klama ve s\u00fcr\u00fckleme ile) sa\u011flar. (\u00d6rn: vtkInteractorStyleTrackballCamera ). Se\u00e7im Stili: Tarama Temizleme arac\u0131 aktifken, kullan\u0131c\u0131n\u0131n 2D bir dikd\u00f6rtgen veya serbest form se\u00e7im alan\u0131 \u00e7izmesini sa\u011flar. Bu 2D se\u00e7im, 3D uzayda geometriyi kesmek veya filtrelemek i\u00e7in kullan\u0131l\u0131r. (\u00d6rn: vtkInteractorStyleRubberBand2D veya \u00f6zel bir interakt\u00f6r stili). \u0130\u015faretleme Stili: Anatomik Hizalama arac\u0131 aktifken, kullan\u0131c\u0131n\u0131n model \u00fczerinde belirli 3D noktalar\u0131 (\u00f6rn: kemik i\u015faretleri) t\u0131klayarak se\u00e7mesini sa\u011flar. Se\u00e7ilen noktalar, daha sonra d\u00f6n\u00fc\u015f\u00fcm matrisleri hesaplamak i\u00e7in kullan\u0131l\u0131r. (\u00d6rn: vtkInteractorStyleTrackballCamera ile birlikte vtkPointPicker kullan\u0131larak \u00f6zelle\u015ftirilmi\u015f bir stil). F\u0131r\u00e7a/Heykel Stili: Oyma/Ekleme veya Yumu\u015fatma ara\u00e7lar\u0131 aktifken, kullan\u0131c\u0131n\u0131n fareyi model \u00fczerinde s\u00fcr\u00fckleyerek lokal deformasyonlar veya yumu\u015fatmalar yapmas\u0131n\u0131 sa\u011flar. F\u0131r\u00e7a imleci ve etki alan\u0131 g\u00f6rselle\u015ftirilir. (\u00d6zel bir vtkInteractorStyle alt s\u0131n\u0131f\u0131). 15. Mesh \u0130\u015flemleri (Temsili) Clonify Labs , protez kal\u0131plar\u0131n\u0131 haz\u0131rlamak ve d\u00fczeltmek i\u00e7in \u00e7e\u015fitli temel mesh i\u015fleme operasyonlar\u0131n\u0131 kullan\u0131r. Bu operasyonlar VTK k\u00fct\u00fcphanesinin g\u00fcc\u00fcn\u00fc kullan\u0131r. Operasyon Tekni\u011fi / VTK Filtresi A\u00e7\u0131klama Temizleme (Clean) vtkCleanPolyData Mesh'teki fazladan (duplicate) noktalar\u0131 birle\u015ftirmek, k\u00fc\u00e7\u00fck a\u00e7\u0131kl\u0131klar\u0131 kapatmak ve genel topolojik temizlik yapmak i\u00e7in kullan\u0131l\u0131r. Tarama verilerindeki hatalar\u0131 gidermede \u00f6nemlidir. Yumu\u015fatma (Smooth) (Taubin/Laplacian) vtkSmoothPolyDataFilter veya \u00f6zelle\u015fmi\u015f filtreler Mesh y\u00fczeyindeki p\u00fcr\u00fczl\u00fcl\u00fc\u011f\u00fc azalt\u0131r, k\u00f6\u015feleri yumu\u015fat\u0131r ve daha organik bir g\u00f6r\u00fcn\u00fcm sa\u011flar. Konfor a\u00e7\u0131s\u0131ndan kritik bir ad\u0131md\u0131r. Basitle\u015ftirme (Decimate) vtkDecimatePro ile hedef azaltma oran\u0131 Mesh'in poligon say\u0131s\u0131n\u0131 azalt\u0131r. Dosya boyutunu k\u00fc\u00e7\u00fclt\u00fcr ve i\u015flem performans\u0131n\u0131 art\u0131r\u0131r, ancak modelin detay seviyesini d\u00fc\u015f\u00fcrebilir. Alt B\u00f6l\u00fcmlere Ay\u0131rma (Subdivide) vtkLoopSubdivisionFilter (ayarlanabilir iterasyonlar) Mesh'in poligon say\u0131s\u0131n\u0131 art\u0131r\u0131r, y\u00fczeylere daha fazla detay ekler ve daha p\u00fcr\u00fczs\u00fcz k\u0131vr\u0131mlar sa\u011flar. \u00d6zellikle manuel \u015fekillendirme i\u00e7in daha fazla kontrol sa\u011flar. Normallerin Yeniden Hesaplanmas\u0131 vtkPolyDataNormals (modifikasyon sonras\u0131) Mesh \u00fczerinde yap\u0131lan deformasyonlar sonras\u0131 noktalar\u0131n ve y\u00fczeylerin normal vekt\u00f6rlerini yeniden hesaplar. Do\u011fru g\u00f6rselle\u015ftirme ve sonraki i\u015flemler (\u00f6rn: kal\u0131nl\u0131k verme) i\u00e7in esast\u0131r. \u00c7arp\u0131tma (Warp) (Kal\u0131p i\u00e7in) vtkWarpVector veya manuel nokta deplasman\u0131 Kal\u0131p olu\u015fturma s\u00fcrecinde, belirli bir y\u00f6nde (genellikle y\u00fczey normali boyunca) ve belirli bir miktar kadar noktalar\u0131 kayd\u0131rarak mesh'i deforme eder. Bas\u0131n\u00e7 de\u011ferleri bu deplasman miktar\u0131n\u0131 belirleyebilir. 16. Performans Stratejileri Yaz\u0131l\u0131m\u0131n yo\u011fun 3D i\u015flemler s\u0131ras\u0131nda bile kullan\u0131c\u0131 aray\u00fcz\u00fcn\u00fcn (UI) duyarl\u0131 kalmas\u0131n\u0131 sa\u011flamak i\u00e7in \u00e7e\u015fitli performans optimizasyon stratejileri uygulanm\u0131\u015ft\u0131r. Endi\u015fe Teknik UI Donmas\u0131 \u0130\u015flem maliyeti y\u00fcksek fonksiyonlar i\u00e7in ayr\u0131 i\u015f par\u00e7ac\u0131klar\u0131 ( QThread ) ve sinyaller ( PyQt Signal/Slot ) kullanarak arka planda i\u015flem y\u00fcr\u00fctme. A\u015f\u0131r\u0131 Render \u00c7a\u011fr\u0131lar\u0131 H\u0131zl\u0131 ard\u0131\u015f\u0131k g\u00fcncelIemeleri ( mouseMoveEvent gibi) tek bir render \u00e7a\u011fr\u0131s\u0131nda birle\u015ftiren gruplama ( BatchRenderer ) ve k\u0131s\u0131tlama (throttling) mekanizmalar\u0131. Uzamsal Sorgular vtkStaticPointLocator gibi VTK 'n\u0131n optimize edilmi\u015f uzamsal indeksleme yap\u0131lar\u0131n\u0131n yeniden kullan\u0131m\u0131. Bu, b\u00fcy\u00fck meshlerdeki noktalara h\u0131zl\u0131 eri\u015fim sa\u011flar (\u00f6rn: f\u0131r\u00e7a etki alan\u0131 sorgular\u0131). Skaler Dizi G\u00fcncellemeleri Skaler dizilerin ( vtkFloatArray ) her de\u011fi\u015fiklikte yeniden olu\u015fturulmas\u0131 yerine, mevcut dizi verilerinin do\u011frudan bellekte g\u00fcncellenmesi (in-place modification). Geri Alma Y\u0131\u011f\u0131n\u0131 Boyutu Tam PolyData kopyalar\u0131 yerine, yaln\u0131zca de\u011fi\u015ftirilen nokta ID'leri ve eski/yeni de\u011ferler gibi delta de\u011fi\u015fikliklerini depolayarak y\u0131\u011f\u0131n boyutunu optimize etme. B\u00fcy\u00fck Mesh Yumu\u015fatma Yumu\u015fatma iterasyonlar\u0131n\u0131n s\u0131n\u0131rlanmas\u0131, yo\u011fun mesh'ler i\u00e7in i\u015flem \u00f6ncesi basitle\u015ftirme (decimation) uygulama. GPU Kullan\u0131m\u0131 (iste\u011fe ba\u011fl\u0131) M\u00fcmk\u00fcn oldu\u011funda VTK 'n\u0131n GPU destekli mapper'lar\u0131n\u0131 veya filtrelerini kullanma. GPU mevcut de\u011filse sorunsuz bir \u015fekilde CPU tabanl\u0131 y\u00f6ntemlere geri d\u00fc\u015fme. \u0130zleme: - Maliyetli operasyonlar\u0131n (\u00f6rn: mesh i\u015fleme) s\u00fcrelerini kaydetmek i\u00e7in loglama kullan\u0131l\u0131r. - \u00d6nemli performans noktalar\u0131 i\u00e7in basit zamanlama dekorat\u00f6rlerinin entegrasyonu potansiyel bir iyile\u015ftirmedir. 17. Loglama ve Hata Y\u00f6netimi Uygulaman\u0131n \u00e7al\u0131\u015fma zaman\u0131 davran\u0131\u015f\u0131n\u0131 izlemek, sorunlar\u0131 te\u015fhis etmek ve kullan\u0131c\u0131ya geri bildirim sa\u011flamak i\u00e7in kapsaml\u0131 bir loglama ve hata y\u00f6netimi stratejisi benimsenmi\u015ftir. Mod\u00fcl Ba\u015f\u0131na Logger: print ifadeleri yerine, her Python mod\u00fcl\u00fc i\u00e7in ayr\u0131 bir logging nesnesi kullan\u0131l\u0131r. Bu, g\u00fcnl\u00fcklerin d\u00fczenli olmas\u0131n\u0131 ve filtrelenmesini kolayla\u015ft\u0131r\u0131r. Kullan\u0131c\u0131ya Y\u00f6nelik Durum Sinyalleri: Kullan\u0131c\u0131 aray\u00fcz\u00fcnde g\u00f6r\u00fcnen durum mesajlar\u0131 i\u00e7in \u00f6zel sinyaller ( logMessage ) kullan\u0131l\u0131r. Bu sinyaller, i\u015flemin ba\u015flad\u0131\u011f\u0131n\u0131, ilerlemesini, tamamland\u0131\u011f\u0131n\u0131 veya bir hata olu\u015ftu\u011funu kullan\u0131c\u0131ya bildirir. Desteklenmeyen Dosya Tipleri: Desteklenmeyen dosya uzant\u0131lar\u0131 veya bozuk mesh dosyalar\u0131 i\u00e7in y\u00fckleme a\u015famas\u0131nda erken ret mekanizmalar\u0131 bulunur. Bu durumlar g\u00fcnl\u00fc\u011fe kaydedilir ve kullan\u0131c\u0131ya a\u00e7\u0131k bir hata mesaj\u0131 sunulur. Asenkron Hata Yakalama: Asenkron i\u015f par\u00e7ac\u0131klar\u0131nda (\u00f6rn: AsyncMeshProcessor ) meydana gelen istisnalar try / catch bloklar\u0131 i\u00e7inde yakalan\u0131r. Hata detaylar\u0131 g\u00fcnl\u00fc\u011fe kaydedilir ve ana thread'e bir hata sinyali g\u00f6nderilerek UI'\u0131n duyarl\u0131 kalmas\u0131 sa\u011flan\u0131r. G\u00fcnl\u00fck Dosyalar\u0131: \u00c7al\u0131\u015fma zaman\u0131 g\u00fcnl\u00fckleri, logs/ dizini alt\u0131nda zaman damgal\u0131 dosyalar halinde saklan\u0131r. Bu g\u00fcnl\u00fckler, sorun giderme ve uygulama denetimleri i\u00e7in kullan\u0131labilir. Ba\u011flam \u0130\u00e7eri\u011fi: Hata mesajlar\u0131na, ilgili mesh dosyas\u0131n\u0131n ad\u0131 gibi ba\u011flam bilgileri eklenerek sorunlar\u0131n tespiti kolayla\u015ft\u0131r\u0131l\u0131r. 18. Konfig\u00fcrasyon ve Ortam Yaz\u0131l\u0131m\u0131n kurulumu ve farkl\u0131 ortamlarda \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131 i\u00e7in konfig\u00fcrasyon ve ba\u011f\u0131ml\u0131l\u0131k y\u00f6netimi stratejileri belirlenmi\u015ftir. Python 3.11 Hedefi: Proje, Python 3.11 veya daha yeni versiyonlar\u0131n\u0131 hedef alarak en g\u00fcncel dil \u00f6zelliklerinden ve performans iyile\u015ftirmelerinden faydalan\u0131r. Ba\u011f\u0131ml\u0131l\u0131k Y\u00f6netimi: T\u00fcm Python ba\u011f\u0131ml\u0131l\u0131klar\u0131 ( PyQt5 , VTK , NumPy vb.) pyproject.toml veya requirements.txt dosyalar\u0131 arac\u0131l\u0131\u011f\u0131yla y\u00f6netilir. Bu, projenin farkl\u0131 geli\u015ftirme veya da\u011f\u0131t\u0131m ortamlar\u0131nda ba\u011f\u0131ml\u0131l\u0131klar\u0131n kolayca kurulmas\u0131n\u0131 sa\u011flar. \u00c7al\u0131\u015fma Zaman\u0131 Dizini Yap\u0131s\u0131: logs/ : \u00c7al\u0131\u015fma zaman\u0131 g\u00fcnl\u00fcklerinin depoland\u0131\u011f\u0131 yaz\u0131labilir bir dizindir. Uygulama ilk \u00e7al\u0131\u015ft\u0131\u011f\u0131nda otomatik olarak olu\u015fturulur. data/ : Test mesh'leri ve prosed\u00fcrel \u00f6rnek mesh'ler gibi statik verilerin sakland\u0131\u011f\u0131 dizindir. \u0130ste\u011fe Ba\u011fl\u0131 Ortam De\u011fi\u015fkenleri: Gelecekte, uygulaman\u0131n davran\u0131\u015f\u0131n\u0131 etkileyebilecek (\u00f6rn: debug modu, varsay\u0131lan dosya yollar\u0131) ortam de\u011fi\u015fkenleri i\u00e7in merkezi bir konfig\u00fcrasyon ( app/core/config.py ) veya d\u0131\u015far\u0131dan y\u00fcklenen bir .env dosyas\u0131 kullan\u0131labilir ve bu dok\u00fcmanda belgelenmelidir. 19. Derleme ve Ba\u011f\u0131ml\u0131l\u0131k Y\u00f6netimi Yaz\u0131l\u0131m\u0131n geli\u015ftirme ve da\u011f\u0131t\u0131m s\u00fcre\u00e7lerinde ba\u011f\u0131ml\u0131l\u0131klar\u0131n y\u00f6netimi ve derleme (build) ad\u0131mlar\u0131 belirlenmi\u015ftir. Kurulum Y\u00f6ntemi: Geli\u015ftirme ortam\u0131nda, proje pip install -e . komutuyla kurulabilir (e\u011fer pyproject.toml projenin tan\u0131m\u0131n\u0131 i\u00e7eriyorsa). Bu, projenin kaynak koduna do\u011frudan ba\u011fl\u0131 olarak d\u00fczenlenebilir bir kurulum sa\u011flar. S\u00fcr\u00fcm Sabitleme: \u00d6zellikle VTK gibi kritik k\u00fct\u00fcphanelerin belirli s\u00fcr\u00fcmleri sabitlenir ( requirements.txt dosyas\u0131nda vtk==X.Y.Z gibi). Bu, farkl\u0131 VTK versiyonlar\u0131n\u0131n yol a\u00e7abilece\u011fi uyumluluk sorunlar\u0131n\u0131 veya \u00e7al\u0131\u015fma zaman\u0131 davran\u0131\u015f farkl\u0131l\u0131klar\u0131n\u0131 \u00f6nler. S\u00fcrekli Entegrasyon (CI - Gelecek): Gelecekte bir CI/CD boru hatt\u0131 kurulmas\u0131 planlanmaktad\u0131r. Bu hat, kod kalitesini ve kararl\u0131l\u0131\u011f\u0131n\u0131 sa\u011flamak i\u00e7in \u015fu ad\u0131mlar\u0131 otomatik olarak \u00e7al\u0131\u015ft\u0131racakt\u0131r: Linting ve Stil Kontrolleri: Kodun PEP8 gibi stil rehberlerine uygunlu\u011funu kontrol eder. \u00c7ekirdek Testler: Temel i\u015flevselli\u011fin do\u011fru \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan emin olmak i\u00e7in birim ve entegrasyon testlerini \u00e7al\u0131\u015ft\u0131r\u0131r. Performans Smoke Testleri: Kritik operasyonlarda performans d\u00fc\u015f\u00fc\u015fleri olup olmad\u0131\u011f\u0131n\u0131 kontrol etmek i\u00e7in se\u00e7ilmi\u015f performans testlerini \u00e7al\u0131\u015ft\u0131r\u0131r. Paketleme (Da\u011f\u0131t\u0131m i\u00e7in): Son kullan\u0131c\u0131 da\u011f\u0131t\u0131mlar\u0131 i\u00e7in, PyInstaller gibi ara\u00e7lar kullan\u0131larak Python uygulamas\u0131 tek bir y\u00fcr\u00fct\u00fclebilir dosyaya (executable) paketlenebilir. Bu, ba\u011f\u0131ml\u0131l\u0131klar\u0131 y\u00f6netme y\u00fck\u00fcn\u00fc son kullan\u0131c\u0131dan al\u0131r. Ba\u015flatma Betikleri: Platformlar aras\u0131 uyumluluk sa\u011flamak i\u00e7in iste\u011fe ba\u011fl\u0131 ba\u015flatma betikleri (launcher scripts) sa\u011flanabilir. 20. Kodlama Standartlar\u0131 Kodun okunabilirli\u011fini, s\u00fcrd\u00fcr\u00fclebilirli\u011fini ve ekip i\u00e7inde tutarl\u0131l\u0131\u011f\u0131 sa\u011flamak i\u00e7in belirli kodlama standartlar\u0131 benimsenmi\u015ftir. PEP8 Uyumlulu\u011fu: Python kodunun b\u00fcy\u00fck \u00f6l\u00e7\u00fcde PEP8 stil rehberine uygun olmas\u0131 hedeflenir. Ancak, \u00f6zellikle VTK boru hatlar\u0131n\u0131n okunabilirli\u011fini art\u0131rmak amac\u0131yla, baz\u0131 durumlarda daha uzun ve birle\u015fik fonksiyonlara pratik tolerans g\u00f6sterilebilir. Tip \u0130pu\u00e7lar\u0131 (Type Hints): T\u00fcm genel (public) aray\u00fczlerde ve m\u00fcmk\u00fcn oldu\u011funca di\u011fer yerlerde tip ipu\u00e7lar\u0131 (type hints) kullan\u0131l\u0131r. Bu, kodun anla\u015f\u0131l\u0131rl\u0131\u011f\u0131n\u0131 art\u0131r\u0131r ve statik analiz ara\u00e7lar\u0131yla potansiyel hatalar\u0131n erken tespitine yard\u0131mc\u0131 olur. Dok\u00fcman Dizileri (Docstrings): Her fonksiyon, s\u0131n\u0131f ve \u00f6nemli metot i\u00e7in k\u0131sa bir \u00f6zet sat\u0131r\u0131 i\u00e7eren docstring'ler yaz\u0131l\u0131r. Parametreler ve d\u00f6n\u00fc\u015f de\u011ferleri hakk\u0131nda detayl\u0131 bilgi sa\u011flan\u0131r. Skaler Dizi Adland\u0131rmas\u0131: PressureValues , MoldDisplacement gibi skaler diziler i\u00e7in tutarl\u0131 ve a\u00e7\u0131klay\u0131c\u0131 adland\u0131rma standartlar\u0131 kullan\u0131l\u0131r. Harici K\u00fct\u00fcphanelerden Ka\u00e7\u0131nma: Zorunlu olmad\u0131k\u00e7a yeni harici Python k\u00fct\u00fcphaneleri eklemekten ka\u00e7\u0131n\u0131l\u0131r. Yeni bir ba\u011f\u0131ml\u0131l\u0131k eklenmeden \u00f6nce dikkatlice de\u011ferlendirilir. Loglama Kullan\u0131m\u0131: Kod i\u00e7inde print() ifadeleri yerine, hata ay\u0131klama ve izleme i\u00e7in merkezi loglama ( logging mod\u00fcl\u00fc) tercih edilir. \u0130stisnalar sessizce yutulmaz; uygun hata loglar\u0131 kaydedilir. 21. Test Stratejisi Yaz\u0131l\u0131m\u0131n do\u011frulu\u011funu, g\u00fcvenilirli\u011fini ve performans\u0131n\u0131 sa\u011flamak i\u00e7in kapsaml\u0131 bir test stratejisi uygulanmaktad\u0131r. Mevcut Test Betikleri: Projenin test klas\u00f6r\u00fcnde ( tests/ ) bulunan mevcut test betikleri, uygulaman\u0131n \u00e7e\u015fitli \u00f6zelliklerini do\u011frulamak i\u00e7in kullan\u0131l\u0131r: - test_pressure_mapping.py : Bas\u0131n\u00e7 boyama, \u0131s\u0131 haritas\u0131 olu\u015fturma ve UI entegrasyonunun temel i\u015flevselli\u011fini do\u011frular. - test_enhanced_pressure_mapping.py : Geli\u015fmi\u015f bas\u0131n\u00e7 boyama \u00f6zelliklerini test eder. - test_split_view_pressure_mapping.py : \u00c7oklu g\u00f6r\u00fcn\u00fcmdeki bas\u0131n\u00e7 boyama ve g\u00f6rselle\u015ftirme davran\u0131\u015f\u0131n\u0131 test eder. - test_mesh_subdivision.py : Mesh alt b\u00f6l\u00fcmlere ay\u0131rma (subdivision) do\u011frulu\u011funu test eder. - test_page3_performance.py : UI'\u0131n belirli sayfalardaki performans\u0131n\u0131 ve tepki s\u00fcresini test eder. - test_gpu_performance.py : GPU h\u0131zland\u0131rma yollar\u0131n\u0131n performans\u0131n\u0131 test eder. - test_landmarks.py : \u0130\u015faret noktas\u0131 yerle\u015ftirme mant\u0131\u011f\u0131n\u0131 do\u011frular. - test_orientation_definition.py : Anatomik y\u00f6nelim hesaplama boru hatt\u0131n\u0131 test eder. - test_page4_cutting_patterns.py : Kesme deseni olu\u015fturma davran\u0131\u015f\u0131n\u0131 test eder. - MOLD_GENERATION_SUCCESS.py gibi betikler, kal\u0131p olu\u015fturma i\u015f ak\u0131\u015flar\u0131n\u0131n ba\u015far\u0131yla tamamland\u0131\u011f\u0131n\u0131 g\u00f6sterir. Test Desenleri: - Prosed\u00fcrel Geometri: Testlerde, d\u0131\u015f dosyalar yerine genellikle k\u00fcp, k\u00fcre gibi basit prosed\u00fcrel geometriler veya programatik olarak olu\u015fturulmu\u015f mesh'ler kullan\u0131l\u0131r. Bu, testlerin ba\u011f\u0131ms\u0131zl\u0131\u011f\u0131n\u0131 ve tekrarlanabilirli\u011fini art\u0131r\u0131r. - Onaylamalar (Assertions): Nokta say\u0131lar\u0131, skaler de\u011fer aral\u0131klar\u0131, fonksiyonlar\u0131n \u00e7\u00f6kmeden \u00e7al\u0131\u015fmas\u0131 gibi konular \u00fczerinde net onaylamalar ( assert ) kullan\u0131l\u0131r. - Geri Al/\u0130leri Al Do\u011frulamas\u0131: Modifikasyonlar sonras\u0131 HistoryStack 'in do\u011fru \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan ve geri alma/ileri alma i\u015flemlerinin veriyi tutarl\u0131 bir \u015fekilde \u00f6nceki/sonraki durumlara d\u00f6nd\u00fcrd\u00fc\u011f\u00fcnden emin olmak i\u00e7in \u00f6zel testler bulunur. - Kal\u0131p Deplasman\u0131 Tutarl\u0131l\u0131\u011f\u0131: Kal\u0131p olu\u015fturma i\u015fleminde minimum/maksimum deplasman de\u011ferlerinin ve genel geometri tutarl\u0131l\u0131\u011f\u0131n\u0131n korunup korunmad\u0131\u011f\u0131 test edilir. - Performans E\u015fi\u011fi Kontrol\u00fc: Belirli operasyonlar\u0131n belirtilen performans e\u015fiklerini a\u015fmad\u0131\u011f\u0131n\u0131 do\u011frulamak i\u00e7in zamanlama testleri kullan\u0131l\u0131r. Test Kategorileri: - Birim Testleri: Her bir fonksiyon veya k\u00fc\u00e7\u00fck s\u0131n\u0131f\u0131n izole edilmi\u015f bir \u015fekilde do\u011fru \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 do\u011frular. - Entegrasyon Testleri: Farkl\u0131 mod\u00fcllerin veya katmanlar\u0131n birbiriyle do\u011fru etkile\u015fim kurdu\u011funu do\u011frular. - Sistem Testleri: T\u00fcm uygulaman\u0131n u\u00e7tan uca senaryolarda beklendi\u011fi gibi \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 do\u011frular. - Performans Testleri: Belirli operasyonlar\u0131n ve genel uygulaman\u0131n tepki s\u00fcresi ve kaynak kullan\u0131m\u0131 hedeflerini kar\u015f\u0131lad\u0131\u011f\u0131n\u0131 do\u011frular. - Regresyon Testleri: Yeni kod eklendikten veya mevcut kod de\u011fi\u015ftirildikten sonra, daha \u00f6nce \u00e7al\u0131\u015fan \u00f6zelliklerin hala do\u011fru \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 garanti eder. 22. Kalite Kontrolleri Yaz\u0131l\u0131m\u0131n y\u00fcksek kalitesini s\u00fcrekli olarak sa\u011flamak i\u00e7in \u00e7e\u015fitli kalite kontrol mekanizmalar\u0131 belirlenmi\u015ftir. Kontrol Noktas\u0131 Ama\u00e7 Linting/Stil Kontrol\u00fc Kodun okunabilirli\u011fini ve stil standartlar\u0131na (\u00f6rn. PEP8) uygunlu\u011funu s\u00fcrd\u00fcrmek. Tip Kontrol\u00fc (iste\u011fe ba\u011fl\u0131) Aray\u00fcz tutars\u0131zl\u0131klar\u0131n\u0131 ve tip hatalar\u0131n\u0131 tespit etmek i\u00e7in Python'\u0131n tip ipu\u00e7lar\u0131 ile statik analiz ara\u00e7lar\u0131 kullanmak. Birim Testleri Her bir k\u00fc\u00e7\u00fck kod biriminin (fonksiyon, metod) do\u011fru \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan emin olmak. Performans Smoke Testleri Boyama ve kal\u0131p olu\u015fturma boru hatlar\u0131 gibi kritik i\u015flevlerde performans gerilemelerinin olmad\u0131\u011f\u0131n\u0131 do\u011frulamak. Loglama Varl\u0131\u011f\u0131 Temel operasyonlar\u0131n izlenebilirlik i\u00e7in do\u011fru g\u00fcnl\u00fck mesajlar\u0131 \u00fcretti\u011fini ve bu g\u00fcnl\u00fcklerin yeterli izleme bilgisi i\u00e7erdi\u011fini do\u011frulamak. 23. G\u00fcvenlik ve Gizlilik Medikal bir yaz\u0131l\u0131m olarak, g\u00fcvenlik ve gizlilik Clonify Labs i\u00e7in kritik \u00f6neme sahiptir. Ki\u015fisel Sa\u011fl\u0131k Bilgilerinin ( PHI ) korunmas\u0131 en \u00fcst d\u00fczeyde \u00f6nceliklidir. PHI Saklama: Yaz\u0131l\u0131m, hasta tan\u0131mlay\u0131c\u0131 bilgilerini veya ki\u015fisel sa\u011fl\u0131k bilgilerini ( PHI ) do\u011frudan kal\u0131c\u0131 olarak saklamaz. Mesh dosya adlar\u0131 anonimle\u015ftirilir veya jenerik bir formatta tutulur. G\u00fcnl\u00fck Dosyalar\u0131: G\u00fcnl\u00fck dosyalar\u0131, hasta tan\u0131mlay\u0131c\u0131lar\u0131n\u0131 i\u00e7ermez. Yaln\u0131zca teknik sorun giderme i\u00e7in gerekli olan uygulama davran\u0131\u015flar\u0131 ve hata bilgileri kaydedilir. A\u011f \u0130leti\u015fimi: Mevcut durumda, yaz\u0131l\u0131m\u0131n herhangi bir a\u011f \u00fczerinden do\u011frudan geometri veya hasta verisi iletimi yapmad\u0131\u011f\u0131 varsay\u0131l\u0131r (\u00e7evrimd\u0131\u015f\u0131 masa\u00fcst\u00fc uygulamas\u0131 olarak \u00e7al\u0131\u015f\u0131r). Gelecek Geni\u015fletmeleri: E\u011fer gelecekte bulut senkronizasyonu veya \u00e7ok kullan\u0131c\u0131l\u0131 i\u015fbirli\u011fi gibi a\u011f ba\u011flant\u0131l\u0131 \u00f6zellikler eklenirse: Veri \u015eifreleme: Saklanan oturum durumlar\u0131 veya iletilen veriler i\u00e7in end\u00fcstri standard\u0131 \u015fifreleme y\u00f6ntemleri (\u00f6rn: AES-256) kullan\u0131lacakt\u0131r. Kimlik Do\u011frulama ve Yetkilendirme: Kullan\u0131c\u0131 kimlik do\u011frulamas\u0131 (\u00f6rne\u011fin, OAuth, API anahtarlar\u0131) ve yetkilendirme (rol tabanl\u0131 eri\u015fim kontrol\u00fc) mekanizmalar\u0131 uygulanacakt\u0131r. G\u00fcvenli Protokoller: HTTPS/TLS gibi g\u00fcvenli ileti\u015fim protokolleri zorunlu tutulacakt\u0131r. Gizlilik Politikalar\u0131: PHI 'nin nas\u0131l i\u015flendi\u011fini, sakland\u0131\u011f\u0131n\u0131 ve korundu\u011funu a\u00e7\u0131klayan net gizlilik politikalar\u0131 belirlenecek ve kullan\u0131c\u0131lara sunulacakt\u0131r. 24. Riskler ve Azaltma Y\u00f6ntemleri Proje boyunca kar\u015f\u0131la\u015f\u0131labilecek potansiyel riskler ve bunlar\u0131 azaltmaya y\u00f6nelik stratejiler belirlenmi\u015ftir. Risk Etki Azaltma Y\u00f6ntemi VTK S\u00fcr\u00fcm Uyumsuzlu\u011fu \u00c7al\u0131\u015fma zaman\u0131 hatalar\u0131, beklenmeyen davran\u0131\u015flar. Ba\u011f\u0131ml\u0131l\u0131klar\u0131 belirli s\u00fcr\u00fcmlere sabitlemek ( pip freeze veya requirements.txt ile) ve farkl\u0131 VTK versiyonlar\u0131yla d\u00fczenli test matrisi \u00e7al\u0131\u015ft\u0131rmak. B\u00fcy\u00fck Mesh Bellek Kullan\u0131m\u0131 Uygulama yava\u015flamas\u0131/donmas\u0131 veya \u00e7\u00f6kmesi. B\u00fcy\u00fck mesh'ler i\u00e7in \u00f6n i\u015flemde basitle\u015ftirme (decimation) uygulama, gelecekte veri ak\u0131\u015f\u0131n\u0131 optimize eden \"streaming\" teknikleri ara\u015ft\u0131rmak. UI Donmas\u0131 (Yan\u0131t Vermemesi) Kullan\u0131c\u0131 deneyiminin k\u00f6t\u00fcle\u015fmesi, \u00fcretkenlik kayb\u0131. T\u00fcm maliyetli operasyonlar\u0131 (dosya y\u00fckleme, karma\u015f\u0131k hesaplamalar) ayr\u0131 i\u015f par\u00e7ac\u0131klar\u0131nda ( QThread ) y\u00fcr\u00fctme ve sinyallerle ileti\u015fim kurma. Geri Alma Y\u0131\u011f\u0131n\u0131 B\u00fcy\u00fcmesi A\u015f\u0131r\u0131 bellek t\u00fcketimi, performans d\u00fc\u015f\u00fc\u015f\u00fc. Ge\u00e7mi\u015f y\u0131\u011f\u0131n\u0131n\u0131 belirli bir boyutta s\u0131n\u0131rlama veya tam mesh kopyalar\u0131 yerine sadece de\u011fi\u015fiklikleri (delta) s\u0131k\u0131\u015ft\u0131rarak depolama. Skaler Dizi Tutars\u0131zl\u0131\u011f\u0131 G\u00f6rsel hatalar, hatal\u0131 \u0131s\u0131 haritalar\u0131 veya kal\u0131p deformasyonlar\u0131. Skaler dizi g\u00fcncellemeleri i\u00e7in merkezi ve g\u00fcvenli bir i\u015flev kullanma, g\u00fcncellemeleri yaln\u0131zca ana i\u015f par\u00e7ac\u0131\u011f\u0131nda yapma. GPU Yolu Ayr\u0131\u015fmas\u0131 Farkl\u0131 donan\u0131mlarda tekrarlanamayan veya zor te\u015fhis edilen hatalar. GPU destekli \u00f6zellikler i\u00e7in iste\u011fe ba\u011fl\u0131 kod yollar\u0131 sa\u011flama ve GPU mevcut olmad\u0131\u011f\u0131nda sorunsuz bir \u015fekilde CPU tabanl\u0131 y\u00f6ntemlere geri d\u00f6nme. Hem GPU hem de CPU yollar\u0131n\u0131 test etme. Ki\u015fisel Sa\u011fl\u0131k Bilgileri (PHI) S\u0131z\u0131nt\u0131s\u0131 Yasal sorunlar, hasta g\u00fcveninin kayb\u0131. Hasta verilerini anonimle\u015ftirme, g\u00fcnl\u00fcklerde PHI bulundurmama, a\u011f iletimi i\u00e7in \u015fifreleme (gelecekte) ve eri\u015fim kontrolleri. A\u015f\u0131r\u0131 Kullan\u0131c\u0131 Geribildirimi/F\u0131r\u00e7a Darbeleri Performans d\u00fc\u015f\u00fc\u015f\u00fc, gereksiz i\u015flem y\u00fck\u00fc. F\u0131r\u00e7a darbelerini veya h\u0131zl\u0131 olaylar\u0131 grupland\u0131ran ve belirli bir oranda i\u015fleyen k\u0131s\u0131tlama (throttling) mekanizmalar\u0131 kullanma. Yeni Geli\u015ftirici Onboarding S\u00fcresi Ekip b\u00fcy\u00fcmesinde verimlilik kayb\u0131. Minimum geli\u015ftirici onboarding ad\u0131mlar\u0131 sa\u011flama, kapsaml\u0131 dok\u00fcmantasyon ve \u00f6rnekler sunma. 25. Gelecek Geli\u015ftirmeler ve Geni\u015fletme Noktalar\u0131 APPClonify '\u0131n mevcut mimarisi, gelecekteki fonksiyonel ve teknolojik geni\u015fletmeler i\u00e7in g\u00fc\u00e7l\u00fc bir temel sa\u011flamaktad\u0131r. A\u015fa\u011f\u0131daki alanlar, potansiyel gelecek geli\u015ftirmeler ve geni\u015fletme noktalar\u0131 olarak tan\u0131mlanm\u0131\u015ft\u0131r: Oturum Serile\u015ftirme: Strateji: Mevcut oturum durumunu (bas\u0131n\u00e7 verileri, i\u015faret noktalar\u0131, modifiye edilmi\u015f mesh ve t\u00fcm ge\u00e7mi\u015f y\u0131\u011f\u0131n\u0131) tek bir dosyada kaydetme ve y\u00fckleme yetene\u011fi ekleme. Bu, kullan\u0131c\u0131lar\u0131n projelerine daha sonra devam etmelerini sa\u011flar. Teknoloji: JSON veya XML tabanl\u0131 \u00f6zel bir dosya format\u0131 kullanarak t\u00fcm Python ve VTK nesnelerini serile\u015ftirme ( pickle veya \u00f6zel serile\u015ftirme mant\u0131\u011f\u0131 gerekebilir). Parametrik Kal\u0131p Tasar\u0131m\u0131: Strateji: Tek tip kal\u0131nl\u0131k uygulaman\u0131n \u00f6tesinde, kullan\u0131c\u0131n\u0131n farkl\u0131 anatomik b\u00f6lgeler i\u00e7in katmanl\u0131 veya de\u011fi\u015fken kal\u0131nl\u0131k profilleri tan\u0131mlamas\u0131na olanak tan\u0131yan parametrik bir sistem geli\u015ftirme. Teknoloji: \u00d6zel UI widget'lar\u0131 ve arka u\u00e7ta geometriyi katmanlara ay\u0131r\u0131p her katman\u0131 ayr\u0131 ayr\u0131 deforme eden VTK filtreleri. Kesme Desenleri \u0130\u00e7in Geli\u015fmi\u015f D\u00fczle\u015ftirme (Unwrapping): Strateji: Kesilmi\u015f 3D mesh y\u00fczeylerini, fiziksel \u015fablon \u00fcretimi veya kuma\u015f kesimi i\u00e7in 2D d\u00fczleme do\u011fru bir \u015fekilde a\u00e7ma (unwrapping) yetene\u011fi ekleme. Teknoloji: vtkUnwrapPolyData gibi VTK filtreleri veya \u00f6zel d\u00fczle\u015ftirme algoritmalar\u0131. Sonlu Elemanlar Analizi (FEM) Entegrasyonu: Strateji: Protez soketinin biyomekanik davran\u0131\u015f\u0131n\u0131 (\u00f6rn: bas\u0131n\u00e7 noktalar\u0131, gerilme) sim\u00fcle etmek i\u00e7in harici bir FEM \u00e7\u00f6z\u00fcc\u00fcs\u00fcn\u00fc entegre etme. Teknoloji: Harici bir FEM k\u00fct\u00fcphanesi (\u00f6rn: FEniCS, PyVista ile entegre), mesh'i FEM i\u00e7in uygun formata d\u00f6n\u00fc\u015ft\u00fcrme ve sonu\u00e7lar\u0131 geri PolyData 'ya map etme. \u00c7oklu F\u0131r\u00e7a Ayarlar\u0131 ve Bas\u0131n\u00e7 AI \u00d6nerileri: Strateji: Farkl\u0131 f\u0131r\u00e7a tipleri, boyutlar\u0131, sertlikleri i\u00e7in \u00f6nceden tan\u0131mlanm\u0131\u015f ayarlar sunma. Hasta verilerine (tarama, ya\u015f, cinsiyet) dayanarak belirli b\u00f6lgeler i\u00e7in yapay zeka tabanl\u0131 bas\u0131n\u00e7 ayarlama \u00f6nerileri sunma. Teknoloji: Makine \u00f6\u011frenimi modelleri (\u00f6rn: scikit-learn , TensorFlow / PyTorch ) \"Model Katman\u0131\"nda, UI'da \u00f6nerileri g\u00f6r\u00fcnt\u00fclemek i\u00e7in yeni aray\u00fcz elemanlar\u0131. \u00d6zel Filtreler \u0130\u00e7in Eklenti Mekanizmas\u0131: Strateji: Geli\u015ftiricilerin, yaz\u0131l\u0131ma kolayca yeni 3D i\u015fleme filtreleri eklemesine olanak tan\u0131yan bir eklenti (plugin) mimarisi olu\u015fturma. Teknoloji: Belirli bir aray\u00fcze (interface) uyan Python s\u0131n\u0131flar\u0131n\u0131 dinamik olarak y\u00fckleyebilen bir mod\u00fcl y\u00fckleyici. Web Assembly (Uzun Vadeli Ta\u015f\u0131nabilirlik): Strateji: Yaz\u0131l\u0131m\u0131n bir web taray\u0131c\u0131s\u0131 \u00fczerinden \u00e7al\u0131\u015fabilmesi i\u00e7in (uzun vadeli hedef) Web Assembly (Wasm) teknolojilerini ara\u015ft\u0131rma. Teknoloji: Pyodide, Emscripten gibi ara\u00e7lar ve VTK.js gibi web tabanl\u0131 VTK portlar\u0131. Ger\u00e7ek Zamanl\u0131 Biyomekanik Sezgisel Katmanlar: Strateji: Modelleme s\u0131ras\u0131nda, protezin potansiyel biyomekanik etkilerini (\u00f6rn: kal\u00e7a abduksiyon a\u00e7\u0131s\u0131, diz eklemi ekseni) ger\u00e7ek zamanl\u0131 olarak g\u00f6steren g\u00f6rsel katmanlar (overlays) sunma. Teknoloji: vtkActor , vtkLineSource , vtkTextActor gibi VTK elemanlar\u0131 ve dinamik hesaplamalar. 26. S\u00f6zl\u00fck Terim Tan\u0131m Skaler Dizi Renklendirme veya deplasman i\u00e7in kullan\u0131lan, nokta ba\u015f\u0131na veri dizisi. Is\u0131 Haritas\u0131 PressureValues '\u0131n renkli g\u00f6rselle\u015ftirmesi. \u00c7arp\u0131tma (Warp) Skaler deplasmana dayal\u0131 geometri d\u00f6n\u00fc\u015f\u00fcm\u00fc. Bulucu (Locator) En yak\u0131n/belirli yar\u0131\u00e7ap i\u00e7indeki sorgular i\u00e7in uzamsal indeks. Vuru\u015f (Stroke) Tek bir s\u00fcrekli boyama etkile\u015fimi. Kal\u0131p (Mold) Fiziksel bir negatif olu\u015fturmak i\u00e7in kullan\u0131lan ayarlanm\u0131\u015f geometri.","title":"Yaz\u0131l\u0131m Tasar\u0131m Dok\u00fcman\u0131"},{"location":"#yazlm-tasarm-dokuman-clonify-labs","text":"Proje Ad\u0131 : Medikal Sekt\u00f6rde 3 Boyutlu Tarama ile Ki\u015fiye \u00d6zel H\u0131zl\u0131 Kal\u0131p \u00dcretimi \u00dcr\u00fcn Ad\u0131 : Clonify Labs Modelleme Yaz\u0131l\u0131m\u0131 Versiyon : 0.2 Tarih : 15.08.2025","title":"Yaz\u0131l\u0131m Tasar\u0131m Dok\u00fcman\u0131: Clonify Labs"},{"location":"#icindekiler","text":"Y\u00f6netici \u00d6zeti Giri\u015f 2.1. Dok\u00fcman\u0131n Amac\u0131 2.2. Projenin Kapsam\u0131 2.3. Tan\u0131mlar ve K\u0131saltmalar Hedefler ve Ama\u00e7lar Payda\u015flar \u00dcst D\u00fczey Mimari 5.1. Katmanl\u0131 Mimari Yakla\u015f\u0131m\u0131 5.2. Katmanlar\u0131n Detayl\u0131 Analizi Mod\u00fcl Envanteri Kullan\u0131lan Teknolojiler ve K\u00fct\u00fcphaneler \u00c7ekirdek Fonksiyonlar\u0131n Mant\u0131ksal Ak\u0131\u015f\u0131 8.1. Fonksiyon: Mesh Y\u00fckleme 8.2. Fonksiyon: Bas\u0131n\u00e7 Boyama 8.3. Fonksiyon: Is\u0131 Haritas\u0131 Olu\u015fturma (Asenkron) 8.4. Fonksiyon: Kal\u0131p Olu\u015fturma 8.5. Fonksiyon: Tarama Temizleme 8.6. Fonksiyon: Anatomik Hizalama 8.7. Fonksiyon: Hacimsel Deformasyon Kullan\u0131c\u0131 Etkile\u015fim Tasar\u0131m\u0131 9.1. Mod\u00fcler Etkile\u015fim Stilleri 9.2. \u0130leti\u015fim Desenleri \u00c7ekirdek Alan Modelleri Hizmet Katman\u0131: VTKProcessor Arka U\u00e7 Ara\u00e7lar\u0131 (Backend Tooling) Asenkron \u0130\u015fleme Render (G\u00f6rselle\u015ftirme) Hatt\u0131 Mesh \u0130\u015flemleri (Temsili) Performans Stratejileri Loglama ve Hata Y\u00f6netimi Konfig\u00fcrasyon ve Ortam Derleme ve Ba\u011f\u0131ml\u0131l\u0131k Y\u00f6netimi Kodlama Standartlar\u0131 Test Stratejisi Kalite Kontrolleri G\u00fcvenlik ve Gizlilik Riskler ve Azaltma Y\u00f6ntemleri Gelecek Geli\u015ftirmeler ve Geni\u015fletme Noktalar\u0131 S\u00f6zl\u00fck","title":"\u0130\u00e7indekiler"},{"location":"#1-giris","text":"ClonifyCad , medikal sekt\u00f6rde, \u00f6zellikle ortopedi ve protez alan\u0131nda, 3 boyutlu tarama verileri kullanarak ki\u015fiye \u00f6zel protez ve uzuv kal\u0131plar\u0131 haz\u0131rlama, bas\u0131nca dayal\u0131 modifikasyonlar yapma ve kal\u0131p \u00fcretimi i\u00e7in tasarlanm\u0131\u015f bir masa\u00fcst\u00fc CAD (Bilgisayar Destekli Tasar\u0131m) yaz\u0131l\u0131m\u0131d\u0131r. Kullan\u0131c\u0131 aray\u00fcz\u00fc i\u00e7in PyQt5 ve 3D mesh i\u015flemleri i\u00e7in VTK'y\u0131 birle\u015ftirerek, etkile\u015fimli \u015fekillendirme, y\u00fcksek performans ve geni\u015fletilebilirlik \u00fczerine odaklanm\u0131\u015ft\u0131r. Yaz\u0131l\u0131m, 3D taray\u0131c\u0131dan gelen STL, OBJ, PLY gibi veri dosyalar\u0131n\u0131 manip\u00fcle edip ki\u015fiye \u00f6zel kal\u0131plar haz\u0131rlayarak bu kal\u0131plar\u0131n STL format\u0131nda 3B bask\u0131 al\u0131nmas\u0131n\u0131 sa\u011flar. Protez kal\u0131p rektifikasyonu (d\u00fczeltme/\u015fekillendirme) s\u00fcreci, ad\u0131m ad\u0131m ilerleyen rehberli bir i\u015f ak\u0131\u015f\u0131 (workflow) ile kullan\u0131c\u0131ya sunulur.","title":"1. Giri\u015f"},{"location":"#11-dokumann-amac","text":"Bu dok\u00fcman\u0131n temel amac\u0131, ClonifyCad yaz\u0131l\u0131m\u0131n\u0131n teknik mimarisini, tasar\u0131m kararlar\u0131n\u0131, temel bile\u015fenlerini ve bu bile\u015fenler aras\u0131ndaki etkile\u015fimi detayl\u0131 bir \u015fekilde a\u00e7\u0131klamakt\u0131r. Bu belge, projenin mevcut ve gelecekteki geli\u015ftiricileri i\u00e7in bir referans kayna\u011f\u0131 olarak hizmet edecek, kodun s\u00fcrd\u00fcr\u00fclebilirli\u011fini ve geni\u015fletilebilirli\u011fini sa\u011flamak i\u00e7in bir yol haritas\u0131 sunacakt\u0131r.","title":"1.1. Dok\u00fcman\u0131n Amac\u0131"},{"location":"#12-projenin-kapsam","text":"Bu dok\u00fcman, yaz\u0131l\u0131m\u0131n a\u015fa\u011f\u0131daki \u00e7ekirdek i\u015flevselliklerini ve planlanan mod\u00fcllerini kapsar: Planlanan \u00d6zellikler: - STL, PLY, OBJ formatlar\u0131nda 3D model y\u00fckleme ve g\u00f6rselle\u015ftirme. - 2D se\u00e7imle 3D g\u00fcr\u00fclt\u00fc temizleme. - Model y\u00fczeyindeki deliklerin otomatik doldurulmas\u0131. - Etkile\u015fimli kesit bantlar\u0131 ile radyal deformasyon. - \"Bulge/Smooth\" f\u0131r\u00e7alar\u0131 ile serbest form modelleme. - Geri Al/\u0130leri Al (Undo/Redo) yetene\u011fi. - \u00c7oklu pencerede (multi-view) anatomik hizalama. - Otomatik \u00f6l\u00e7\u00fcm ve analiz ara\u00e7lar\u0131. - Bask\u0131 i\u00e7in 3D \u00e7\u0131kt\u0131 alma se\u00e7enekleri. Yaz\u0131l\u0131m\u0131n temel hedefleri: - Hastan\u0131n taranm\u0131\u015f uzuv verilerini dijital ortamda hassas bir \u015fekilde modellemek. - Protez kal\u0131plar\u0131n\u0131 dijital ortamda hassas bir \u015fekilde modellemek. - Ortopedi uzmanlar\u0131n\u0131n klinik bilgi ve deneyimlerini dijital s\u00fcrece entegre etmelerini sa\u011flamak. - Ki\u015fiye \u00f6zel, konforlu ve performansl\u0131 protezlerin \u00fcretimini h\u0131zland\u0131rmak ve kolayla\u015ft\u0131rmak. - Geleneksel kal\u0131plama y\u00f6ntemlerinin zorluklar\u0131n\u0131 (y\u00fcksek kilolu hasta, \u00e7ift tarafl\u0131 amputasyon, tekrarlanan d\u00fczeltmeler vb.) dijital \u00e7\u00f6z\u00fcmlerle a\u015fmak.","title":"1.2. Projenin Kapsam\u0131"},{"location":"#13-tanmlar-ve-ksaltmalar","text":"GUI : Grafiksel Kullan\u0131c\u0131 Aray\u00fcz\u00fc (Graphical User Interface) VTK : The Visualization Toolkit STL : Stereolithography (3D dosya format\u0131) PolyData : VTK'da poligon a\u011f\u0131n\u0131 (noktalar, h\u00fccreler) temsil eden temel veri yap\u0131s\u0131. Pipeline : Veri ak\u0131\u015f hatt\u0131. VTK'da verinin bir dizi filtreden ge\u00e7erek i\u015flenmesi. Frustum : Kesik piramit. 3D'de bir kamera g\u00f6r\u00fc\u015f alan\u0131n\u0131 tan\u0131mlayan geometrik hacim. PHI : (Personal Health Information) Ki\u015fisel Sa\u011fl\u0131k Bilgileri CAD : Bilgisayar Destekli Tasar\u0131m (Computer-Aided Design) CAM : Bilgisayar Destekli \u00dcretim (Computer-Aided Manufacturing) 3D : \u00dc\u00e7 Boyutlu (Three-Dimensional) Dimension Sheet : Boyut Tablosu","title":"1.3. Tan\u0131mlar ve K\u0131saltmalar"},{"location":"#14-uygulama-is-aks-admlar-workflow-steps","text":"Clonify Labs Modelleme Yaz\u0131l\u0131m\u0131, planlanan \u00f6zellikler do\u011frultusunda, kullan\u0131c\u0131y\u0131 ad\u0131m ad\u0131m y\u00f6nlendiren mant\u0131ksal bir i\u015f ak\u0131\u015f\u0131 sunar. Bu ak\u0131\u015f, ham tarama verisinden bask\u0131ya haz\u0131r 3D modele kadar olan s\u00fcreci kapsar ve her ad\u0131mda Geri Al/\u0130leri Al (Undo/Redo) yetene\u011fi ile desteklenir.","title":"1.4. Uygulama \u0130\u015f Ak\u0131\u015f\u0131 Ad\u0131mlar\u0131 (Workflow Steps)"},{"location":"#adm-1-veri-yukleme-ve-gorsellestirme-data-loading-visualization","text":"Amac\u0131: Hastadan al\u0131nan ham 3D tarama verisinin sisteme aktar\u0131lmas\u0131 ve incelenmesi. \u0130\u015flevselli\u011fi: Model \u0130\u00e7e Aktarma: Kullan\u0131c\u0131, STL , PLY , veya OBJ formatlar\u0131ndaki 3D modelleri yaz\u0131l\u0131ma y\u00fckler. 3D G\u00f6r\u00fcnt\u00fcleme: Y\u00fcklenen model, 3D g\u00f6r\u00fcnt\u00fcleme penceresinde serbest\u00e7e d\u00f6nd\u00fcr\u00fclebilir, kayd\u0131r\u0131labilir ve yak\u0131nla\u015ft\u0131r\u0131labilir bir \u015fekilde sunulur. Bu, modelin ilk genel de\u011ferlendirmesi i\u00e7in temel olu\u015fturur.","title":"Ad\u0131m 1: Veri Y\u00fckleme ve G\u00f6rselle\u015ftirme (Data Loading &amp; Visualization)"},{"location":"#adm-2-coklu-tarama-birlestirme-multi-scan-registrationnot-priority","text":"Amac\u0131: Hastan\u0131n farkl\u0131 a\u00e7\u0131lardan veya zamanlarda yap\u0131lm\u0131\u015f birden fazla 3D taramas\u0131n\u0131 tek, b\u00fct\u00fcnsel bir modelde birle\u015ftirmek. Bu, eksik verileri tamamlamak ve daha eksiksiz bir anatomi olu\u015fturmak i\u00e7in gereklidir. \u0130\u015flevselli\u011fi: Otomatik Hizalama (Automated Registration): Yaz\u0131l\u0131m, ortak geometrik \u00f6zellikleri veya kullan\u0131c\u0131 taraf\u0131ndan belirlenen referans noktalar\u0131n\u0131 kullanarak birden fazla taramay\u0131 otomatik olarak hizalar. Manuel \u0130nce Ayar: Otomatik hizalaman\u0131n ard\u0131ndan, kullan\u0131c\u0131ya hizalamay\u0131 manuel olarak hassas bir \u015fekilde ayarlama imkan\u0131 sunulu, gerekirse. Model Birle\u015ftirme (Merging): Hizalanan taramalar, tek ve tutarl\u0131 bir 3D model olu\u015fturmak i\u00e7in birle\u015ftirilir. Bu birle\u015fik model, sonraki ad\u0131mlarda kullan\u0131lacak olan ana model haline gelir.","title":"Ad\u0131m 2: \u00c7oklu Tarama Birle\u015ftirme (Multi-Scan Registration)(Not Priority)"},{"location":"#adm-3-tarama-temizleme-ve-onarm-scan-cleaning-repair","text":"Amac\u0131: Tarama s\u00fcrecinden kaynaklanan g\u00fcr\u00fclt\u00fc, artefakt ve geometrik kusurlar\u0131n giderilmesi. \u0130\u015flevselli\u011fi: 2D Se\u00e7imle G\u00fcr\u00fclt\u00fc Temizleme: Kullan\u0131c\u0131, 2D g\u00f6r\u00fcnt\u00fcleme d\u00fczleminde istenmeyen alanlar\u0131 (\u00f6rne\u011fin, tarama masas\u0131, destek yap\u0131lar\u0131, ilgisiz uzuvlar) se\u00e7erek 3D modelden kolayca kald\u0131r\u0131r. Otomatik Delik Doldurma: Yaz\u0131l\u0131m, model y\u00fczeyindeki istenmeyen delikleri ve bo\u015fluklar\u0131 ak\u0131ll\u0131 algoritmalarla tespit eder ve otomatik olarak kapatarak su ge\u00e7irmez (manifold) bir model olu\u015fturur.","title":"Ad\u0131m 3: Tarama Temizleme ve Onar\u0131m (Scan Cleaning &amp; Repair)"},{"location":"#adm-4-anatomik-hizalama-anatomical-alignment","text":"Amac\u0131: Modelin, standart bir anatomik referans sistemine g\u00f6re do\u011fru bir \u015fekilde konumland\u0131r\u0131lmas\u0131 ve y\u00f6nlendirilmesi. \u0130\u015flevselli\u011fi: \u00c7oklu Pencerede Hizalama: Kullan\u0131c\u0131, farkl\u0131 a\u00e7\u0131lardan (\u00f6n, yan, \u00fcst) g\u00f6sterilen model \u00fczerinde anatomik referans noktalar\u0131 belirler. Otomatik Y\u00f6nlendirme: Belirlenen noktalara g\u00f6re yaz\u0131l\u0131m, modeli otomatik olarak standart anatomik d\u00fczleme (\u00f6rne\u011fin, uzun ekseni Z eksenine paralel olacak \u015fekilde) hizalar.","title":"Ad\u0131m 4: Anatomik Hizalama (Anatomical Alignment)"},{"location":"#adm-5-serbest-form-modelleme-ve-deformasyon-free-form-modeling-deformation","text":"Amac\u0131: Protez kal\u0131b\u0131n\u0131n hasta i\u00e7in en uygun ve konforlu hale getirilmesi amac\u0131yla model \u00fczerinde hassas geometrik de\u011fi\u015fiklikler yap\u0131lmas\u0131. \u0130\u015flevselli\u011fi: \"Bulge/Smooth\" F\u0131r\u00e7alar\u0131: Kullan\u0131c\u0131, f\u0131r\u00e7a benzeri ara\u00e7larla model y\u00fczeyinde sezgisel olarak hacim ekleme (\u015fi\u015firme), \u00e7\u0131karma (a\u015f\u0131nd\u0131rma) ve p\u00fcr\u00fczs\u00fczle\u015ftirme i\u015flemleri yapar. Bu, \u00f6zellikle bas\u0131n\u00e7 noktalar\u0131n\u0131 rahatlatmak veya destek alanlar\u0131 olu\u015fturmak i\u00e7in kullan\u0131l\u0131r. Etkile\u015fimli Kesit Bantlar\u0131 ile Radyal Deformasyon: Model \u00fczerine yerle\u015ftirilen kesit bantlar\u0131 arac\u0131l\u0131\u011f\u0131yla, belirli b\u00f6lgelerde dairesel (radyal) olarak hassas boyutland\u0131rma (geni\u015fletme/daraltma) yap\u0131l\u0131r. Bu, uzvun \u00e7evresel \u00f6l\u00e7\u00fclerine tam uyum sa\u011flamak i\u00e7in kritiktir.","title":"Ad\u0131m 5: Serbest Form Modelleme ve Deformasyon (Free-form Modeling &amp; Deformation)"},{"location":"#adm-6-olcum-ve-analiz-measurement-analysis","text":"Amac\u0131: Yap\u0131lan modifikasyonlar\u0131n do\u011frulu\u011funu teyit etmek ve klinik gereksinimlere uygunlu\u011funu kontrol etmek. \u0130\u015flevselli\u011fi: Otomatik \u00d6l\u00e7\u00fcm Ara\u00e7lar\u0131: Yaz\u0131l\u0131m, model \u00fczerinde uzunluk, \u00e7evre, a\u00e7\u0131 ve hacim gibi kritik \u00f6l\u00e7\u00fcmleri otomatik olarak yapabilir. Bu, tasar\u0131m\u0131n say\u0131sal verilerle do\u011frulanmas\u0131n\u0131 sa\u011flar. Analiz: \u0130ki model aras\u0131ndaki farklar\u0131 veya belirli b\u00f6lgelerdeki de\u011fi\u015fiklikleri g\u00f6rsel ve say\u0131sal olarak analiz etme imkan\u0131 sunar.","title":"Ad\u0131m 6: \u00d6l\u00e7\u00fcm ve Analiz (Measurement &amp; Analysis)"},{"location":"#adm-7-baskya-hazrlk-ve-ckt-print-preparation-export","text":"Amac\u0131: Tamamlanan modelin 3D yaz\u0131c\u0131da bas\u0131lmak \u00fczere haz\u0131rlanmas\u0131. \u0130\u015flevselli\u011fi: Model Sonland\u0131rma: Modelin bask\u0131ya uygunlu\u011fu (\u00f6rne\u011fin, duvar kal\u0131nl\u0131\u011f\u0131 kontrol\u00fc) son kez denetlenir. 3D \u00c7\u0131kt\u0131 Alma: Nihai model, 3D bask\u0131 i\u00e7in yayg\u0131n olarak kullan\u0131lan STL veya di\u011fer formatlarda d\u0131\u015fa aktar\u0131l\u0131r.","title":"Ad\u0131m 7: Bask\u0131ya Haz\u0131rl\u0131k ve \u00c7\u0131kt\u0131 (Print Preparation &amp; Export)"},{"location":"#3-hedefler-ve-amaclar","text":"Klinisyenlere/teknisyenlere anatomik mesh'leri hassas bir \u015fekilde d\u00fczeltmek i\u00e7in ara\u00e7lar sa\u011flamak. G\u00f6rsel geri bildirim (\u0131s\u0131 haritas\u0131) ile bas\u0131nca dayal\u0131 ayarlamalar\u0131 desteklemek. Tekrarlanabilir bir \u015fekilde deplasman tabanl\u0131 kal\u0131plar \u00fcretmek (\u00f6rn. ayn\u0131 bas\u0131n\u00e7 haritas\u0131 ve parametrelerle, deterministik test mesh'leri ve prosed\u00fcrel kaynaklar kullan\u0131larak her seferinde ayn\u0131 sonu\u00e7lar\u0131n elde edilmesi; \u00f6rnek i\u00e7in bkz. \"Test Stratejisi\" ve \"\u00c7ekirdek Alan Modelleri\" b\u00f6l\u00fcmleri). Yo\u011fun geometri operasyonlar\u0131 s\u0131ras\u0131nda duyarl\u0131 bir kullan\u0131c\u0131 aray\u00fcz\u00fc s\u00fcrd\u00fcrmek. Gelecekteki ara\u00e7lar (kesme desenleri, \u015fekillendirme, i\u015faretleme, GPU h\u0131zland\u0131rma) i\u00e7in mod\u00fcler bir arka u\u00e7 sunmak. Tekrarlanabilirli\u011fi sa\u011flamak (deterministik test mesh'leri, prosed\u00fcrel kaynaklar).","title":"3. Hedefler ve Ama\u00e7lar"},{"location":"#4-paydaslar","text":"Klinik protez teknisyenleri (birincil kullan\u0131c\u0131lar). Hastane merkezleri. Dahili geli\u015ftiriciler (ara\u00e7 zinciri geni\u015fletme). QA/test personeli (do\u011frulama senaryolar\u0131).","title":"4. Payda\u015flar"},{"location":"#5-ust-duzey-mimari","text":"Yaz\u0131l\u0131m, katmanl\u0131 mimari yakla\u015f\u0131m\u0131n\u0131 benimseyerek mod\u00fcler, s\u00fcrd\u00fcr\u00fclebilir ve geni\u015fletilebilir bir yap\u0131 sunmaktad\u0131r. Bu mimari, g\u00f6revleri net bir \u015fekilde ay\u0131rarak kodun karma\u015f\u0131kl\u0131\u011f\u0131n\u0131 azalt\u0131r.","title":"5. \u00dcst D\u00fczey Mimari"},{"location":"#51-katmanl-mimari-yaklasm","text":"Yaz\u0131l\u0131m, kodun y\u00f6netilebilirli\u011fini ve mod\u00fclerli\u011fini sa\u011flamak amac\u0131yla, g\u00f6revleri net bir \u015fekilde ayr\u0131\u015ft\u0131ran \u00fc\u00e7 katmanl\u0131 bir mimari \u00fczerine in\u015fa edilmi\u015ftir. Bu yap\u0131, Model-View-Controller (MVC) tasar\u0131m deseninden g\u00fc\u00e7l\u00fc bir \u015fekilde ilham alm\u0131\u015ft\u0131r.","title":"5.1. Katmanl\u0131 Mimari Yakla\u015f\u0131m\u0131"},{"location":"#52-katmanlarn-detayl-analizi","text":"Katman Sorumluluk Teknolojiler / Bile\u015fenler Sunum (Presentation) Kullan\u0131c\u0131 etkile\u015fimini y\u00f6netir, g\u00f6rsel bile\u015fenleri sunar ve kullan\u0131c\u0131 girdilerini al\u0131r. PyQt (Widget'lar, Sinyaller/Slotlar), VTK (3D Render Penceresi) Uygulama (Application) Aray\u00fczden gelen istekleri i\u015fler, i\u015f mant\u0131\u011f\u0131n\u0131 koordine eder ve servisleri \u00e7a\u011f\u0131r\u0131r. Ana uygulama s\u0131n\u0131f\u0131, olay y\u00f6neticileri, UI ve servisler aras\u0131 k\u00f6pr\u00fc. Servisler (Services) Belirli i\u015flevleri (\u00f6rn: dosya I/O, mesh i\u015fleme) kaps\u00fclleyen senkron veya asenkron operasyonlar\u0131 y\u00fcr\u00fct\u00fcr. VTKProcessor , AsyncMeshProcessor , API istemcileri. Arka U\u00e7 (Backend) Yo\u011fun hesaplama gerektiren \u00f6zel alan operasyonlar\u0131n\u0131 ve algoritmalar\u0131 i\u00e7erir. Bas\u0131n\u00e7 haritalama, kal\u0131p olu\u015fturma, hizalama algoritmalar\u0131. Alan Modelleri (Domain) Uygulaman\u0131n durumunu ve temel veri yap\u0131lar\u0131n\u0131 (\u00f6rn: mesh, oturum bilgileri, geri alma y\u0131\u011f\u0131n\u0131) temsil eder. AnatomySession , vtkPolyData , PressureDict . Altyap\u0131 (Infrastructure) Veri depolama, loglama, konfig\u00fcrasyon ve harici sistemlerle ileti\u015fimi y\u00f6netir. Dosya sistemi, veritaban\u0131 ba\u011flant\u0131lar\u0131, loglama k\u00fct\u00fcphanesi.","title":"5.2. Katmanlar\u0131n Detayl\u0131 Analizi"},{"location":"#7-kullanlan-teknolojiler-ve-kutuphaneler","text":"Projenin geli\u015ftirilmesinde, a\u00e7\u0131k kaynak kodlu, end\u00fcstri standard\u0131, y\u00fcksek performansl\u0131 ve geni\u015f topluluk deste\u011fine sahip teknolojiler tercih edilecektir.","title":"7. Kullan\u0131lan Teknolojiler ve K\u00fct\u00fcphaneler"},{"location":"#71-ana-programlama-dili-python-310","text":"Python , h\u0131zl\u0131 prototipleme, temiz s\u00f6zdizimi ve zengin k\u00fct\u00fcphane deste\u011fi sayesinde projenin ana dili olarak se\u00e7ilmi\u015ftir. \u00d6zellikle bilimsel hesaplama ve veri analizi alanlar\u0131ndaki g\u00fcc\u00fc, medikal veri i\u015fleme do\u011fas\u0131yla \u00f6rt\u00fc\u015fmektedir. Python'un \"yap\u0131\u015ft\u0131r\u0131c\u0131 dil\" \u00f6zelli\u011fi, VTK gibi C++ k\u00fct\u00fcphanelerinin kolayca entegre edilmesini sa\u011flam\u0131\u015ft\u0131r.","title":"7.1. Ana Programlama Dili: Python 3.10"},{"location":"#72-grafiksel-kullanc-arayuzu-gui-pyqt5","text":"PyQt5 , platformdan ba\u011f\u0131ms\u0131z masa\u00fcst\u00fc uygulamalar\u0131 geli\u015ftirmek i\u00e7in kullan\u0131lan, Qt C++ k\u00fct\u00fcphanesinin Python versiyonudur. - Olgunluk ve Kararl\u0131l\u0131k: Kararl\u0131 ve g\u00fcvenilir bir aray\u00fcz \u00e7at\u0131s\u0131d\u0131r. - Sinyal ve Slot Mekanizmas\u0131: Aray\u00fcz elemanlar\u0131 ile program mant\u0131\u011f\u0131 aras\u0131nda esnek ve ayr\u0131\u015ft\u0131r\u0131lm\u0131\u015f ileti\u015fim sa\u011flar. - Geni\u015f Widget Seti: Karma\u015f\u0131k ve profesyonel bir kullan\u0131c\u0131 aray\u00fcz\u00fcn\u00fcn h\u0131zl\u0131ca olu\u015fturulmas\u0131na olanak tan\u0131r. - VTK Entegrasyonu: QVTKRenderWindowInteractor widget'\u0131 sayesinde, VTK 'n\u0131n 3D render pencerelerinin bir Qt uygulamas\u0131 i\u00e7ine sorunsuz entegrasyonu sa\u011flar.","title":"7.2. Grafiksel Kullan\u0131c\u0131 Aray\u00fcz\u00fc (GUI): PyQt5"},{"location":"#73-3d-gorsellestirme-ve-isleme-motoru-vtk-the-visualization-toolkit","text":"VTK , bilimsel ve medikal verilerin 3 boyutlu olarak i\u015flenmesi, g\u00f6rselle\u015ftirilmesi ve analizi i\u00e7in tasarlanm\u0131\u015f, C++ tabanl\u0131, y\u00fcksek performansl\u0131 bir k\u00fct\u00fcphanedir. Projenin 3D ile ilgili t\u00fcm a\u011f\u0131r i\u015flerini VTK \u00fcstlenir. - Veri Ak\u0131\u015f Hatt\u0131 Mimarisi (Pipeline Architecture): Source -> Filter -> Mapper -> Actor \u015feklindeki veri ak\u0131\u015f modeli, karma\u015f\u0131k 3D veri i\u015fleme zincirlerinin mod\u00fcler ve verimli bir \u015fekilde olu\u015fturulmas\u0131n\u0131 sa\u011flar. - Zengin Filtre K\u00fct\u00fcphanesi: vtkClipPolyData , vtkTransformPolyDataFilter ve vtkSTLReader gibi y\u00fczlerce haz\u0131r algoritma i\u00e7erir. Gelecekte vtkFillHolesFilter , vtkSmoothPolyDataFilter gibi filtreler de kullan\u0131lacakt\u0131r. - Geli\u015fmi\u015f Etkile\u015fim Mekanizmalar\u0131: vtkRenderWindowInteractor ve vtkInteractorStyle alt s\u0131n\u0131flar\u0131, fare ve klavye ile karma\u015f\u0131k 3D sahne etkile\u015fimleri olu\u015fturmak i\u00e7in g\u00fc\u00e7l\u00fc bir altyap\u0131 sunar.","title":"7.3. 3D G\u00f6rselle\u015ftirme ve \u0130\u015fleme Motoru: VTK (The Visualization Toolkit)"},{"location":"#74-matematiksel-ve-bilimsel-hesaplama-numpy","text":"NumPy , Python'da bilimsel hesaplamalar i\u00e7in temel pakettir. \u00c7ok boyutlu diziler \u00fczerinde y\u00fcksek performansl\u0131 matematiksel i\u015flemler i\u00e7in kullan\u0131l\u0131r. - Performans: B\u00fcy\u00fck veri k\u00fcmeleri \u00fczerinde h\u0131zl\u0131 hesaplamalar sa\u011flar. - Vekt\u00f6r Matemati\u011fi: Anatomik hizalama ve deformasyon algoritmalar\u0131nda vekt\u00f6r ve matris i\u015flemleri i\u00e7in kullan\u0131l\u0131r. - VTK Uyumlulu\u011fu: vtk.util.numpy_support mod\u00fcl\u00fc, NumPy dizileri ile VTK veri dizileri aras\u0131nda verimli veri al\u0131\u015fveri\u015fi sa\u011flar.","title":"7.4. Matematiksel ve Bilimsel Hesaplama: NumPy"},{"location":"#8-cekirdek-fonksiyonlarn-mantksal-aks","text":"","title":"8. \u00c7ekirdek Fonksiyonlar\u0131n Mant\u0131ksal Ak\u0131\u015f\u0131"},{"location":"#81-fonksiyon-mesh-yukleme","text":"Ama\u00e7: Harici bir dosyadan (\u00f6rn: .stl, .ply) 3D mesh verilerini uygulamaya y\u00fcklemek ve g\u00f6rselle\u015ftirmek. Mant\u0131ksal Ak\u0131\u015f: 1. UI Talebi: Kullan\u0131c\u0131, UI sayfas\u0131ndan bir mesh y\u00fckleme iste\u011fi ba\u015flat\u0131r (dosya yolu ile). 2. \u0130\u015flem Ba\u015flang\u0131c\u0131 Sinyali: Kontrol Katman\u0131, UI'a bir \"processingStarted\" sinyali g\u00f6nderir. 3. Dosya Okuma: VTKProcessor (Hizmet Katman\u0131), dosya uzant\u0131s\u0131na g\u00f6re uygun VTK okuyucusunu ( vtkSTLReader , vtkPLYReader ) se\u00e7er. 4. Mesh Y\u00fckleme: Okuyucu, 3D mesh verilerini ( vtkPolyData ) belle\u011fe y\u00fckler. 5. Orijinal Veri Kopyas\u0131: Y\u00fcklenen mesh'in derin bir kopyas\u0131 original_poly_data olarak saklan\u0131r. 6. Aktif Veri Ayar\u0131: Y\u00fcklenen mesh, active_poly_data olarak ayarlan\u0131r. 7. Ge\u00e7mi\u015f Y\u0131\u011f\u0131n\u0131na Ekleme: Uygulaman\u0131n ba\u015flang\u0131\u00e7 durumu, HistoryStack 'e ilk \"i\u015flem\" olarak eklenir. 8. Mesh Y\u00fcklendi Sinyali: VTKProcessor , y\u00fcklendi\u011fini ve active_poly_data 'y\u0131 referans alarak \"meshLoaded\" sinyali g\u00f6nderir. 9. \u0130\u015flem Tamamland\u0131 Sinyali: Son olarak, \"processingFinished\" sinyali g\u00f6nderilir. 10. UI G\u00fcncelleme: UI, update_renderer metoduyla yeni active_poly_data 'y\u0131 g\u00f6rselle\u015ftirmek \u00fczere g\u00fcncellenir. 11. MESH kalitesi artt\u0131rma : Y\u00fcklenen mesh verileri, VTKProcessor taraf\u0131ndan \u00e7e\u015fitli iyile\u015ftirme teknikleri (\u00f6rn: y\u00fczey p\u00fcr\u00fczs\u00fczle\u015ftirme, kenar keskinle\u015ftirme) ile i\u015flenir.","title":"8.1. Fonksiyon: Mesh Y\u00fckleme"},{"location":"#82-fonksiyon-basnc-boyama","text":"Ama\u00e7: Kullan\u0131c\u0131n\u0131n 3D mesh \u00fczerinde fare ile \u00e7izim yaparak her bir noktaya (vertex) bir bas\u0131n\u00e7 de\u011feri atamas\u0131n\u0131 sa\u011flamak ve bunu g\u00f6rselle\u015ftirmek (\u0131s\u0131 haritas\u0131). Mant\u0131ksal Ak\u0131\u015f: 1. F\u0131r\u00e7a Se\u00e7imi: Kullan\u0131c\u0131 UI'dan bir f\u0131r\u00e7a (boyut, sertlik, g\u00fc\u00e7) se\u00e7er. 2. Uzamsal Sorgu Ba\u015flatma: vtkStaticPointLocator nesnesi (h\u0131zl\u0131 uzamsal sorgular i\u00e7in \u00f6nceden olu\u015fturulmu\u015f/\u00f6nbelle\u011fe al\u0131nm\u0131\u015f) ba\u015flat\u0131l\u0131r. 3. \u00c7izim Ba\u015flang\u0131c\u0131: Kullan\u0131c\u0131 fareyi mesh \u00fczerinde s\u00fcr\u00fcklemeye ba\u015flad\u0131\u011f\u0131nda, ge\u00e7erli f\u0131r\u00e7a vuru\u015fu i\u00e7in bir tampon (buffer) temizlenir. 4. F\u0131r\u00e7a Hareketi: Kullan\u0131c\u0131 farenin bas\u0131l\u0131 tutarak mesh \u00fczerinde hareket etmesiyle ( mouse_moved olay\u0131), PressureTool \u015fu ad\u0131mlar\u0131 izler: - F\u0131r\u00e7a merkezi \u00e7evresindeki noktalar (radius) bir uzamsal sorgu ile bulunur. - Her etkilenen nokta i\u00e7in, f\u0131r\u00e7a merkezine olan uzakl\u0131\u011fa g\u00f6re bir \"a\u011f\u0131rl\u0131k\" (weight) veya etki d\u00fc\u015f\u00fc\u015f\u00fc (falloff) hesaplan\u0131r. - Yeni bas\u0131n\u00e7 de\u011feri (\u00f6rn: yeni_basinc = mevcut_basinc + guc * agirlik ) hesaplan\u0131r ve -100 ile 100 aras\u0131nda bir de\u011fere clamped edilir. - Noktan\u0131n ID'si, eski de\u011feri ve yeni de\u011feri bir vuru\u015f tamponuna ( stroke buffer ) kaydedilir (bu nokta ilk kez de\u011fi\u015ftiriliyorsa). - Bas\u0131n\u00e7 de\u011ferleri, haf\u0131zadaki pressure_dict 'te g\u00fcncellenir. - Bu de\u011fi\u015fiklikler, vtkFloatArray olan PressureValues skaler dizisine yans\u0131t\u0131l\u0131r ve render iste\u011fi, UI'da ger\u00e7ek zamanl\u0131 g\u00f6rsel geri bildirim sa\u011flamak i\u00e7in gruplan\u0131r (throttled). 5. \u00c7izim Sonu: Kullan\u0131c\u0131 fareyi b\u0131rakt\u0131\u011f\u0131nda ( mouse_released olay\u0131), t\u00fcm vuru\u015f tamponu, geri alma/ileri alma y\u0131\u011f\u0131n\u0131na ( HistoryStack ) bir \"i\u015flem\" olarak eklenir.","title":"8.2. Fonksiyon: Bas\u0131n\u00e7 Boyama"},{"location":"#83-fonksiyon-is-haritas-olusturma-asenkron","text":"Ama\u00e7: pressure_dict 'teki bas\u0131n\u00e7 de\u011ferlerini mesh \u00fczerinde g\u00f6rsel olarak bir \u0131s\u0131 haritas\u0131 olarak g\u00f6stermek. Performans i\u00e7in asenkron (arka planda) olarak \u00e7al\u0131\u015f\u0131r. Mant\u0131ksal Ak\u0131\u015f: 1. UI \u0130ste\u011fi: Kullan\u0131c\u0131, UI'dan \u0131s\u0131 haritas\u0131 olu\u015fturma talebini tetikler. 2. Asenkron Kuyruk: Kontrol Katman\u0131, bu operasyonu AsyncMeshProcessor 'a (ayr\u0131 bir thread) s\u0131raya al\u0131r. 3. Thread Ba\u015flatma: Ayr\u0131 bir thread'de (i\u015flemciyi dondurmamak i\u00e7in) AsyncMeshProcessor \u00e7al\u0131\u015fmaya ba\u015flar. 4. Skaler Dizi Olu\u015fturma/G\u00fcncelleme: Thread, pressure_dict 'teki de\u011ferleri kullanarak veya g\u00fcncelleyerek vtkFloatArray tipinde bir PressureValues skaler dizisi olu\u015fturur/g\u00fcnceller. 5. Tamamlanma Sinyali: \u0130\u015flem tamamland\u0131\u011f\u0131nda, thread, sonu\u00e7 meta verileriyle (\u00f6rn: de\u011fer aral\u0131\u011f\u0131) bir processing_complete sinyali g\u00f6nderir. 6. UI G\u00fcncelleme: Kontrol Katman\u0131, bu sinyali ana thread'de yakalar. Is\u0131 haritas\u0131n\u0131n renk d\u00f6n\u00fc\u015f\u00fcm\u00fc i\u00e7in vtkLookupTable (LUT) yap\u0131land\u0131r\u0131l\u0131r ve bu LUT'ye g\u00f6re renderer g\u00fcncellenir.","title":"8.3. Fonksiyon: Is\u0131 Haritas\u0131 Olu\u015fturma (Asenkron)"},{"location":"#84-fonksiyon-kalp-olusturma","text":"Ama\u00e7: Mesh'in PressureValues '\u0131na dayal\u0131 olarak protez kal\u0131b\u0131n\u0131 (deforme edilmi\u015f mesh) olu\u015fturmak. Mant\u0131ksal Ak\u0131\u015f: 1. Is\u0131 Haritas\u0131 Garantisi: \u0130\u015flem ba\u015flamadan \u00f6nce PressureValues '\u0131n do\u011fru bir \u015fekilde hesaplanm\u0131\u015f ve meshe atanm\u0131\u015f oldu\u011fundan emin olunur. 2. Deplasman Skaleri Hesaplama: Her bir nokta i\u00e7in bir deplasman skaleri ( displacement_scalar ) hesaplan\u0131r. Bu genellikle atanm\u0131\u015f bas\u0131n\u00e7 de\u011ferinin ( pressure_value ) bir warp_scale fakt\u00f6r\u00fc ile \u00e7arp\u0131lmas\u0131yla elde edilir (\u00f6rn: displacement_scalar = -pressure_value * warp_scale ). Negatif de\u011ferler, materyalin d\u0131\u015far\u0131 do\u011fru itilmesi anlam\u0131na gelir. 3. Geometri Deformasyonu: - Modeldeki her bir noktan\u0131n normal vekt\u00f6r\u00fc al\u0131n\u0131r. - Noktan\u0131n yeni konumu, yeni_konum = mevcut_konum + deplasman_skaleri * normal_vekt\u00f6r form\u00fcl\u00fcyle hesaplan\u0131r. - Bu, vtkWarpVector filtresi veya manuel nokta deplasman\u0131 algoritmalar\u0131 kullan\u0131larak ger\u00e7ekle\u015ftirilebilir. 4. MoldDisplacement Kayd\u0131: Hesaplanan deplasman de\u011ferleri, daha sonra tekrarlanabilirlik ve analiz i\u00e7in MoldDisplacement ad\u0131nda yeni bir skaler dizi olarak meshe atanabilir. 5. G\u00fcncelleme: Deforme olmu\u015f PolyData , active_poly_data olarak ayarlan\u0131r ve HistoryStack 'e eklenir. Render g\u00fcncellenir. 6. Meta Veri: Olu\u015fturulan kal\u0131b\u0131n \u00f6l\u00e7e\u011fi, minimum/maksimum deplasman gibi meta veriler, daha sonra raporlama veya analiz i\u00e7in kaydedilir.","title":"8.4. Fonksiyon: Kal\u0131p Olu\u015fturma"},{"location":"#85-fonksiyon-tarama-temizleme","text":"Ama\u00e7: Kullan\u0131c\u0131n\u0131n 2D bir se\u00e7imle 3D modelin istenmeyen k\u0131s\u0131mlar\u0131n\u0131 (\u00f6rn: tarama g\u00fcr\u00fclt\u00fcs\u00fc, gereksiz arka plan) silmesi. Mant\u0131ksal Ak\u0131\u015f: 1. Giri\u015f: Kullan\u0131c\u0131, 3D g\u00f6r\u00fcnt\u00fcleme penceresinde 2D bir dikd\u00f6rtgen veya serbest form bir alan \u00e7izer (fare s\u00fcr\u00fcklemesi ile). 2. 2D -> 3D D\u00f6n\u00fc\u015f\u00fcm: Sistem (VTK Picker ve Frustum s\u0131n\u0131flar\u0131), bu 2D se\u00e7im alan\u0131n\u0131, 3D uzayda bir se\u00e7im hacmine (frustum veya bounding box) d\u00f6n\u00fc\u015ft\u00fcr\u00fcr. Bu hacim, kameran\u0131n bak\u0131\u015f a\u00e7\u0131s\u0131 ve derinli\u011fi dikkate al\u0131narak olu\u015fturulur. 3. Kesme \u0130\u015flemi: Se\u00e7ilen 3D hacmin i\u00e7inde veya d\u0131\u015f\u0131nda kalan (kullan\u0131c\u0131n\u0131n se\u00e7imine ba\u011fl\u0131 olarak) t\u00fcm 3D geometri ( PolyData 'n\u0131n noktalar\u0131 ve h\u00fccreleri), vtkClipPolyData veya benzeri bir filtre kullan\u0131larak modelden \u00e7\u0131kar\u0131l\u0131r. 4. G\u00fcncelleme: Temizlenmi\u015f PolyData nesnesi, yeni \"Aktif Veri\" olarak ayarlan\u0131r ve HistoryStack 'e yeni bir i\u015flem olarak eklenir. Aray\u00fcz g\u00fcncellenir.","title":"8.5. Fonksiyon: Tarama Temizleme"},{"location":"#86-fonksiyon-anatomik-hizalama","text":"Ama\u00e7: 3D modeli (\u00f6rne\u011fin, ampute uzuv taramas\u0131), standart bir anatomik koordinat sistemine g\u00f6re yeniden y\u00f6nlendirmek (\u00f6rn: uzvun uzun eksenini Z eksenine, \u00f6n-arka y\u00f6n\u00fcn\u00fc Y eksenine hizalamak). Mant\u0131ksal Ak\u0131\u015f: 1. Giri\u015f: Kullan\u0131c\u0131, model \u00fczerinde stratejik anatomik referans noktalar\u0131n\u0131 i\u015faretler (\u00f6rn: b\u00fcy\u00fck trokanter, lateral/medial epikondil, distal u\u00e7). Bu noktalar, 3D uzayda vtkPointPicker gibi ara\u00e7larla se\u00e7ilir ve koordinatlar\u0131 saklan\u0131r. 2. Koordinat Sistemi Hesaplama: Sistem ( NumPy ve lineer cebir fonksiyonlar\u0131 kullanarak), i\u015faretlenen bu noktalardan yola \u00e7\u0131karak yeni bir anatomik koordinat sistemi (yeni X, Y, Z eksenleri) hesaplar. \u00d6rne\u011fin, uzvun uzun ekseni iki nokta aras\u0131ndaki vekt\u00f6rden, \u00f6n-arka ekseni ise di\u011fer noktalar\u0131n konumlar\u0131na g\u00f6re belirlenir. 3. D\u00f6n\u00fc\u015f\u00fcm Matrisi Olu\u015fturma: Modelin mevcut koordinat sistemi ile yeni hesaplanan anatomik koordinat sistemi aras\u0131nda ge\u00e7i\u015fi sa\u011flayacak bir d\u00f6n\u00fc\u015f\u00fcm (rotasyon ve translasyon) matrisi ( vtkTransform ) olu\u015fturulur. 4. Model Hizalama: vtkTransformPolyDataFilter kullan\u0131larak, t\u00fcm PolyData bu matris ile d\u00f6nd\u00fcr\u00fcl\u00fcr ve hizalanm\u0131\u015f olur. 5. G\u00fcncelleme: Hizalanm\u0131\u015f PolyData nesnesi \"Aktif Veri\" olarak kaydedilir ve HistoryStack g\u00fcncellenir.","title":"8.6. Fonksiyon: Anatomik Hizalama"},{"location":"#87-fonksiyon-hacimsel-deformasyon","text":"Ama\u00e7: Protez soketinin belirli b\u00f6lgelerinde (\u00f6rn: y\u00fck ta\u015f\u0131yan alanlar, hassas kemik b\u00f6lgeleri) \u00f6l\u00e7\u00fcleri hassas bir \u015fekilde art\u0131rmak (hacim ekleme) veya azaltmak (hacim \u00e7\u0131karma/s\u0131k\u0131\u015ft\u0131rma). Mant\u0131ksal Ak\u0131\u015f: 1. Giri\u015f: Kullan\u0131c\u0131, model \u00fczerinde deforme etmek istedi\u011fi bir b\u00f6lgeyi (\u00f6rn: kesit bantlar\u0131 ile, veya manuel f\u0131r\u00e7a ile) ve uygulanacak deformasyon miktar\u0131n\u0131 (+/- mm) tan\u0131mlar. 2. Nokta Se\u00e7imi ve Etki Alan\u0131: Sistem, tan\u0131mlanan b\u00f6lge i\u00e7indeki t\u00fcm 3D noktalar\u0131 belirler. Bir f\u0131r\u00e7a kullan\u0131l\u0131yorsa, f\u0131r\u00e7a merkezine olan uzakl\u0131\u011fa g\u00f6re bir \"etki d\u00fc\u015f\u00fc\u015f\u00fc\" (falloff) fonksiyonu hesaplan\u0131r. 3. Deformasyon Uygulama: - Her bir se\u00e7ili nokta i\u00e7in, noktan\u0131n y\u00fczey normal vekt\u00f6r\u00fc hesaplan\u0131r. - Nokta, belirlenen deformasyon miktar\u0131 ve falloff fonksiyonuna g\u00f6re (y\u00fczey normali boyunca) i\u00e7e (azaltma) veya d\u0131\u015fa (art\u0131rma) do\u011fru hareket ettirilir. - Bu i\u015flem, PolyData 'n\u0131n nokta koordinatlar\u0131n\u0131 do\u011frudan de\u011fi\u015ftirerek ger\u00e7ekle\u015ftirilir. 4. G\u00fcncelleme: Deforme olmu\u015f PolyData nesnesi \"Aktif Veri\" olarak ayarlan\u0131r ve HistoryStack 'e eklenir.","title":"8.7. Fonksiyon: Hacimsel Deformasyon"},{"location":"#9-kullanc-etkilesim-tasarm","text":"","title":"9. Kullan\u0131c\u0131 Etkile\u015fim Tasar\u0131m\u0131"},{"location":"#91-moduler-etkilesim-stilleri","text":"Uygulama, farkl\u0131 g\u00f6revler i\u00e7in farkl\u0131 fare ve klavye davran\u0131\u015flar\u0131 gerektirir. Bu, VTK 'n\u0131n vtkInteractorStyle s\u0131n\u0131f\u0131ndan t\u00fcretilen \"Etkile\u015fim Stilleri\" ad\u0131 verilen de\u011fi\u015ftirilebilir mod\u00fcllerle y\u00f6netilir. MainWindow (Controller), kullan\u0131c\u0131n\u0131n se\u00e7ti\u011fi araca g\u00f6re bu stiller aras\u0131nda dinamik olarak ge\u00e7i\u015f yapar. Kamera Stili (Varsay\u0131lan): Varsay\u0131lan mod. Kullan\u0131c\u0131n\u0131n 3D sahneyi serbest\u00e7e d\u00f6nd\u00fcrme, kayd\u0131rma ve yak\u0131nla\u015ft\u0131rma i\u015flemlerini (fare tekerle\u011fi, sol/orta/sa\u011f t\u0131klama ve s\u00fcr\u00fckleme ile) sa\u011flar. (\u00d6rn: vtkInteractorStyleTrackballCamera ). Se\u00e7im Stili: Tarama Temizleme arac\u0131 aktifken, kullan\u0131c\u0131n\u0131n 2D bir dikd\u00f6rtgen veya serbest form se\u00e7im alan\u0131 \u00e7izmesini sa\u011flar. Bu 2D se\u00e7im, 3D uzayda geometriyi kesmek veya filtrelemek i\u00e7in kullan\u0131l\u0131r. (\u00d6rn: vtkInteractorStyleRubberBand2D veya \u00f6zel bir interakt\u00f6r stili). \u0130\u015faretleme Stili: Anatomik Hizalama arac\u0131 aktifken, kullan\u0131c\u0131n\u0131n model \u00fczerinde belirli 3D noktalar\u0131 (\u00f6rn: kemik i\u015faretleri) t\u0131klayarak se\u00e7mesini sa\u011flar. Se\u00e7ilen noktalar, daha sonra d\u00f6n\u00fc\u015f\u00fcm matrisleri hesaplamak i\u00e7in kullan\u0131l\u0131r. (\u00d6rn: vtkInteractorStyleTrackballCamera ile birlikte vtkPointPicker kullan\u0131larak \u00f6zelle\u015ftirilmi\u015f bir stil). F\u0131r\u00e7a/Heykel Stili: Oyma/Ekleme veya Yumu\u015fatma ara\u00e7lar\u0131 aktifken, kullan\u0131c\u0131n\u0131n fareyi model \u00fczerinde s\u00fcr\u00fckleyerek lokal deformasyonlar veya yumu\u015fatmalar yapmas\u0131n\u0131 sa\u011flar. F\u0131r\u00e7a imleci ve etki alan\u0131 g\u00f6rselle\u015ftirilir. (\u00d6zel bir vtkInteractorStyle alt s\u0131n\u0131f\u0131).","title":"9.1. Mod\u00fcler Etkile\u015fim Stilleri"},{"location":"#15-mesh-islemleri-temsili","text":"Clonify Labs , protez kal\u0131plar\u0131n\u0131 haz\u0131rlamak ve d\u00fczeltmek i\u00e7in \u00e7e\u015fitli temel mesh i\u015fleme operasyonlar\u0131n\u0131 kullan\u0131r. Bu operasyonlar VTK k\u00fct\u00fcphanesinin g\u00fcc\u00fcn\u00fc kullan\u0131r. Operasyon Tekni\u011fi / VTK Filtresi A\u00e7\u0131klama Temizleme (Clean) vtkCleanPolyData Mesh'teki fazladan (duplicate) noktalar\u0131 birle\u015ftirmek, k\u00fc\u00e7\u00fck a\u00e7\u0131kl\u0131klar\u0131 kapatmak ve genel topolojik temizlik yapmak i\u00e7in kullan\u0131l\u0131r. Tarama verilerindeki hatalar\u0131 gidermede \u00f6nemlidir. Yumu\u015fatma (Smooth) (Taubin/Laplacian) vtkSmoothPolyDataFilter veya \u00f6zelle\u015fmi\u015f filtreler Mesh y\u00fczeyindeki p\u00fcr\u00fczl\u00fcl\u00fc\u011f\u00fc azalt\u0131r, k\u00f6\u015feleri yumu\u015fat\u0131r ve daha organik bir g\u00f6r\u00fcn\u00fcm sa\u011flar. Konfor a\u00e7\u0131s\u0131ndan kritik bir ad\u0131md\u0131r. Basitle\u015ftirme (Decimate) vtkDecimatePro ile hedef azaltma oran\u0131 Mesh'in poligon say\u0131s\u0131n\u0131 azalt\u0131r. Dosya boyutunu k\u00fc\u00e7\u00fclt\u00fcr ve i\u015flem performans\u0131n\u0131 art\u0131r\u0131r, ancak modelin detay seviyesini d\u00fc\u015f\u00fcrebilir. Alt B\u00f6l\u00fcmlere Ay\u0131rma (Subdivide) vtkLoopSubdivisionFilter (ayarlanabilir iterasyonlar) Mesh'in poligon say\u0131s\u0131n\u0131 art\u0131r\u0131r, y\u00fczeylere daha fazla detay ekler ve daha p\u00fcr\u00fczs\u00fcz k\u0131vr\u0131mlar sa\u011flar. \u00d6zellikle manuel \u015fekillendirme i\u00e7in daha fazla kontrol sa\u011flar. Normallerin Yeniden Hesaplanmas\u0131 vtkPolyDataNormals (modifikasyon sonras\u0131) Mesh \u00fczerinde yap\u0131lan deformasyonlar sonras\u0131 noktalar\u0131n ve y\u00fczeylerin normal vekt\u00f6rlerini yeniden hesaplar. Do\u011fru g\u00f6rselle\u015ftirme ve sonraki i\u015flemler (\u00f6rn: kal\u0131nl\u0131k verme) i\u00e7in esast\u0131r. \u00c7arp\u0131tma (Warp) (Kal\u0131p i\u00e7in) vtkWarpVector veya manuel nokta deplasman\u0131 Kal\u0131p olu\u015fturma s\u00fcrecinde, belirli bir y\u00f6nde (genellikle y\u00fczey normali boyunca) ve belirli bir miktar kadar noktalar\u0131 kayd\u0131rarak mesh'i deforme eder. Bas\u0131n\u00e7 de\u011ferleri bu deplasman miktar\u0131n\u0131 belirleyebilir.","title":"15. Mesh \u0130\u015flemleri (Temsili)"},{"location":"#16-performans-stratejileri","text":"Yaz\u0131l\u0131m\u0131n yo\u011fun 3D i\u015flemler s\u0131ras\u0131nda bile kullan\u0131c\u0131 aray\u00fcz\u00fcn\u00fcn (UI) duyarl\u0131 kalmas\u0131n\u0131 sa\u011flamak i\u00e7in \u00e7e\u015fitli performans optimizasyon stratejileri uygulanm\u0131\u015ft\u0131r. Endi\u015fe Teknik UI Donmas\u0131 \u0130\u015flem maliyeti y\u00fcksek fonksiyonlar i\u00e7in ayr\u0131 i\u015f par\u00e7ac\u0131klar\u0131 ( QThread ) ve sinyaller ( PyQt Signal/Slot ) kullanarak arka planda i\u015flem y\u00fcr\u00fctme. A\u015f\u0131r\u0131 Render \u00c7a\u011fr\u0131lar\u0131 H\u0131zl\u0131 ard\u0131\u015f\u0131k g\u00fcncelIemeleri ( mouseMoveEvent gibi) tek bir render \u00e7a\u011fr\u0131s\u0131nda birle\u015ftiren gruplama ( BatchRenderer ) ve k\u0131s\u0131tlama (throttling) mekanizmalar\u0131. Uzamsal Sorgular vtkStaticPointLocator gibi VTK 'n\u0131n optimize edilmi\u015f uzamsal indeksleme yap\u0131lar\u0131n\u0131n yeniden kullan\u0131m\u0131. Bu, b\u00fcy\u00fck meshlerdeki noktalara h\u0131zl\u0131 eri\u015fim sa\u011flar (\u00f6rn: f\u0131r\u00e7a etki alan\u0131 sorgular\u0131). Skaler Dizi G\u00fcncellemeleri Skaler dizilerin ( vtkFloatArray ) her de\u011fi\u015fiklikte yeniden olu\u015fturulmas\u0131 yerine, mevcut dizi verilerinin do\u011frudan bellekte g\u00fcncellenmesi (in-place modification). Geri Alma Y\u0131\u011f\u0131n\u0131 Boyutu Tam PolyData kopyalar\u0131 yerine, yaln\u0131zca de\u011fi\u015ftirilen nokta ID'leri ve eski/yeni de\u011ferler gibi delta de\u011fi\u015fikliklerini depolayarak y\u0131\u011f\u0131n boyutunu optimize etme. B\u00fcy\u00fck Mesh Yumu\u015fatma Yumu\u015fatma iterasyonlar\u0131n\u0131n s\u0131n\u0131rlanmas\u0131, yo\u011fun mesh'ler i\u00e7in i\u015flem \u00f6ncesi basitle\u015ftirme (decimation) uygulama. GPU Kullan\u0131m\u0131 (iste\u011fe ba\u011fl\u0131) M\u00fcmk\u00fcn oldu\u011funda VTK 'n\u0131n GPU destekli mapper'lar\u0131n\u0131 veya filtrelerini kullanma. GPU mevcut de\u011filse sorunsuz bir \u015fekilde CPU tabanl\u0131 y\u00f6ntemlere geri d\u00fc\u015fme. \u0130zleme: - Maliyetli operasyonlar\u0131n (\u00f6rn: mesh i\u015fleme) s\u00fcrelerini kaydetmek i\u00e7in loglama kullan\u0131l\u0131r. - \u00d6nemli performans noktalar\u0131 i\u00e7in basit zamanlama dekorat\u00f6rlerinin entegrasyonu potansiyel bir iyile\u015ftirmedir.","title":"16. Performans Stratejileri"},{"location":"#17-loglama-ve-hata-yonetimi","text":"Uygulaman\u0131n \u00e7al\u0131\u015fma zaman\u0131 davran\u0131\u015f\u0131n\u0131 izlemek, sorunlar\u0131 te\u015fhis etmek ve kullan\u0131c\u0131ya geri bildirim sa\u011flamak i\u00e7in kapsaml\u0131 bir loglama ve hata y\u00f6netimi stratejisi benimsenmi\u015ftir. Mod\u00fcl Ba\u015f\u0131na Logger: print ifadeleri yerine, her Python mod\u00fcl\u00fc i\u00e7in ayr\u0131 bir logging nesnesi kullan\u0131l\u0131r. Bu, g\u00fcnl\u00fcklerin d\u00fczenli olmas\u0131n\u0131 ve filtrelenmesini kolayla\u015ft\u0131r\u0131r. Kullan\u0131c\u0131ya Y\u00f6nelik Durum Sinyalleri: Kullan\u0131c\u0131 aray\u00fcz\u00fcnde g\u00f6r\u00fcnen durum mesajlar\u0131 i\u00e7in \u00f6zel sinyaller ( logMessage ) kullan\u0131l\u0131r. Bu sinyaller, i\u015flemin ba\u015flad\u0131\u011f\u0131n\u0131, ilerlemesini, tamamland\u0131\u011f\u0131n\u0131 veya bir hata olu\u015ftu\u011funu kullan\u0131c\u0131ya bildirir. Desteklenmeyen Dosya Tipleri: Desteklenmeyen dosya uzant\u0131lar\u0131 veya bozuk mesh dosyalar\u0131 i\u00e7in y\u00fckleme a\u015famas\u0131nda erken ret mekanizmalar\u0131 bulunur. Bu durumlar g\u00fcnl\u00fc\u011fe kaydedilir ve kullan\u0131c\u0131ya a\u00e7\u0131k bir hata mesaj\u0131 sunulur. Asenkron Hata Yakalama: Asenkron i\u015f par\u00e7ac\u0131klar\u0131nda (\u00f6rn: AsyncMeshProcessor ) meydana gelen istisnalar try / catch bloklar\u0131 i\u00e7inde yakalan\u0131r. Hata detaylar\u0131 g\u00fcnl\u00fc\u011fe kaydedilir ve ana thread'e bir hata sinyali g\u00f6nderilerek UI'\u0131n duyarl\u0131 kalmas\u0131 sa\u011flan\u0131r. G\u00fcnl\u00fck Dosyalar\u0131: \u00c7al\u0131\u015fma zaman\u0131 g\u00fcnl\u00fckleri, logs/ dizini alt\u0131nda zaman damgal\u0131 dosyalar halinde saklan\u0131r. Bu g\u00fcnl\u00fckler, sorun giderme ve uygulama denetimleri i\u00e7in kullan\u0131labilir. Ba\u011flam \u0130\u00e7eri\u011fi: Hata mesajlar\u0131na, ilgili mesh dosyas\u0131n\u0131n ad\u0131 gibi ba\u011flam bilgileri eklenerek sorunlar\u0131n tespiti kolayla\u015ft\u0131r\u0131l\u0131r.","title":"17. Loglama ve Hata Y\u00f6netimi"},{"location":"#18-konfigurasyon-ve-ortam","text":"Yaz\u0131l\u0131m\u0131n kurulumu ve farkl\u0131 ortamlarda \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131 i\u00e7in konfig\u00fcrasyon ve ba\u011f\u0131ml\u0131l\u0131k y\u00f6netimi stratejileri belirlenmi\u015ftir. Python 3.11 Hedefi: Proje, Python 3.11 veya daha yeni versiyonlar\u0131n\u0131 hedef alarak en g\u00fcncel dil \u00f6zelliklerinden ve performans iyile\u015ftirmelerinden faydalan\u0131r. Ba\u011f\u0131ml\u0131l\u0131k Y\u00f6netimi: T\u00fcm Python ba\u011f\u0131ml\u0131l\u0131klar\u0131 ( PyQt5 , VTK , NumPy vb.) pyproject.toml veya requirements.txt dosyalar\u0131 arac\u0131l\u0131\u011f\u0131yla y\u00f6netilir. Bu, projenin farkl\u0131 geli\u015ftirme veya da\u011f\u0131t\u0131m ortamlar\u0131nda ba\u011f\u0131ml\u0131l\u0131klar\u0131n kolayca kurulmas\u0131n\u0131 sa\u011flar. \u00c7al\u0131\u015fma Zaman\u0131 Dizini Yap\u0131s\u0131: logs/ : \u00c7al\u0131\u015fma zaman\u0131 g\u00fcnl\u00fcklerinin depoland\u0131\u011f\u0131 yaz\u0131labilir bir dizindir. Uygulama ilk \u00e7al\u0131\u015ft\u0131\u011f\u0131nda otomatik olarak olu\u015fturulur. data/ : Test mesh'leri ve prosed\u00fcrel \u00f6rnek mesh'ler gibi statik verilerin sakland\u0131\u011f\u0131 dizindir. \u0130ste\u011fe Ba\u011fl\u0131 Ortam De\u011fi\u015fkenleri: Gelecekte, uygulaman\u0131n davran\u0131\u015f\u0131n\u0131 etkileyebilecek (\u00f6rn: debug modu, varsay\u0131lan dosya yollar\u0131) ortam de\u011fi\u015fkenleri i\u00e7in merkezi bir konfig\u00fcrasyon ( app/core/config.py ) veya d\u0131\u015far\u0131dan y\u00fcklenen bir .env dosyas\u0131 kullan\u0131labilir ve bu dok\u00fcmanda belgelenmelidir.","title":"18. Konfig\u00fcrasyon ve Ortam"},{"location":"#19-derleme-ve-bagmllk-yonetimi","text":"Yaz\u0131l\u0131m\u0131n geli\u015ftirme ve da\u011f\u0131t\u0131m s\u00fcre\u00e7lerinde ba\u011f\u0131ml\u0131l\u0131klar\u0131n y\u00f6netimi ve derleme (build) ad\u0131mlar\u0131 belirlenmi\u015ftir. Kurulum Y\u00f6ntemi: Geli\u015ftirme ortam\u0131nda, proje pip install -e . komutuyla kurulabilir (e\u011fer pyproject.toml projenin tan\u0131m\u0131n\u0131 i\u00e7eriyorsa). Bu, projenin kaynak koduna do\u011frudan ba\u011fl\u0131 olarak d\u00fczenlenebilir bir kurulum sa\u011flar. S\u00fcr\u00fcm Sabitleme: \u00d6zellikle VTK gibi kritik k\u00fct\u00fcphanelerin belirli s\u00fcr\u00fcmleri sabitlenir ( requirements.txt dosyas\u0131nda vtk==X.Y.Z gibi). Bu, farkl\u0131 VTK versiyonlar\u0131n\u0131n yol a\u00e7abilece\u011fi uyumluluk sorunlar\u0131n\u0131 veya \u00e7al\u0131\u015fma zaman\u0131 davran\u0131\u015f farkl\u0131l\u0131klar\u0131n\u0131 \u00f6nler. S\u00fcrekli Entegrasyon (CI - Gelecek): Gelecekte bir CI/CD boru hatt\u0131 kurulmas\u0131 planlanmaktad\u0131r. Bu hat, kod kalitesini ve kararl\u0131l\u0131\u011f\u0131n\u0131 sa\u011flamak i\u00e7in \u015fu ad\u0131mlar\u0131 otomatik olarak \u00e7al\u0131\u015ft\u0131racakt\u0131r: Linting ve Stil Kontrolleri: Kodun PEP8 gibi stil rehberlerine uygunlu\u011funu kontrol eder. \u00c7ekirdek Testler: Temel i\u015flevselli\u011fin do\u011fru \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan emin olmak i\u00e7in birim ve entegrasyon testlerini \u00e7al\u0131\u015ft\u0131r\u0131r. Performans Smoke Testleri: Kritik operasyonlarda performans d\u00fc\u015f\u00fc\u015fleri olup olmad\u0131\u011f\u0131n\u0131 kontrol etmek i\u00e7in se\u00e7ilmi\u015f performans testlerini \u00e7al\u0131\u015ft\u0131r\u0131r. Paketleme (Da\u011f\u0131t\u0131m i\u00e7in): Son kullan\u0131c\u0131 da\u011f\u0131t\u0131mlar\u0131 i\u00e7in, PyInstaller gibi ara\u00e7lar kullan\u0131larak Python uygulamas\u0131 tek bir y\u00fcr\u00fct\u00fclebilir dosyaya (executable) paketlenebilir. Bu, ba\u011f\u0131ml\u0131l\u0131klar\u0131 y\u00f6netme y\u00fck\u00fcn\u00fc son kullan\u0131c\u0131dan al\u0131r. Ba\u015flatma Betikleri: Platformlar aras\u0131 uyumluluk sa\u011flamak i\u00e7in iste\u011fe ba\u011fl\u0131 ba\u015flatma betikleri (launcher scripts) sa\u011flanabilir.","title":"19. Derleme ve Ba\u011f\u0131ml\u0131l\u0131k Y\u00f6netimi"},{"location":"#20-kodlama-standartlar","text":"Kodun okunabilirli\u011fini, s\u00fcrd\u00fcr\u00fclebilirli\u011fini ve ekip i\u00e7inde tutarl\u0131l\u0131\u011f\u0131 sa\u011flamak i\u00e7in belirli kodlama standartlar\u0131 benimsenmi\u015ftir. PEP8 Uyumlulu\u011fu: Python kodunun b\u00fcy\u00fck \u00f6l\u00e7\u00fcde PEP8 stil rehberine uygun olmas\u0131 hedeflenir. Ancak, \u00f6zellikle VTK boru hatlar\u0131n\u0131n okunabilirli\u011fini art\u0131rmak amac\u0131yla, baz\u0131 durumlarda daha uzun ve birle\u015fik fonksiyonlara pratik tolerans g\u00f6sterilebilir. Tip \u0130pu\u00e7lar\u0131 (Type Hints): T\u00fcm genel (public) aray\u00fczlerde ve m\u00fcmk\u00fcn oldu\u011funca di\u011fer yerlerde tip ipu\u00e7lar\u0131 (type hints) kullan\u0131l\u0131r. Bu, kodun anla\u015f\u0131l\u0131rl\u0131\u011f\u0131n\u0131 art\u0131r\u0131r ve statik analiz ara\u00e7lar\u0131yla potansiyel hatalar\u0131n erken tespitine yard\u0131mc\u0131 olur. Dok\u00fcman Dizileri (Docstrings): Her fonksiyon, s\u0131n\u0131f ve \u00f6nemli metot i\u00e7in k\u0131sa bir \u00f6zet sat\u0131r\u0131 i\u00e7eren docstring'ler yaz\u0131l\u0131r. Parametreler ve d\u00f6n\u00fc\u015f de\u011ferleri hakk\u0131nda detayl\u0131 bilgi sa\u011flan\u0131r. Skaler Dizi Adland\u0131rmas\u0131: PressureValues , MoldDisplacement gibi skaler diziler i\u00e7in tutarl\u0131 ve a\u00e7\u0131klay\u0131c\u0131 adland\u0131rma standartlar\u0131 kullan\u0131l\u0131r. Harici K\u00fct\u00fcphanelerden Ka\u00e7\u0131nma: Zorunlu olmad\u0131k\u00e7a yeni harici Python k\u00fct\u00fcphaneleri eklemekten ka\u00e7\u0131n\u0131l\u0131r. Yeni bir ba\u011f\u0131ml\u0131l\u0131k eklenmeden \u00f6nce dikkatlice de\u011ferlendirilir. Loglama Kullan\u0131m\u0131: Kod i\u00e7inde print() ifadeleri yerine, hata ay\u0131klama ve izleme i\u00e7in merkezi loglama ( logging mod\u00fcl\u00fc) tercih edilir. \u0130stisnalar sessizce yutulmaz; uygun hata loglar\u0131 kaydedilir.","title":"20. Kodlama Standartlar\u0131"},{"location":"#21-test-stratejisi","text":"Yaz\u0131l\u0131m\u0131n do\u011frulu\u011funu, g\u00fcvenilirli\u011fini ve performans\u0131n\u0131 sa\u011flamak i\u00e7in kapsaml\u0131 bir test stratejisi uygulanmaktad\u0131r. Mevcut Test Betikleri: Projenin test klas\u00f6r\u00fcnde ( tests/ ) bulunan mevcut test betikleri, uygulaman\u0131n \u00e7e\u015fitli \u00f6zelliklerini do\u011frulamak i\u00e7in kullan\u0131l\u0131r: - test_pressure_mapping.py : Bas\u0131n\u00e7 boyama, \u0131s\u0131 haritas\u0131 olu\u015fturma ve UI entegrasyonunun temel i\u015flevselli\u011fini do\u011frular. - test_enhanced_pressure_mapping.py : Geli\u015fmi\u015f bas\u0131n\u00e7 boyama \u00f6zelliklerini test eder. - test_split_view_pressure_mapping.py : \u00c7oklu g\u00f6r\u00fcn\u00fcmdeki bas\u0131n\u00e7 boyama ve g\u00f6rselle\u015ftirme davran\u0131\u015f\u0131n\u0131 test eder. - test_mesh_subdivision.py : Mesh alt b\u00f6l\u00fcmlere ay\u0131rma (subdivision) do\u011frulu\u011funu test eder. - test_page3_performance.py : UI'\u0131n belirli sayfalardaki performans\u0131n\u0131 ve tepki s\u00fcresini test eder. - test_gpu_performance.py : GPU h\u0131zland\u0131rma yollar\u0131n\u0131n performans\u0131n\u0131 test eder. - test_landmarks.py : \u0130\u015faret noktas\u0131 yerle\u015ftirme mant\u0131\u011f\u0131n\u0131 do\u011frular. - test_orientation_definition.py : Anatomik y\u00f6nelim hesaplama boru hatt\u0131n\u0131 test eder. - test_page4_cutting_patterns.py : Kesme deseni olu\u015fturma davran\u0131\u015f\u0131n\u0131 test eder. - MOLD_GENERATION_SUCCESS.py gibi betikler, kal\u0131p olu\u015fturma i\u015f ak\u0131\u015flar\u0131n\u0131n ba\u015far\u0131yla tamamland\u0131\u011f\u0131n\u0131 g\u00f6sterir. Test Desenleri: - Prosed\u00fcrel Geometri: Testlerde, d\u0131\u015f dosyalar yerine genellikle k\u00fcp, k\u00fcre gibi basit prosed\u00fcrel geometriler veya programatik olarak olu\u015fturulmu\u015f mesh'ler kullan\u0131l\u0131r. Bu, testlerin ba\u011f\u0131ms\u0131zl\u0131\u011f\u0131n\u0131 ve tekrarlanabilirli\u011fini art\u0131r\u0131r. - Onaylamalar (Assertions): Nokta say\u0131lar\u0131, skaler de\u011fer aral\u0131klar\u0131, fonksiyonlar\u0131n \u00e7\u00f6kmeden \u00e7al\u0131\u015fmas\u0131 gibi konular \u00fczerinde net onaylamalar ( assert ) kullan\u0131l\u0131r. - Geri Al/\u0130leri Al Do\u011frulamas\u0131: Modifikasyonlar sonras\u0131 HistoryStack 'in do\u011fru \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan ve geri alma/ileri alma i\u015flemlerinin veriyi tutarl\u0131 bir \u015fekilde \u00f6nceki/sonraki durumlara d\u00f6nd\u00fcrd\u00fc\u011f\u00fcnden emin olmak i\u00e7in \u00f6zel testler bulunur. - Kal\u0131p Deplasman\u0131 Tutarl\u0131l\u0131\u011f\u0131: Kal\u0131p olu\u015fturma i\u015fleminde minimum/maksimum deplasman de\u011ferlerinin ve genel geometri tutarl\u0131l\u0131\u011f\u0131n\u0131n korunup korunmad\u0131\u011f\u0131 test edilir. - Performans E\u015fi\u011fi Kontrol\u00fc: Belirli operasyonlar\u0131n belirtilen performans e\u015fiklerini a\u015fmad\u0131\u011f\u0131n\u0131 do\u011frulamak i\u00e7in zamanlama testleri kullan\u0131l\u0131r. Test Kategorileri: - Birim Testleri: Her bir fonksiyon veya k\u00fc\u00e7\u00fck s\u0131n\u0131f\u0131n izole edilmi\u015f bir \u015fekilde do\u011fru \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 do\u011frular. - Entegrasyon Testleri: Farkl\u0131 mod\u00fcllerin veya katmanlar\u0131n birbiriyle do\u011fru etkile\u015fim kurdu\u011funu do\u011frular. - Sistem Testleri: T\u00fcm uygulaman\u0131n u\u00e7tan uca senaryolarda beklendi\u011fi gibi \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 do\u011frular. - Performans Testleri: Belirli operasyonlar\u0131n ve genel uygulaman\u0131n tepki s\u00fcresi ve kaynak kullan\u0131m\u0131 hedeflerini kar\u015f\u0131lad\u0131\u011f\u0131n\u0131 do\u011frular. - Regresyon Testleri: Yeni kod eklendikten veya mevcut kod de\u011fi\u015ftirildikten sonra, daha \u00f6nce \u00e7al\u0131\u015fan \u00f6zelliklerin hala do\u011fru \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 garanti eder.","title":"21. Test Stratejisi"},{"location":"#22-kalite-kontrolleri","text":"Yaz\u0131l\u0131m\u0131n y\u00fcksek kalitesini s\u00fcrekli olarak sa\u011flamak i\u00e7in \u00e7e\u015fitli kalite kontrol mekanizmalar\u0131 belirlenmi\u015ftir. Kontrol Noktas\u0131 Ama\u00e7 Linting/Stil Kontrol\u00fc Kodun okunabilirli\u011fini ve stil standartlar\u0131na (\u00f6rn. PEP8) uygunlu\u011funu s\u00fcrd\u00fcrmek. Tip Kontrol\u00fc (iste\u011fe ba\u011fl\u0131) Aray\u00fcz tutars\u0131zl\u0131klar\u0131n\u0131 ve tip hatalar\u0131n\u0131 tespit etmek i\u00e7in Python'\u0131n tip ipu\u00e7lar\u0131 ile statik analiz ara\u00e7lar\u0131 kullanmak. Birim Testleri Her bir k\u00fc\u00e7\u00fck kod biriminin (fonksiyon, metod) do\u011fru \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan emin olmak. Performans Smoke Testleri Boyama ve kal\u0131p olu\u015fturma boru hatlar\u0131 gibi kritik i\u015flevlerde performans gerilemelerinin olmad\u0131\u011f\u0131n\u0131 do\u011frulamak. Loglama Varl\u0131\u011f\u0131 Temel operasyonlar\u0131n izlenebilirlik i\u00e7in do\u011fru g\u00fcnl\u00fck mesajlar\u0131 \u00fcretti\u011fini ve bu g\u00fcnl\u00fcklerin yeterli izleme bilgisi i\u00e7erdi\u011fini do\u011frulamak.","title":"22. Kalite Kontrolleri"},{"location":"#23-guvenlik-ve-gizlilik","text":"Medikal bir yaz\u0131l\u0131m olarak, g\u00fcvenlik ve gizlilik Clonify Labs i\u00e7in kritik \u00f6neme sahiptir. Ki\u015fisel Sa\u011fl\u0131k Bilgilerinin ( PHI ) korunmas\u0131 en \u00fcst d\u00fczeyde \u00f6nceliklidir. PHI Saklama: Yaz\u0131l\u0131m, hasta tan\u0131mlay\u0131c\u0131 bilgilerini veya ki\u015fisel sa\u011fl\u0131k bilgilerini ( PHI ) do\u011frudan kal\u0131c\u0131 olarak saklamaz. Mesh dosya adlar\u0131 anonimle\u015ftirilir veya jenerik bir formatta tutulur. G\u00fcnl\u00fck Dosyalar\u0131: G\u00fcnl\u00fck dosyalar\u0131, hasta tan\u0131mlay\u0131c\u0131lar\u0131n\u0131 i\u00e7ermez. Yaln\u0131zca teknik sorun giderme i\u00e7in gerekli olan uygulama davran\u0131\u015flar\u0131 ve hata bilgileri kaydedilir. A\u011f \u0130leti\u015fimi: Mevcut durumda, yaz\u0131l\u0131m\u0131n herhangi bir a\u011f \u00fczerinden do\u011frudan geometri veya hasta verisi iletimi yapmad\u0131\u011f\u0131 varsay\u0131l\u0131r (\u00e7evrimd\u0131\u015f\u0131 masa\u00fcst\u00fc uygulamas\u0131 olarak \u00e7al\u0131\u015f\u0131r). Gelecek Geni\u015fletmeleri: E\u011fer gelecekte bulut senkronizasyonu veya \u00e7ok kullan\u0131c\u0131l\u0131 i\u015fbirli\u011fi gibi a\u011f ba\u011flant\u0131l\u0131 \u00f6zellikler eklenirse: Veri \u015eifreleme: Saklanan oturum durumlar\u0131 veya iletilen veriler i\u00e7in end\u00fcstri standard\u0131 \u015fifreleme y\u00f6ntemleri (\u00f6rn: AES-256) kullan\u0131lacakt\u0131r. Kimlik Do\u011frulama ve Yetkilendirme: Kullan\u0131c\u0131 kimlik do\u011frulamas\u0131 (\u00f6rne\u011fin, OAuth, API anahtarlar\u0131) ve yetkilendirme (rol tabanl\u0131 eri\u015fim kontrol\u00fc) mekanizmalar\u0131 uygulanacakt\u0131r. G\u00fcvenli Protokoller: HTTPS/TLS gibi g\u00fcvenli ileti\u015fim protokolleri zorunlu tutulacakt\u0131r. Gizlilik Politikalar\u0131: PHI 'nin nas\u0131l i\u015flendi\u011fini, sakland\u0131\u011f\u0131n\u0131 ve korundu\u011funu a\u00e7\u0131klayan net gizlilik politikalar\u0131 belirlenecek ve kullan\u0131c\u0131lara sunulacakt\u0131r.","title":"23. G\u00fcvenlik ve Gizlilik"},{"location":"#24-riskler-ve-azaltma-yontemleri","text":"Proje boyunca kar\u015f\u0131la\u015f\u0131labilecek potansiyel riskler ve bunlar\u0131 azaltmaya y\u00f6nelik stratejiler belirlenmi\u015ftir. Risk Etki Azaltma Y\u00f6ntemi VTK S\u00fcr\u00fcm Uyumsuzlu\u011fu \u00c7al\u0131\u015fma zaman\u0131 hatalar\u0131, beklenmeyen davran\u0131\u015flar. Ba\u011f\u0131ml\u0131l\u0131klar\u0131 belirli s\u00fcr\u00fcmlere sabitlemek ( pip freeze veya requirements.txt ile) ve farkl\u0131 VTK versiyonlar\u0131yla d\u00fczenli test matrisi \u00e7al\u0131\u015ft\u0131rmak. B\u00fcy\u00fck Mesh Bellek Kullan\u0131m\u0131 Uygulama yava\u015flamas\u0131/donmas\u0131 veya \u00e7\u00f6kmesi. B\u00fcy\u00fck mesh'ler i\u00e7in \u00f6n i\u015flemde basitle\u015ftirme (decimation) uygulama, gelecekte veri ak\u0131\u015f\u0131n\u0131 optimize eden \"streaming\" teknikleri ara\u015ft\u0131rmak. UI Donmas\u0131 (Yan\u0131t Vermemesi) Kullan\u0131c\u0131 deneyiminin k\u00f6t\u00fcle\u015fmesi, \u00fcretkenlik kayb\u0131. T\u00fcm maliyetli operasyonlar\u0131 (dosya y\u00fckleme, karma\u015f\u0131k hesaplamalar) ayr\u0131 i\u015f par\u00e7ac\u0131klar\u0131nda ( QThread ) y\u00fcr\u00fctme ve sinyallerle ileti\u015fim kurma. Geri Alma Y\u0131\u011f\u0131n\u0131 B\u00fcy\u00fcmesi A\u015f\u0131r\u0131 bellek t\u00fcketimi, performans d\u00fc\u015f\u00fc\u015f\u00fc. Ge\u00e7mi\u015f y\u0131\u011f\u0131n\u0131n\u0131 belirli bir boyutta s\u0131n\u0131rlama veya tam mesh kopyalar\u0131 yerine sadece de\u011fi\u015fiklikleri (delta) s\u0131k\u0131\u015ft\u0131rarak depolama. Skaler Dizi Tutars\u0131zl\u0131\u011f\u0131 G\u00f6rsel hatalar, hatal\u0131 \u0131s\u0131 haritalar\u0131 veya kal\u0131p deformasyonlar\u0131. Skaler dizi g\u00fcncellemeleri i\u00e7in merkezi ve g\u00fcvenli bir i\u015flev kullanma, g\u00fcncellemeleri yaln\u0131zca ana i\u015f par\u00e7ac\u0131\u011f\u0131nda yapma. GPU Yolu Ayr\u0131\u015fmas\u0131 Farkl\u0131 donan\u0131mlarda tekrarlanamayan veya zor te\u015fhis edilen hatalar. GPU destekli \u00f6zellikler i\u00e7in iste\u011fe ba\u011fl\u0131 kod yollar\u0131 sa\u011flama ve GPU mevcut olmad\u0131\u011f\u0131nda sorunsuz bir \u015fekilde CPU tabanl\u0131 y\u00f6ntemlere geri d\u00f6nme. Hem GPU hem de CPU yollar\u0131n\u0131 test etme. Ki\u015fisel Sa\u011fl\u0131k Bilgileri (PHI) S\u0131z\u0131nt\u0131s\u0131 Yasal sorunlar, hasta g\u00fcveninin kayb\u0131. Hasta verilerini anonimle\u015ftirme, g\u00fcnl\u00fcklerde PHI bulundurmama, a\u011f iletimi i\u00e7in \u015fifreleme (gelecekte) ve eri\u015fim kontrolleri. A\u015f\u0131r\u0131 Kullan\u0131c\u0131 Geribildirimi/F\u0131r\u00e7a Darbeleri Performans d\u00fc\u015f\u00fc\u015f\u00fc, gereksiz i\u015flem y\u00fck\u00fc. F\u0131r\u00e7a darbelerini veya h\u0131zl\u0131 olaylar\u0131 grupland\u0131ran ve belirli bir oranda i\u015fleyen k\u0131s\u0131tlama (throttling) mekanizmalar\u0131 kullanma. Yeni Geli\u015ftirici Onboarding S\u00fcresi Ekip b\u00fcy\u00fcmesinde verimlilik kayb\u0131. Minimum geli\u015ftirici onboarding ad\u0131mlar\u0131 sa\u011flama, kapsaml\u0131 dok\u00fcmantasyon ve \u00f6rnekler sunma.","title":"24. Riskler ve Azaltma Y\u00f6ntemleri"},{"location":"#25-gelecek-gelistirmeler-ve-genisletme-noktalar","text":"APPClonify '\u0131n mevcut mimarisi, gelecekteki fonksiyonel ve teknolojik geni\u015fletmeler i\u00e7in g\u00fc\u00e7l\u00fc bir temel sa\u011flamaktad\u0131r. A\u015fa\u011f\u0131daki alanlar, potansiyel gelecek geli\u015ftirmeler ve geni\u015fletme noktalar\u0131 olarak tan\u0131mlanm\u0131\u015ft\u0131r: Oturum Serile\u015ftirme: Strateji: Mevcut oturum durumunu (bas\u0131n\u00e7 verileri, i\u015faret noktalar\u0131, modifiye edilmi\u015f mesh ve t\u00fcm ge\u00e7mi\u015f y\u0131\u011f\u0131n\u0131) tek bir dosyada kaydetme ve y\u00fckleme yetene\u011fi ekleme. Bu, kullan\u0131c\u0131lar\u0131n projelerine daha sonra devam etmelerini sa\u011flar. Teknoloji: JSON veya XML tabanl\u0131 \u00f6zel bir dosya format\u0131 kullanarak t\u00fcm Python ve VTK nesnelerini serile\u015ftirme ( pickle veya \u00f6zel serile\u015ftirme mant\u0131\u011f\u0131 gerekebilir). Parametrik Kal\u0131p Tasar\u0131m\u0131: Strateji: Tek tip kal\u0131nl\u0131k uygulaman\u0131n \u00f6tesinde, kullan\u0131c\u0131n\u0131n farkl\u0131 anatomik b\u00f6lgeler i\u00e7in katmanl\u0131 veya de\u011fi\u015fken kal\u0131nl\u0131k profilleri tan\u0131mlamas\u0131na olanak tan\u0131yan parametrik bir sistem geli\u015ftirme. Teknoloji: \u00d6zel UI widget'lar\u0131 ve arka u\u00e7ta geometriyi katmanlara ay\u0131r\u0131p her katman\u0131 ayr\u0131 ayr\u0131 deforme eden VTK filtreleri. Kesme Desenleri \u0130\u00e7in Geli\u015fmi\u015f D\u00fczle\u015ftirme (Unwrapping): Strateji: Kesilmi\u015f 3D mesh y\u00fczeylerini, fiziksel \u015fablon \u00fcretimi veya kuma\u015f kesimi i\u00e7in 2D d\u00fczleme do\u011fru bir \u015fekilde a\u00e7ma (unwrapping) yetene\u011fi ekleme. Teknoloji: vtkUnwrapPolyData gibi VTK filtreleri veya \u00f6zel d\u00fczle\u015ftirme algoritmalar\u0131. Sonlu Elemanlar Analizi (FEM) Entegrasyonu: Strateji: Protez soketinin biyomekanik davran\u0131\u015f\u0131n\u0131 (\u00f6rn: bas\u0131n\u00e7 noktalar\u0131, gerilme) sim\u00fcle etmek i\u00e7in harici bir FEM \u00e7\u00f6z\u00fcc\u00fcs\u00fcn\u00fc entegre etme. Teknoloji: Harici bir FEM k\u00fct\u00fcphanesi (\u00f6rn: FEniCS, PyVista ile entegre), mesh'i FEM i\u00e7in uygun formata d\u00f6n\u00fc\u015ft\u00fcrme ve sonu\u00e7lar\u0131 geri PolyData 'ya map etme. \u00c7oklu F\u0131r\u00e7a Ayarlar\u0131 ve Bas\u0131n\u00e7 AI \u00d6nerileri: Strateji: Farkl\u0131 f\u0131r\u00e7a tipleri, boyutlar\u0131, sertlikleri i\u00e7in \u00f6nceden tan\u0131mlanm\u0131\u015f ayarlar sunma. Hasta verilerine (tarama, ya\u015f, cinsiyet) dayanarak belirli b\u00f6lgeler i\u00e7in yapay zeka tabanl\u0131 bas\u0131n\u00e7 ayarlama \u00f6nerileri sunma. Teknoloji: Makine \u00f6\u011frenimi modelleri (\u00f6rn: scikit-learn , TensorFlow / PyTorch ) \"Model Katman\u0131\"nda, UI'da \u00f6nerileri g\u00f6r\u00fcnt\u00fclemek i\u00e7in yeni aray\u00fcz elemanlar\u0131. \u00d6zel Filtreler \u0130\u00e7in Eklenti Mekanizmas\u0131: Strateji: Geli\u015ftiricilerin, yaz\u0131l\u0131ma kolayca yeni 3D i\u015fleme filtreleri eklemesine olanak tan\u0131yan bir eklenti (plugin) mimarisi olu\u015fturma. Teknoloji: Belirli bir aray\u00fcze (interface) uyan Python s\u0131n\u0131flar\u0131n\u0131 dinamik olarak y\u00fckleyebilen bir mod\u00fcl y\u00fckleyici. Web Assembly (Uzun Vadeli Ta\u015f\u0131nabilirlik): Strateji: Yaz\u0131l\u0131m\u0131n bir web taray\u0131c\u0131s\u0131 \u00fczerinden \u00e7al\u0131\u015fabilmesi i\u00e7in (uzun vadeli hedef) Web Assembly (Wasm) teknolojilerini ara\u015ft\u0131rma. Teknoloji: Pyodide, Emscripten gibi ara\u00e7lar ve VTK.js gibi web tabanl\u0131 VTK portlar\u0131. Ger\u00e7ek Zamanl\u0131 Biyomekanik Sezgisel Katmanlar: Strateji: Modelleme s\u0131ras\u0131nda, protezin potansiyel biyomekanik etkilerini (\u00f6rn: kal\u00e7a abduksiyon a\u00e7\u0131s\u0131, diz eklemi ekseni) ger\u00e7ek zamanl\u0131 olarak g\u00f6steren g\u00f6rsel katmanlar (overlays) sunma. Teknoloji: vtkActor , vtkLineSource , vtkTextActor gibi VTK elemanlar\u0131 ve dinamik hesaplamalar.","title":"25. Gelecek Geli\u015ftirmeler ve Geni\u015fletme Noktalar\u0131"},{"location":"#26-sozluk","text":"Terim Tan\u0131m Skaler Dizi Renklendirme veya deplasman i\u00e7in kullan\u0131lan, nokta ba\u015f\u0131na veri dizisi. Is\u0131 Haritas\u0131 PressureValues '\u0131n renkli g\u00f6rselle\u015ftirmesi. \u00c7arp\u0131tma (Warp) Skaler deplasmana dayal\u0131 geometri d\u00f6n\u00fc\u015f\u00fcm\u00fc. Bulucu (Locator) En yak\u0131n/belirli yar\u0131\u00e7ap i\u00e7indeki sorgular i\u00e7in uzamsal indeks. Vuru\u015f (Stroke) Tek bir s\u00fcrekli boyama etkile\u015fimi. Kal\u0131p (Mold) Fiziksel bir negatif olu\u015fturmak i\u00e7in kullan\u0131lan ayarlanm\u0131\u015f geometri.","title":"26. S\u00f6zl\u00fck"},{"location":"SRD/","text":"Yaz\u0131l\u0131m Gereksinimleri Belirtimi (SRD) Belge T\u00fcr\u00fc : Teknik Dok\u00fcmantasyon Proje : 3B Tarama Cihaz\u0131 Versiyon: 1.1 Tarih: 18.03.2025 Revizyon Ge\u00e7mi\u015fi Tarih A\u00e7\u0131klama Yazar Yorumlar 18.03.2025 V1.0 Ahmet Furkan KARAARSLAN Dok\u00fcman ba\u015flang\u0131\u00e7 2.04.2025 V1.1 Muammer Tiryaki K\u00fc\u00e7\u00fck g\u00fcncellemeler \u0130\u00e7indekiler 1. Giri\u015f 1.1 Ama\u00e7 1.2 Kapsam 1.3 Tan\u0131mlar ve K\u0131saltmalar 1.4 Referanslar 1.5 Genel Bak\u0131\u015f 2. Genel A\u00e7\u0131klama 2.1 \u00dcr\u00fcn Perspektifi 2.3 \u00dcr\u00fcn \u0130\u015flevleri 2.3 Kullan\u0131c\u0131 \u00d6zellikleri 2.4 Genel S\u0131n\u0131rlamalar 2.5 Varsay\u0131mlar ve Ba\u011f\u0131ml\u0131l\u0131klar\u0131 3. \u00d6zel Gereksinimler 3.1 D\u0131\u015f Arabirimi Gereksinimleri 3.2 Fonksiyonel Gereksinimleri 3.3 Kullan\u0131m Durumlar\u0131 3.4 S\u0131n\u0131flar / Nesneler 3.5 \u0130\u015flevsel Olmayan Gereksinimler 3.6 Ters Gereksinimleri 3.7 Tasar\u0131m K\u0131s\u0131tlamalar\u0131 3.8 Mant\u0131ksal Veritaban\u0131 Gereksinimleri 3.9 Di\u011fer Gereksinimler 4. Analiz Modelleri 4.1 Aktivite Diyagramlar\u0131 4.2 Sequence Diyagramlar\u0131 4.3 Veri Ak\u0131\u015f Diyagramlar\u0131 4.4 Durum Ge\u00e7i\u015fi Diyagramlar\u0131 5. De\u011fi\u015fiklik Y\u00f6netimi S\u00fcreci A. Ekler A.1 Ek 1 1. Giri\u015f 1.1 Ama\u00e7 Bu dok\u00fcman, 3D tarama cihaz\u0131 yaz\u0131l\u0131m\u0131n\u0131n i\u015flevsel ve i\u015flevsel olmayan gereksinimlerini tan\u0131mlamaktad\u0131r. Yaz\u0131l\u0131m\u0131n amac\u0131, lazer tabanl\u0131 yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k desenlerini yakalamak, stereo kamera kurulumu kullanarak noktu bulutunu \u00e7\u0131karmak, kamera konumunu belirlemek i\u00e7in marker tabanl\u0131 PnP algoritmas\u0131n\u0131 kullanmak ve g\u00f6r\u00fcnt\u00fcleri i\u015fleyerek hassas 3D modellerin \u00e7\u0131kt\u0131 olarak olu\u015fturulmas\u0131n\u0131 sa\u011flamakt\u0131r. \u00dcretilecek olan yaz\u0131l\u0131m ve donan\u0131m Kickstarter (Fonlama ile sat\u0131\u015f) projesinde farkl\u0131 paketler (Stereo kamera, Structured Light, Stereo Kamera + Structured Light, Infrared Light, Infrared Light+ Stereo kamera veya hepsi i\u00e7in mono kamera) \u015feklinde piyasaya s\u00fcr\u00fclecektir. Proje i\u00e7erisinde elektronik tasar\u0131m ve yaz\u0131l\u0131m tasar\u0131m\u0131 olarak ikiye ayr\u0131lmaktad\u0131r. Tasarlanan yaz\u0131l\u0131m\u0131n SDK (Software Development Kit) \u015feklinde a\u00e7\u0131k kaynak olarak yay\u0131nlanarak geri d\u00f6n\u00fc\u015fler alarak yaz\u0131l\u0131m\u0131n geli\u015ftirilmesi hedeflenmektedir. Elektronik tasar\u0131m ise SDK ile b\u00fct\u00fcnle\u015fik \u00e7al\u0131\u015f\u0131p kapal\u0131 kaynak benimsenmesi sa\u011flanacakt\u0131r. 1.2 Kapsam Bu yaz\u0131l\u0131m a\u015fa\u011f\u0131daki i\u015flevleri sa\u011flayacakt\u0131r: Lazer tarama sistemi ve kamera ile y\u00fcksek \u00e7\u00f6z\u00fcn\u00fcrl\u00fckl\u00fc g\u00f6r\u00fcnt\u00fcler yakalama. \u0130ki kamera (stereo kamera) kullan\u0131larak derinlik bilgisi elde edilerek nokta bulutu elde etme. Kamera kalibrasyonun yap\u0131labilmesi. G\u00f6r\u00fcnt\u00fc i\u015fleme algoritmalar\u0131n\u0131 kullanarak 3D nokta bulutlar\u0131 olu\u015fturma. Kamera konumlar\u0131n\u0131n i\u015faret\u00e7i tabanl\u0131 PnP algoritmas\u0131 ile belirlenmesi. Tarama ve veri d\u0131\u015fa aktarma i\u015flemleri i\u00e7in etkile\u015fimli bir kullan\u0131c\u0131 aray\u00fcz\u00fc sa\u011flama. Birden fazla \u00e7\u0131kt\u0131 format\u0131n\u0131 destekleme (PCL, STL, OBJ, PLY). Tarama h\u0131z\u0131 ve do\u011frulu\u011funu optimize etme. Elde edilen nokta bulutlar\u0131 \u00fczerinde farkl\u0131 algoritmalar\u0131n\u0131n denenmesi ve denenilen algoritmalar\u0131n etkisinin kontrol edilmesi i\u00e7in test aray\u00fcz\u00fcn\u00fcn olu\u015fturulmas\u0131, algoritma nokta bulutuna uyguland\u0131ktan sonra algoritman\u0131n etkisinin g\u00f6zle kontrol edilmesi. Python SDK ile kullan\u0131c\u0131lar\u0131n hem ham g\u00f6r\u00fcnt\u00fc verilerini hem de \u00f6n i\u015flemden ge\u00e7mi\u015f en az\u0131ndan PCL olarak i\u015flenmi\u015f verileri alabilmesi hedeflenmektedir. Bu elektronik sistem a\u015fa\u011f\u0131daki i\u015flevleri sa\u011flayacakt\u0131r: Birbirinden ba\u011f\u0131ms\u0131z noktada kitler bulunmas\u0131 hedeflenmektedir. Kit ana bilgisayara ya da hesaplama birimine kablolu ya da kablosuz olarak ba\u011flanacakt\u0131r. \u00c7e\u015fitli mod\u00fcller e\u015f zamanl\u0131 piyasaya s\u00fcr\u00fclecektir: Kamera Kaynak Sens\u00f6r Haberle\u015fme FPGA ya da SOM Mod\u00fcl 1 mono RGB IR led pattern IMU kablolu var Mod\u00fcl 2 mono RGB MAV\u0130 pattern IMU kablosuz var Mod\u00fcl 3 stereo RGB IR pattern IMU kablolu yok Mod\u00fcl 4 stereo Monokrome K\u0131rm\u0131z\u0131 pattern IMU kablosuz yok Bu mod\u00fcl kombinasyonu daha sonra belirlenecektir. Mod\u00fcller \u00fczerinde bulunabilecek ISP ve dahili FPGA/SOM gibi yap\u0131lar ara\u015ft\u0131r\u0131lacakt\u0131r. Mod\u00fcller e\u011fer kablosuz tasarlanabiliyorsa batarya mod\u00fcl\u00fc de eklenecektir. 1.3 Tan\u0131mlar ve K\u0131saltmalar Lazer Tarama: Bir nesneye belirli lazer desenlerinin yans\u0131t\u0131lmas\u0131 ve kameradan al\u0131nan g\u00f6r\u00fcnt\u00fclerin analiz edilerek 3D model olu\u015fturulmas\u0131 tekni\u011fi. Stereo Kamera: Derinlik alg\u0131s\u0131 olu\u015fturmak i\u00e7in iki farkl\u0131 a\u00e7\u0131dan g\u00f6r\u00fcnt\u00fc yakalayan \u00e7ift kamera sistemi. PnP (Perspective-n-Point): Kameran\u0131n 3D uzaydaki konumunu belirlemek i\u00e7in marker tabanl\u0131 konumland\u0131rma y\u00f6ntemi. Nokta Bulutu: Tarama y\u00fczeyini temsil eden 3D veri noktalar\u0131ndan olu\u015fan yap\u0131. STL (Stereolithography): CAD ve 3D bask\u0131 i\u00e7in yayg\u0131n olarak kullan\u0131lan bir 3D dosya format\u0131. Structured Light: Yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k, \u00fc\u00e7 boyutlu bir nesnenin \u015feklini ve derinli\u011fini, nesnenin y\u00fczeyine bir \u0131\u015f\u0131k deseni yans\u0131tarak \u00f6l\u00e7en bir y\u00f6ntemdir. Desen \u015feritler, \u0131zgaralar veya noktalar olabilir. Mono kamera: Tekli kamera kurulumu. IMU: Kameralar\u0131n konum lokasyon takibi yapabilmesi ve birbirlerine g\u00f6re referanslanabilmesini sa\u011flayacakt\u0131r. FPGA ya da SOM: E\u011fer gerekirse mod\u00fcller \u00fczerinde dahili i\u015flem birimi ile PCL verilerinin aktar\u0131labilmesi sa\u011flanacakt\u0131r. 1.4 Referanslar OpenCV Dok\u00fcmantasyonu (G\u00f6r\u00fcnt\u00fc i\u015fleme i\u00e7in) Kamera Kalibrasyonu https://docs.opencv.org/4.x/dc/dbb/tutorial_py_calibration.html PCL (Point Cloud Library) Dok\u00fcmantasyonu Agile Yaz\u0131l\u0131m Geli\u015ftirme \u0130lkeleri Open3D Dok\u00fcmantasyonu Kickstarter Kullan\u0131lacak kamera e-con system'e ait monochroma ve RGB kameralard\u0131r. 1.5 Genel Bak\u0131\u015f Bu belge, 3B tarama cihaz\u0131 yaz\u0131l\u0131m\u0131n\u0131n i\u015flevsel ve i\u015flevsel olmayan t\u00fcm gereksinimlerini ayr\u0131nt\u0131l\u0131 bi\u00e7imde a\u00e7\u0131klar. Belge, yaz\u0131l\u0131m\u0131n amac\u0131n\u0131, kapsam\u0131n\u0131, teknik altyap\u0131s\u0131n\u0131, kullan\u0131c\u0131 aray\u00fczlerini, donan\u0131m ve yaz\u0131l\u0131m arabirimlerini, kullan\u0131m senaryolar\u0131n\u0131, s\u0131n\u0131f ve nesne yap\u0131s\u0131n\u0131, performans beklentilerini ve tasar\u0131m k\u0131s\u0131tlar\u0131n\u0131 i\u00e7ermektedir. Dok\u00fcman a\u015fa\u011f\u0131daki b\u00f6l\u00fcmlerden olu\u015fmaktad\u0131r: Giri\u015f: Projenin amac\u0131, kapsam\u0131, terminolojisi Genel A\u00e7\u0131klama: \u00dcr\u00fcn\u00fcn genel yap\u0131s\u0131 ve kullan\u0131m alanlar\u0131 \u00d6zel Gereksinimler: Fonksiyonel ve i\u015flevsel olmayan gereksinimler Analiz Modelleri: Diyagramlar ve i\u015f ak\u0131\u015flar\u0131 De\u011fi\u015fiklik Y\u00f6netimi: Gereksinimlerin nas\u0131l g\u00fcncellenece\u011fi 2. Genel A\u00e7\u0131klama 2.1 \u00dcr\u00fcn Perspektifi Yaz\u0131l\u0131m, harici donan\u0131mlarla (kameralar, lazer kayna\u011f\u0131) etkile\u015fime giren ba\u011f\u0131ms\u0131z bir uygulama ve donan\u0131m olarak tasarlanacakt\u0131r ve kullan\u0131c\u0131ya ger\u00e7ek zamanl\u0131 geri bildirim sa\u011flayacakt\u0131r. Yaz\u0131l\u0131m, \u00fc\u00e7 farkl\u0131 3D tarama y\u00f6ntemi i\u00e7in destek sa\u011flayacakt\u0131r: Stereo Kamera Y\u00f6ntemi: \u0130ki farkl\u0131 kameradan al\u0131nan g\u00f6r\u00fcnt\u00fcler aras\u0131ndaki paralaks fark\u0131 kullan\u0131larak derinlik bilgisi elde edilir. Lazer Tabanl\u0131 Yap\u0131land\u0131r\u0131lm\u0131\u015f I\u015f\u0131k Y\u00f6ntemi: Bir projeksiyon kayna\u011f\u0131 arac\u0131l\u0131\u011f\u0131yla nesne \u00fczerine belirli desenler yans\u0131t\u0131larak, kameradan bu desenlerin deformasyonu analiz edilir ve 3D model olu\u015fturulur. Stereo Kamera + Lazer Tabanl\u0131 Yap\u0131land\u0131r\u0131lm\u0131\u015f I\u015f\u0131k Y\u00f6ntemi: Stereo kamera ve lazer(hem g\u00f6r\u00fcn\u00fcr \u0131\u015f\u0131k hem IR \u0131\u015f\u0131k i\u00e7in) tabanl\u0131 yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k y\u00f6ntemlerinin birle\u015fimi ile daha y\u00fcksek do\u011fruluk elde edilir. Stereo kameralar derinlik haritas\u0131n\u0131 \u00e7\u0131kar\u0131rken, lazer ile detayl\u0131 y\u00fczey bilgisi sa\u011flan\u0131r. 2.3 \u00dcr\u00fcn \u0130\u015flevleri G\u00f6r\u00fcnt\u00fc Yakalama: Kameradan ham g\u00f6r\u00fcnt\u00fclerin al\u0131nmas\u0131. Lazer Tabanl\u0131 Yap\u0131land\u0131r\u0131lm\u0131\u015f I\u015f\u0131k \u0130\u015fleme: Algoritmalarla derinlik bilgisi \u00e7\u0131karma. 3D Modelle\u015ftirme: Derinlik verisini nokta bulutuna ve mesh yap\u0131s\u0131na d\u00f6n\u00fc\u015ft\u00fcrme. Kamera Konumu Belirleme: Marker tabanl\u0131 PnP algoritmas\u0131 kullanarak kameran\u0131n konumunun hesaplanmas\u0131. Yaz\u0131l\u0131m \u00fczerinden kullan\u0131c\u0131n\u0131n i\u015flevlere sahip olmas\u0131n\u0131 sa\u011flama. E\u011fer birden fazla kamera mod\u00fcl\u00fc bir sisteme tak\u0131l\u0131ysa bunlar aras\u0131nda kolerasyon kurulmas\u0131. Dosya D\u0131\u015fa Aktarma: Sonu\u00e7lar\u0131 end\u00fcstri standard\u0131 3D dosya formatlar\u0131nda kaydetme. Kullan\u0131c\u0131 Aray\u00fcz\u00fc: Tarama ba\u015flatma, durdurma ve dosya y\u00f6netimi gibi \u00f6zellikler sunma. 2.3 Kullan\u0131c\u0131 \u00d6zellikleri 2.4 Genel S\u0131n\u0131rlamalar Yaz\u0131l\u0131m sadece uyumlu kamera ve lazer donan\u0131m\u0131 ile \u00e7al\u0131\u015facakt\u0131r. Ger\u00e7ek zamanl\u0131 veri i\u015fleme i\u00e7in belirli bir sistem konfig\u00fcrasyonu (\u00f6rn. minimum i7 i\u015flemci, 32GB RAM ya da Nvidia CUDA) gereklidir. I\u015f\u0131k ko\u015fullar\u0131, tarama kalitesini etkileyebilir. Yetersiz ayd\u0131nlatma durumlar\u0131nda tarama do\u011frulu\u011fu azalabilir. Bu tarz tespitler ile sistem mod\u00fclleri aras\u0131na ek \u00fcr\u00fcnler geli\u015ftirilecektir. Ba\u015flang\u0131\u00e7ta yaln\u0131zca Ubuntu 22.04 i\u015fletim sistemi \u00fczerinde \u00e7al\u0131\u015facakt\u0131r. Ard\u0131ndan Python/C++ SDK ile di\u011fer sistemlerde de \u00e7al\u0131\u015fabilir hale getirilecektir. 2.5 Varsay\u0131mlar ve Ba\u011f\u0131ml\u0131l\u0131klar\u0131 Tarama i\u015flemi i\u00e7in uyumlu bir kamera ve lazer kayna\u011f\u0131 gereklidir. Kamera konumu, marker tabanl\u0131 PnP algoritmas\u0131 kullan\u0131larak tespit edilecektir. G\u00f6r\u00fcnt\u00fc ve 3D i\u015flemleme i\u00e7in OpenCV ve PCL gibi harici k\u00fct\u00fcphaneler kullan\u0131lacakt\u0131r. Birden fazla kamera kullan\u0131lan durumlarda kameralar\u0131n birbirlerine g\u00f6re konumu hassas olarak girilmesi beklenebilir. 3. \u00d6zel Gereksinimler 3.1 D\u0131\u015f Arabirimi Gereksinimleri 3.1.1 Kullan\u0131c\u0131 Aray\u00fczleri Ana ekran: Tarama ba\u015flatma, durdurma ve ayarlar\u0131 bar\u0131nd\u0131r\u0131r. \u00d6nizleme alan\u0131: Ger\u00e7ek zamanl\u0131 g\u00f6r\u00fcnt\u00fc ak\u0131\u015f\u0131 ve olu\u015fturulan 3D modelin \u00f6nizlemesi g\u00f6sterilir. Ayarlar paneli: Kalibrasyon verileri, \u00e7\u00f6z\u00fcn\u00fcrl\u00fck ve \u00e7\u0131kt\u0131 format\u0131 gibi ayarlar yap\u0131l\u0131r. \u00c7\u0131kt\u0131 ekran\u0131: Tarama sonucu 3D modelin kaydedilece\u011fi format ve konum se\u00e7ilir. 3.1.2 Donan\u0131m Arabirimleri 2 adet USB 3.0 ba\u011flant\u0131 noktas\u0131 (stereo kamera i\u00e7in) Lazer taray\u0131c\u0131 i\u00e7in harici g\u00fc\u00e7 ba\u011flant\u0131s\u0131(\u015eimdilik) Donan\u0131m tetikleyici (opsiyonel) ile senkron g\u00f6r\u00fcnt\u00fc alma deste\u011fi \u0130leriki modellerde geni\u015f bant \u00fczerinden veri aktar\u0131m\u0131n\u0131 sa\u011flayabilmek i\u00e7in ETH, Fiber kablo ya da Wi-Fi d\u00fc\u015f\u00fcn\u00fclmektedir. Mod\u00fcl \u00fczerinde dahili batarya 3.1.3 Yaz\u0131l\u0131m Arabirimleri OpenCV: G\u00f6r\u00fcnt\u00fc i\u015fleme ve kamera kalibrasyonu i\u00e7in PCL: Nokta bulutu olu\u015fturma ve i\u015fleme i\u00e7in, 3D g\u00f6rselle\u015ftirme ve \u00e7\u0131kt\u0131 alma i\u015flemleri i\u00e7in USB kamera SDK\u2019s\u0131 (e-con Systems) 3.1.4 \u0130leti\u015fim Arabirimleri USB 3.0 \u00fczerinden kamera veri ak\u0131\u015f\u0131 3.2 Fonksiyonel Gereksinimleri ID Gereksinim A\u00e7\u0131klamas\u0131 FG-1 Sistem ba\u011fl\u0131 kameradan g\u00f6r\u00fcnt\u00fc yakalayabilmelidir. FG-2 Yaz\u0131l\u0131m lazer tabanl\u0131 yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k desenlerini alg\u0131lay\u0131p analiz edebilmelidir. FG-3 Sistem yakalanan g\u00f6r\u00fcnt\u00fclerden 3D nokta bulutu olu\u015fturabilmelidir. FG-4 Kullan\u0131c\u0131 tarama \u00e7\u00f6z\u00fcn\u00fcrl\u00fc\u011f\u00fcn\u00fc ve parametreleri ayarlayabilmelidir. FG-5 Sistem 3D modelleri STL, OBJ ve PLY formatlar\u0131nda d\u0131\u015fa aktarabilmelidir. FG-6 Kullan\u0131c\u0131 aray\u00fcz\u00fc, tarama ba\u015flatma, durdurma ve kaydetme i\u015flemlerine izin vermelidir. FG-7 Kamera konumu, i\u015faret tabanl\u0131 PnP algoritmas\u0131 ile tespit edilmelidir. FG-8 Nokta bulutlar\u0131 \u00fczerinde denenilecek olan algoritmalar i\u00e7in \u00f6ncesi ve sonras\u0131 \u015feklinde g\u00f6r\u00fcnt\u00fcler vermelidir. FG-9 G\u00f6r\u00fcnt\u00fc hem dinamik olarak hem de kullan\u0131c\u0131n\u0131n iste\u011fine g\u00f6re \u201cspace\u201d tu\u015funa bast\u0131k\u00e7a kameradan g\u00f6r\u00fcnt\u00fc alacak \u015fekilde iki se\u00e7enekli olmal\u0131d\u0131r. FG-10 \u0130\u015faret\u00e7i takibi kaybedildi\u011fi zaman kullan\u0131c\u0131y\u0131 bilgilendirmek i\u00e7in ekranda uyar\u0131 vermeli ve kamera konumu belirlenene kadar tarama durdurulmal\u0131d\u0131r. 3.2.1 Fonksiyonel Gereksinim #1: G\u00f6r\u00fcnt\u00fc Yakalama ve Tarama Giri\u015f: Stereo kamera g\u00f6r\u00fcnt\u00fcleri Giri\u015fler: Kalibrasyon verileri (K1, D1, K2, D2) \u0130\u015fleme: Stereo e\u015fleme algoritmas\u0131 ile derinlik haritas\u0131 \u00fcretimi \u00c7\u0131k\u0131\u015flar: 3D nokta bulutu Hata i\u015fleme: Kalibrasyon eksikse uyar\u0131 verilir, d\u00fc\u015f\u00fck e\u015fle\u015fme kalitesi tespit edilirse kullan\u0131c\u0131ya bildirim yap\u0131l\u0131r. 3.2.2 Fonksiyonel Gereksinim #2: 3D Modelin Olu\u015fturulmas\u0131 ve D\u0131\u015fa Aktar\u0131m\u0131 Giri\u015f: Nokta bulutu, kullan\u0131c\u0131 taraf\u0131ndan se\u00e7ilen parametreler \u0130\u015fleme: Noktalar mesh'e d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr, gerekli dosya format\u0131 olu\u015fturulur \u00c7\u0131k\u0131\u015flar: STL, OBJ, PLY format\u0131nda dosyalar Hata \u0130\u015fleme: Yazma izni olmayan klas\u00f6r se\u00e7ilirse kullan\u0131c\u0131 uyar\u0131l\u0131r, bo\u015f tarama verisi varsa i\u015flem durdurulur. 3.3 Kullan\u0131m Durumlar\u0131 3.3.1 Kullan\u0131m Durumu #1: Nesne Tabanl\u0131 3D Tarama Ama\u00e7: Ger\u00e7ek d\u00fcnya ortam\u0131ndaki bir nesnenin y\u00fczey geometrisinin y\u00fcksek hassasiyetle taranarak bilgisayar ortam\u0131nda 3B model olarak elde edilmesi. Akt\u00f6rler: Kullan\u0131c\u0131 (operat\u00f6r) \u00d6n Ko\u015fullar: Kamera ve lazer sistemi d\u00fczg\u00fcn \u00e7al\u0131\u015f\u0131yor olmal\u0131 Kalibrasyon tamamlanm\u0131\u015f olmal\u0131 Marker\u2019lar sistemin g\u00f6rebilece\u011fi \u015fekilde d\u00fczg\u00fcn konumland\u0131r\u0131lm\u0131\u015f olmal\u0131 Marker tan\u0131mlar\u0131 yaz\u0131l\u0131ma \u00f6nceden tan\u0131t\u0131lm\u0131\u015f olmal\u0131 Senaryo: Kullan\u0131c\u0131 sistemi ba\u015flat\u0131r. Marker\u2019lar kameralar taraf\u0131ndan alg\u0131lan\u0131r ve PnP algoritmas\u0131 ile pozisyon tespiti yap\u0131l\u0131r. Kamera ve lazer otomatik olarak senkronize \u00e7al\u0131\u015fmaya ba\u015flar. Kullan\u0131c\u0131 nesneyi sabit konumda yerle\u015ftirir. Sistem g\u00f6r\u00fcnt\u00fcleri yakalar, i\u015fleyip nokta bulutu olu\u015fturur. Nokta bulutu 3B modele d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr. Kullan\u0131c\u0131 \u00e7\u0131kt\u0131y\u0131 .STL veya .PLY format\u0131nda kaydeder. Sonu\u00e7: Tarama ba\u015far\u0131yla tamamlan\u0131r ve 3D model elde edilir. 3.3.2 Kullan\u0131m Durumu #2: Medikal Tarama \u2013 Uzuv Modelleme Ama\u00e7: Medikal sekt\u00f6r\u00fcnde kullan\u0131lmak \u00fczere insan uzuvlar\u0131n\u0131n hassas \u015fekilde taranarak dijital ortama aktar\u0131lmas\u0131. Akt\u00f6rler: Kullan\u0131c\u0131 (teknisyen), hasta \u00d6n Ko\u015fullar: Ki\u015fi hareketsiz pozisyonda durmal\u0131 Kalibrasyon dosyalar\u0131 \u00f6nceden haz\u0131rlanm\u0131\u015f olmal\u0131 Marker\u2019lar sistem g\u00f6r\u00fc\u015f alan\u0131nda net \u015fekilde sabitlenmi\u015f olmal\u0131 Ortam \u0131\u015f\u0131\u011f\u0131 yetersiz de\u011filse ek ayd\u0131nlatma sa\u011flanmal\u0131 Senaryo: Kullan\u0131c\u0131 hastay\u0131 tarama alan\u0131na yerle\u015ftirir. Marker'lar alg\u0131lan\u0131r, sistem pozisyonunu do\u011frular. Tarama \u00e7\u00f6z\u00fcn\u00fcrl\u00fc\u011f\u00fc \u201cy\u00fcksek\u201d olarak se\u00e7ilir. Sistem birka\u00e7 saniyelik g\u00f6r\u00fcnt\u00fc al\u0131m\u0131 yapar. Elde edilen nokta bulutu y\u00fczey yumu\u015fatma ile optimize edilir. Model, ortopedik kal\u0131p \u00fcretimi i\u00e7in d\u0131\u015fa aktar\u0131l\u0131r. Sonu\u00e7: Hasta uzvunun dijital modeli al\u0131nm\u0131\u015f ve \u00fcretime haz\u0131r h\u00e2le getirilmi\u015ftir. 3.3.3 Kullan\u0131m Durumu #3: Algoritma Kar\u015f\u0131la\u015ft\u0131rma Modu (Test Aray\u00fcz\u00fc) Ama\u00e7: Yeni nokta bulutu filtreleme veya y\u00fczey iyile\u015ftirme algoritmalar\u0131n\u0131 test etmek ve etkilerini g\u00f6rsel olarak kar\u015f\u0131la\u015ft\u0131rmak. Akt\u00f6rler: Geli\u015ftirici veya ara\u015ft\u0131rmac\u0131 kullan\u0131c\u0131 \u00d6n Ko\u015fullar: Marker\u2019lar yaz\u0131l\u0131mda tan\u0131t\u0131lm\u0131\u015f olmal\u0131 (e\u011fer canl\u0131 tarama yap\u0131lacaksa) Mevcut veya \u00f6nceden taranm\u0131\u015f nokta bulutu verisi sisteme y\u00fcklenebilir olmal\u0131 Senaryo: Kullan\u0131c\u0131 mevcut bir nokta bulutunu yaz\u0131l\u0131ma y\u00fckler. Farkl\u0131 filtreleme algoritmalar\u0131 listeden se\u00e7ilir. Yaz\u0131l\u0131m ayn\u0131 veri \u00fczerinde \u00f6nce/sonra kar\u015f\u0131la\u015ft\u0131rmas\u0131 yapar. Kullan\u0131c\u0131 g\u00f6rsel \u00e7\u0131kt\u0131lar \u00fczerinden karar verir. Sonu\u00e7: Algoritmalar\u0131n performans\u0131 test edilmi\u015f olur, ileri geli\u015ftirmeler yap\u0131labilir. 3.4 S\u0131n\u0131flar / Nesneler 3.4.1 S\u0131n\u0131f / Nesne #1: KameraMod\u00fcl\u00fc \u00d6znitelikler: ID, \u00e7\u00f6z\u00fcn\u00fcrl\u00fck, fps, kalibrasyon parametreleri \u0130\u015flevler: G\u00f6r\u00fcnt\u00fcAl(), KalibrasyonY\u00fckle(), VideoAk\u0131\u015f\u0131Ba\u015flat() Referans: FG-1, FG-7 3.4.2 S\u0131n\u0131f / Nesne #2: Nokta Bulutu \u0130\u015fleyici \u00d6znitelikler: Nokta listesi, filtreleme parametreleri \u0130\u015flevler: Olu\u015ftur(), Filtrele(), Kaydet() Referans: FG-3, FG-5, FG-8 3.5 \u0130\u015flevsel Olmayan Gereksinimler 3.5.1 Performans Kamera ve yap\u0131sal \u0131\u015f\u0131ktan elde edilecek nokta bulutlar\u0131 sistem \u00fczerinden donma olmadan ak\u0131c\u0131 bir \u015fekilde minimum 15 fps\u2019te g\u00f6r\u00fcnt\u00fcleyebilmelidir. 3.5.2 G\u00fcvenilirlik Elde edilen nokta bulutlar\u0131n\u0131n kusursuza yak\u0131n olmas\u0131 ve taramada elde edilen obje ile ger\u00e7ek d\u00fcnyadaki objenin ayn\u0131 boyutta olmas\u0131 hedeflenmektedir. 3.5.3 Kullan\u0131labilirlik Kullan\u0131c\u0131 aray\u00fcz\u00fc sade ve sezgisel olacak \u015fekilde tasarlanmal\u0131d\u0131r. Kullan\u0131c\u0131lar, temel e\u011fitimle t\u00fcm tarama i\u015flemlerini ger\u00e7ekle\u015ftirebilecektir. 3.5.4 G\u00fcvenlik Yaz\u0131l\u0131m, kullan\u0131c\u0131 eri\u015fim kontrol\u00fc sa\u011flamasa da yaln\u0131zca yerel sistemde \u00e7al\u0131\u015f\u0131r. Hassas veriler \u015fifreli bi\u00e7imde saklanmaz. 3.5.5 S\u00fcrd\u00fcr\u00fclebilirlik Yaz\u0131l\u0131m a\u00e7\u0131k kaynak kodlu olarak geli\u015ftirilecek, topluluk katk\u0131lar\u0131 ile g\u00fcncellemeler s\u00fcrd\u00fcr\u00fclebilecektir. 3.5.6 Ta\u015f\u0131nabilirlik Kodlar platformdan ba\u011f\u0131ms\u0131z olarak C++ ve Python ile yaz\u0131lacak, ancak ba\u015flang\u0131\u00e7ta yaln\u0131zca Ubuntu 22.04 i\u015fletim sisteminde \u00e7al\u0131\u015facakt\u0131r. 3.6 Ters Gereksinimleri Yaz\u0131l\u0131m \u00e7evrimd\u0131\u015f\u0131 \u00e7al\u0131\u015facak, bulut ba\u011flant\u0131s\u0131 olmadan t\u00fcm i\u015flevlerini ger\u00e7ekle\u015ftirecektir. 3.7 Tasar\u0131m K\u0131s\u0131tlamalar\u0131 Bu yaz\u0131l\u0131m projesini etkileyen baz\u0131 tasar\u0131m k\u0131s\u0131tlamalar\u0131 a\u015fa\u011f\u0131da belirtilmi\u015ftir: Donan\u0131m Kaynak S\u0131n\u0131rlamalar\u0131: Cihaz\u0131n \u00e7al\u0131\u015fabilmesi i\u00e7in minimum donan\u0131m gereksinimleri vard\u0131r. \u00d6zellikle y\u00fcksek \u00e7\u00f6z\u00fcn\u00fcrl\u00fckl\u00fc stereo g\u00f6r\u00fcnt\u00fclerin i\u015flenmesi ve 3D nokta bulutu olu\u015fturma s\u00fcre\u00e7leri y\u00fcksek i\u015flem g\u00fcc\u00fc ve bellek gerektirdi\u011finden, sistemin en az Intel i7 i\u015flemci, 32GB RAM ve SSD depolama alan\u0131na sahip olmas\u0131 beklenmektedir. Ger\u00e7ek Zamanl\u0131 \u0130\u015fleme K\u0131s\u0131tlamas\u0131: Kameralardan gelen veri ak\u0131\u015f\u0131n\u0131n e\u015f zamanl\u0131 olarak i\u015flenebilmesi i\u00e7in i\u015flem gecikmelerinin minimumda tutulmas\u0131 gerekmektedir. Bu durum yaz\u0131l\u0131m\u0131n mod\u00fcler ve h\u0131zl\u0131 \u00e7al\u0131\u015fan algoritmalarla geli\u015ftirilmesini zorunlu k\u0131lar. Kamera Uyumlulu\u011fu: Yaz\u0131l\u0131m yaln\u0131zca belirli USB 3.0 stereo kameralarla (\u00f6r. e-con Systems IMX900) uyumlu olacak \u015fekilde geli\u015ftirilecektir. Di\u011fer marka/model kameralarla uyumluluk garanti edilmemektedir. \u0130\u015fletim Sistemi Uyumlulu\u011fu: Yaz\u0131l\u0131m sadece Ubuntu 22.04 LTS i\u015fletim sistemi \u00fczerinde test edilip \u00e7al\u0131\u015ft\u0131r\u0131lacakt\u0131r. Di\u011fer i\u015fletim sistemleri i\u00e7in destek sa\u011flanmamaktad\u0131r. \u00c7evrimd\u0131\u015f\u0131 \u00c7al\u0131\u015fma: Uygulama tamamen \u00e7evrimd\u0131\u015f\u0131 \u00e7al\u0131\u015facak \u015fekilde tasarland\u0131\u011f\u0131ndan, bulut tabanl\u0131 depolama veya i\u015flem hizmetleri kullan\u0131lmayacakt\u0131r. 3.8 Mant\u0131ksal Veritaban\u0131 Gereksinimleri Bu sistemde merkezi bir veritaban\u0131 kullan\u0131lmayacakt\u0131r. Ancak yap\u0131lan tarama i\u015flemlerine ait metadata\u2019lar JSON format\u0131nda klas\u00f6rlerde saklanacakt\u0131r. Dosya yap\u0131s\u0131 hiyerar\u015fik olacakt\u0131r. 3.9 Di\u011fer Gereksinimler Yaz\u0131l\u0131m a\u00e7\u0131k kaynak lisans (MIT veya GPL) ile yay\u0131nlanacakt\u0131r. T\u00fcm \u00e7\u0131kt\u0131lar kullan\u0131c\u0131 dizinine otomatik olarak kaydedilecek, i\u015flem sonunda otomatik olarak klas\u00f6r a\u00e7\u0131lacakt\u0131r. Uygulama terminal \u00e7\u0131kt\u0131lar\u0131 ile hata mesajlar\u0131 ve debug bilgilerini kullan\u0131c\u0131ya g\u00f6sterecektir. 4. Analiz Modelleri 4.1 Aktivite Diyagramlar\u0131 Kamera Pozisyonun Bulunmas\u0131 flowchart TD A[\"Kamera Kalibrasyonu - \u0130\u00e7 parametreler: K, D\"] --> B[\"Kamera G\u00f6r\u00fcnt\u00fcs\u00fc - Ger\u00e7ek zamanl\u0131 video\"] B --> C[\"G\u00f6r\u00fcnt\u00fc \u00d6n \u0130\u015fleme - Griye \u00e7evirme, Gauss bulan\u0131kla\u015ft\u0131rma, E\u015fikleme / Canny\"] C --> D[\"Daire Alg\u0131lama - HoughCircles veya Blob\"] D --> E[\"Dairelerin Merkezi ve Yar\u0131\u00e7ap Bilgisi\"] E --> F[\"Marker ID Atama - Opsiyonel, Konum, boyut, desen ile\"] F --> G[\"PnP ile Pozisyon Tahmini - 3D - 2D e\u015fleme, solvePnP\"] G --> H[\"Kamera Pozisyonu - R, t ve Takip G\u00fcncellemesi\"] Genel Yaz\u0131l\u0131m Mimarisi \u2026 4.2 Sequence Diyagramlar\u0131 sequenceDiagram participant Kullan\u0131c\u0131 participant UI participant Kamera participant G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici participant PnP Algoritmas\u0131 Kullan\u0131c\u0131 ->> UI: Tarama Ba\u015flat UI ->> Kamera: Kamera Ba\u015flat Kamera ->> G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici: G\u00f6r\u00fcnt\u00fc G\u00f6nder G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici ->> PnP Algoritmas\u0131: \u0130\u015flem Yap PnP Algoritmas\u0131 ->> G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici: Pozisyon Hesapla G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici ->> UI: Veriyi UI'ye G\u00f6nder UI ->> Kullan\u0131c\u0131: Model G\u00f6ster 4.3 Veri Ak\u0131\u015f Diyagramlar\u0131 graph TD A[Kamera-Ham G\u00f6r\u00fcnt\u00fc] --> B[Kalibrasyon - Kalibrasyon Verisi] B --> C[G\u00f6r\u00fcnt\u00fc \u0130\u015fleme - \u0130\u015flenmi\u015f G\u00f6r\u00fcnt] C --> D[Derinlik Hesaplama - Derinlik Verisi] C --> E[Nokta Bulutu] D --> F[Nokta Bulutu] E --> F[3D Model Olu\u015fturucu] 4.4 Durum Ge\u00e7i\u015fi Diyagramlar\u0131 stateDiagram-v2 [*] --> Ba\u015flang\u0131\u00e7 Ba\u015flang\u0131\u00e7 --> Kalibrasyon_Y\u00fckleniyor Kalibrasyon_Y\u00fckleniyor --> Haz\u0131r Haz\u0131r --> Tarama_Yap\u0131l\u0131yor Tarama_Yap\u0131l\u0131yor --> \u0130\u015fleniyor \u0130\u015fleniyor --> Kaydedildi \u0130\u015fleniyor --> Hata_Durumu Hata_Durumu --> Tarama_Yap\u0131l\u0131yor 5. De\u011fi\u015fiklik Y\u00f6netimi S\u00fcreci Bu yaz\u0131l\u0131m gereksinimleri dok\u00fcman\u0131nda yap\u0131lacak her t\u00fcrl\u00fc de\u011fi\u015fiklik, kontroll\u00fc ve izlenebilir bir s\u00fcre\u00e7 \u00e7er\u00e7evesinde y\u00fcr\u00fct\u00fclecektir. A\u015fa\u011f\u0131da bu s\u00fcrecin detaylar\u0131 yer almaktad\u0131r: 5.1 De\u011fi\u015fiklik Talebi Herhangi bir ekip \u00fcyesi, m\u00fc\u015fteri ya da payda\u015f sistem gereksinimlerinde de\u011fi\u015fiklik \u00f6nerisinde bulunabilir. De\u011fi\u015fiklik talepleri yaz\u0131l\u0131 olarak ve gerek\u00e7esiyle birlikte De\u011fi\u015fiklik Talep Formu (veya GitHub Issues \u00fczerinden) ile sunulmal\u0131d\u0131r. 5.2 De\u011ferlendirme ve Etki Analizi De\u011fi\u015fiklik talepleri, proje y\u00f6neticisi ve teknik ekip taraf\u0131ndan de\u011ferlendirilir. Her de\u011fi\u015fikli\u011fin teknik fizibilitesi, zaman/maliyet etkisi ve mevcut sistem \u00fczerindeki etkisi analiz edilir. Gerekirse, m\u00fc\u015fteriyle tekrar ileti\u015fime ge\u00e7ilerek kapsam netle\u015ftirilir. 5.3 Onay ve Uygulama Uygun bulunan de\u011fi\u015fiklikler, proje y\u00f6neticisi taraf\u0131ndan onaylanarak resmi revizyonlara dahil edilir. \u0130lgili yaz\u0131l\u0131m bile\u015fenleri, test planlar\u0131 ve dok\u00fcmantasyon bu de\u011fi\u015fikli\u011fe g\u00f6re g\u00fcncellenir. 5.4 Versiyonlama ve Kay\u0131t Her de\u011fi\u015fiklik dok\u00fcmana revizyon numaras\u0131, tarih, yazar ve a\u00e7\u0131klama ile birlikte kaydedilir. De\u011fi\u015fiklik ge\u00e7mi\u015fi \u201cRevizyon Ge\u00e7mi\u015fi\u201d b\u00f6l\u00fcm\u00fcnde tutulur. Git \u00fczerinden s\u00fcr\u00fcm kontrol\u00fc sa\u011flan\u0131r (\u00f6rn. v1.1, v1.2-beta gibi). 5.5 \u0130leti\u015fim ve Payla\u015f\u0131m Onaylanan de\u011fi\u015fiklikler ilgili t\u00fcm ekip \u00fcyeleriyle payla\u015f\u0131l\u0131r. Yeni versiyonlar yaz\u0131l\u0131m deposunda ve proje belgelerinde a\u00e7\u0131k\u00e7a belirtilir. A. Ekler Ekler, ilave ve yararl\u0131 bilgi sa\u011flamak i\u00e7in kullan\u0131labilir. Varsa, belirtim a\u00e7\u0131k\u00e7a ekinde yer alan bilgilerin belirtimde ifade edilen gereksinimlerin bir par\u00e7as\u0131 olarak dikkate al\u0131nmas\u0131 gerekiyor belirtilmelidir. \u00d6rnek Ekler (ilk) yaz\u0131l\u0131m projesi i\u00e7in kavramsal belgeler, pazarlama materyalleri, m\u00fc\u015fteri ler ile toplant\u0131lar\u0131n i\u00e7eri\u011fini vs.i\u00e7erebilir. A.1 Ek 1 Etkile\u015fimli Diyagramlar GitHub Pages'de Mermaid diyagramlar\u0131 kullanabilirsiniz. \u00d6rnek: graph TD A[Kamera Mod\u00fcl\u00fc] -->|G\u00f6r\u00fcnt\u00fc Yakala| B[G\u00f6r\u00fcnt\u00fc \u0130\u015fleme] B --> C[Nokta Bulutu Olu\u015fturma] C --> D[Mesh Olu\u015fturma] D --> E[3D Model D\u0131\u015fa Aktarma] B --> F[Marker Tespiti] F --> G[PnP ile Kamera Pozisyonu] Proje \u0130lerleme Takibi Gereksinimlerin Belirlenmesi : Tamamland\u0131 (2 Nisan 2025) Mimari Tasar\u0131m : Devam Ediyor Prototip Geli\u015ftirme : Planlanan (15 May\u0131s 2025) Kod De\u011fi\u015fikli\u011fi G\u00fcncellemeleri 2025-04-02 11:55 Tarihli Kod De\u011fi\u015fiklikleri Commit: 43ffc96 - Add System Requirements Document (SRD) and update project progress tracking De\u011fi\u015ftirilen Dosyalar","title":"Yaz\u0131l\u0131m Gereksinimleri Belirtimi (SRD)"},{"location":"SRD/#yazlm-gereksinimleri-belirtimi-srd","text":"Belge T\u00fcr\u00fc : Teknik Dok\u00fcmantasyon Proje : 3B Tarama Cihaz\u0131 Versiyon: 1.1 Tarih: 18.03.2025","title":"Yaz\u0131l\u0131m Gereksinimleri Belirtimi (SRD)"},{"location":"SRD/#revizyon-gecmisi","text":"Tarih A\u00e7\u0131klama Yazar Yorumlar 18.03.2025 V1.0 Ahmet Furkan KARAARSLAN Dok\u00fcman ba\u015flang\u0131\u00e7 2.04.2025 V1.1 Muammer Tiryaki K\u00fc\u00e7\u00fck g\u00fcncellemeler","title":"Revizyon Ge\u00e7mi\u015fi"},{"location":"SRD/#icindekiler","text":"1. Giri\u015f 1.1 Ama\u00e7 1.2 Kapsam 1.3 Tan\u0131mlar ve K\u0131saltmalar 1.4 Referanslar 1.5 Genel Bak\u0131\u015f 2. Genel A\u00e7\u0131klama 2.1 \u00dcr\u00fcn Perspektifi 2.3 \u00dcr\u00fcn \u0130\u015flevleri 2.3 Kullan\u0131c\u0131 \u00d6zellikleri 2.4 Genel S\u0131n\u0131rlamalar 2.5 Varsay\u0131mlar ve Ba\u011f\u0131ml\u0131l\u0131klar\u0131 3. \u00d6zel Gereksinimler 3.1 D\u0131\u015f Arabirimi Gereksinimleri 3.2 Fonksiyonel Gereksinimleri 3.3 Kullan\u0131m Durumlar\u0131 3.4 S\u0131n\u0131flar / Nesneler 3.5 \u0130\u015flevsel Olmayan Gereksinimler 3.6 Ters Gereksinimleri 3.7 Tasar\u0131m K\u0131s\u0131tlamalar\u0131 3.8 Mant\u0131ksal Veritaban\u0131 Gereksinimleri 3.9 Di\u011fer Gereksinimler 4. Analiz Modelleri 4.1 Aktivite Diyagramlar\u0131 4.2 Sequence Diyagramlar\u0131 4.3 Veri Ak\u0131\u015f Diyagramlar\u0131 4.4 Durum Ge\u00e7i\u015fi Diyagramlar\u0131 5. De\u011fi\u015fiklik Y\u00f6netimi S\u00fcreci A. Ekler A.1 Ek 1","title":"\u0130\u00e7indekiler"},{"location":"SRD/#1-giris","text":"","title":"1. Giri\u015f"},{"location":"SRD/#11-amac","text":"Bu dok\u00fcman, 3D tarama cihaz\u0131 yaz\u0131l\u0131m\u0131n\u0131n i\u015flevsel ve i\u015flevsel olmayan gereksinimlerini tan\u0131mlamaktad\u0131r. Yaz\u0131l\u0131m\u0131n amac\u0131, lazer tabanl\u0131 yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k desenlerini yakalamak, stereo kamera kurulumu kullanarak noktu bulutunu \u00e7\u0131karmak, kamera konumunu belirlemek i\u00e7in marker tabanl\u0131 PnP algoritmas\u0131n\u0131 kullanmak ve g\u00f6r\u00fcnt\u00fcleri i\u015fleyerek hassas 3D modellerin \u00e7\u0131kt\u0131 olarak olu\u015fturulmas\u0131n\u0131 sa\u011flamakt\u0131r. \u00dcretilecek olan yaz\u0131l\u0131m ve donan\u0131m Kickstarter (Fonlama ile sat\u0131\u015f) projesinde farkl\u0131 paketler (Stereo kamera, Structured Light, Stereo Kamera + Structured Light, Infrared Light, Infrared Light+ Stereo kamera veya hepsi i\u00e7in mono kamera) \u015feklinde piyasaya s\u00fcr\u00fclecektir. Proje i\u00e7erisinde elektronik tasar\u0131m ve yaz\u0131l\u0131m tasar\u0131m\u0131 olarak ikiye ayr\u0131lmaktad\u0131r. Tasarlanan yaz\u0131l\u0131m\u0131n SDK (Software Development Kit) \u015feklinde a\u00e7\u0131k kaynak olarak yay\u0131nlanarak geri d\u00f6n\u00fc\u015fler alarak yaz\u0131l\u0131m\u0131n geli\u015ftirilmesi hedeflenmektedir. Elektronik tasar\u0131m ise SDK ile b\u00fct\u00fcnle\u015fik \u00e7al\u0131\u015f\u0131p kapal\u0131 kaynak benimsenmesi sa\u011flanacakt\u0131r.","title":"1.1 Ama\u00e7"},{"location":"SRD/#12-kapsam","text":"Bu yaz\u0131l\u0131m a\u015fa\u011f\u0131daki i\u015flevleri sa\u011flayacakt\u0131r: Lazer tarama sistemi ve kamera ile y\u00fcksek \u00e7\u00f6z\u00fcn\u00fcrl\u00fckl\u00fc g\u00f6r\u00fcnt\u00fcler yakalama. \u0130ki kamera (stereo kamera) kullan\u0131larak derinlik bilgisi elde edilerek nokta bulutu elde etme. Kamera kalibrasyonun yap\u0131labilmesi. G\u00f6r\u00fcnt\u00fc i\u015fleme algoritmalar\u0131n\u0131 kullanarak 3D nokta bulutlar\u0131 olu\u015fturma. Kamera konumlar\u0131n\u0131n i\u015faret\u00e7i tabanl\u0131 PnP algoritmas\u0131 ile belirlenmesi. Tarama ve veri d\u0131\u015fa aktarma i\u015flemleri i\u00e7in etkile\u015fimli bir kullan\u0131c\u0131 aray\u00fcz\u00fc sa\u011flama. Birden fazla \u00e7\u0131kt\u0131 format\u0131n\u0131 destekleme (PCL, STL, OBJ, PLY). Tarama h\u0131z\u0131 ve do\u011frulu\u011funu optimize etme. Elde edilen nokta bulutlar\u0131 \u00fczerinde farkl\u0131 algoritmalar\u0131n\u0131n denenmesi ve denenilen algoritmalar\u0131n etkisinin kontrol edilmesi i\u00e7in test aray\u00fcz\u00fcn\u00fcn olu\u015fturulmas\u0131, algoritma nokta bulutuna uyguland\u0131ktan sonra algoritman\u0131n etkisinin g\u00f6zle kontrol edilmesi. Python SDK ile kullan\u0131c\u0131lar\u0131n hem ham g\u00f6r\u00fcnt\u00fc verilerini hem de \u00f6n i\u015flemden ge\u00e7mi\u015f en az\u0131ndan PCL olarak i\u015flenmi\u015f verileri alabilmesi hedeflenmektedir. Bu elektronik sistem a\u015fa\u011f\u0131daki i\u015flevleri sa\u011flayacakt\u0131r: Birbirinden ba\u011f\u0131ms\u0131z noktada kitler bulunmas\u0131 hedeflenmektedir. Kit ana bilgisayara ya da hesaplama birimine kablolu ya da kablosuz olarak ba\u011flanacakt\u0131r. \u00c7e\u015fitli mod\u00fcller e\u015f zamanl\u0131 piyasaya s\u00fcr\u00fclecektir: Kamera Kaynak Sens\u00f6r Haberle\u015fme FPGA ya da SOM Mod\u00fcl 1 mono RGB IR led pattern IMU kablolu var Mod\u00fcl 2 mono RGB MAV\u0130 pattern IMU kablosuz var Mod\u00fcl 3 stereo RGB IR pattern IMU kablolu yok Mod\u00fcl 4 stereo Monokrome K\u0131rm\u0131z\u0131 pattern IMU kablosuz yok Bu mod\u00fcl kombinasyonu daha sonra belirlenecektir. Mod\u00fcller \u00fczerinde bulunabilecek ISP ve dahili FPGA/SOM gibi yap\u0131lar ara\u015ft\u0131r\u0131lacakt\u0131r. Mod\u00fcller e\u011fer kablosuz tasarlanabiliyorsa batarya mod\u00fcl\u00fc de eklenecektir.","title":"1.2 Kapsam"},{"location":"SRD/#13-tanmlar-ve-ksaltmalar","text":"Lazer Tarama: Bir nesneye belirli lazer desenlerinin yans\u0131t\u0131lmas\u0131 ve kameradan al\u0131nan g\u00f6r\u00fcnt\u00fclerin analiz edilerek 3D model olu\u015fturulmas\u0131 tekni\u011fi. Stereo Kamera: Derinlik alg\u0131s\u0131 olu\u015fturmak i\u00e7in iki farkl\u0131 a\u00e7\u0131dan g\u00f6r\u00fcnt\u00fc yakalayan \u00e7ift kamera sistemi. PnP (Perspective-n-Point): Kameran\u0131n 3D uzaydaki konumunu belirlemek i\u00e7in marker tabanl\u0131 konumland\u0131rma y\u00f6ntemi. Nokta Bulutu: Tarama y\u00fczeyini temsil eden 3D veri noktalar\u0131ndan olu\u015fan yap\u0131. STL (Stereolithography): CAD ve 3D bask\u0131 i\u00e7in yayg\u0131n olarak kullan\u0131lan bir 3D dosya format\u0131. Structured Light: Yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k, \u00fc\u00e7 boyutlu bir nesnenin \u015feklini ve derinli\u011fini, nesnenin y\u00fczeyine bir \u0131\u015f\u0131k deseni yans\u0131tarak \u00f6l\u00e7en bir y\u00f6ntemdir. Desen \u015feritler, \u0131zgaralar veya noktalar olabilir. Mono kamera: Tekli kamera kurulumu. IMU: Kameralar\u0131n konum lokasyon takibi yapabilmesi ve birbirlerine g\u00f6re referanslanabilmesini sa\u011flayacakt\u0131r. FPGA ya da SOM: E\u011fer gerekirse mod\u00fcller \u00fczerinde dahili i\u015flem birimi ile PCL verilerinin aktar\u0131labilmesi sa\u011flanacakt\u0131r.","title":"1.3 Tan\u0131mlar ve K\u0131saltmalar"},{"location":"SRD/#14-referanslar","text":"OpenCV Dok\u00fcmantasyonu (G\u00f6r\u00fcnt\u00fc i\u015fleme i\u00e7in) Kamera Kalibrasyonu https://docs.opencv.org/4.x/dc/dbb/tutorial_py_calibration.html PCL (Point Cloud Library) Dok\u00fcmantasyonu Agile Yaz\u0131l\u0131m Geli\u015ftirme \u0130lkeleri Open3D Dok\u00fcmantasyonu Kickstarter Kullan\u0131lacak kamera e-con system'e ait monochroma ve RGB kameralard\u0131r.","title":"1.4 Referanslar"},{"location":"SRD/#15-genel-baks","text":"Bu belge, 3B tarama cihaz\u0131 yaz\u0131l\u0131m\u0131n\u0131n i\u015flevsel ve i\u015flevsel olmayan t\u00fcm gereksinimlerini ayr\u0131nt\u0131l\u0131 bi\u00e7imde a\u00e7\u0131klar. Belge, yaz\u0131l\u0131m\u0131n amac\u0131n\u0131, kapsam\u0131n\u0131, teknik altyap\u0131s\u0131n\u0131, kullan\u0131c\u0131 aray\u00fczlerini, donan\u0131m ve yaz\u0131l\u0131m arabirimlerini, kullan\u0131m senaryolar\u0131n\u0131, s\u0131n\u0131f ve nesne yap\u0131s\u0131n\u0131, performans beklentilerini ve tasar\u0131m k\u0131s\u0131tlar\u0131n\u0131 i\u00e7ermektedir. Dok\u00fcman a\u015fa\u011f\u0131daki b\u00f6l\u00fcmlerden olu\u015fmaktad\u0131r: Giri\u015f: Projenin amac\u0131, kapsam\u0131, terminolojisi Genel A\u00e7\u0131klama: \u00dcr\u00fcn\u00fcn genel yap\u0131s\u0131 ve kullan\u0131m alanlar\u0131 \u00d6zel Gereksinimler: Fonksiyonel ve i\u015flevsel olmayan gereksinimler Analiz Modelleri: Diyagramlar ve i\u015f ak\u0131\u015flar\u0131 De\u011fi\u015fiklik Y\u00f6netimi: Gereksinimlerin nas\u0131l g\u00fcncellenece\u011fi","title":"1.5 Genel Bak\u0131\u015f"},{"location":"SRD/#2-genel-acklama","text":"","title":"2. Genel A\u00e7\u0131klama"},{"location":"SRD/#21-urun-perspektifi","text":"Yaz\u0131l\u0131m, harici donan\u0131mlarla (kameralar, lazer kayna\u011f\u0131) etkile\u015fime giren ba\u011f\u0131ms\u0131z bir uygulama ve donan\u0131m olarak tasarlanacakt\u0131r ve kullan\u0131c\u0131ya ger\u00e7ek zamanl\u0131 geri bildirim sa\u011flayacakt\u0131r. Yaz\u0131l\u0131m, \u00fc\u00e7 farkl\u0131 3D tarama y\u00f6ntemi i\u00e7in destek sa\u011flayacakt\u0131r: Stereo Kamera Y\u00f6ntemi: \u0130ki farkl\u0131 kameradan al\u0131nan g\u00f6r\u00fcnt\u00fcler aras\u0131ndaki paralaks fark\u0131 kullan\u0131larak derinlik bilgisi elde edilir. Lazer Tabanl\u0131 Yap\u0131land\u0131r\u0131lm\u0131\u015f I\u015f\u0131k Y\u00f6ntemi: Bir projeksiyon kayna\u011f\u0131 arac\u0131l\u0131\u011f\u0131yla nesne \u00fczerine belirli desenler yans\u0131t\u0131larak, kameradan bu desenlerin deformasyonu analiz edilir ve 3D model olu\u015fturulur. Stereo Kamera + Lazer Tabanl\u0131 Yap\u0131land\u0131r\u0131lm\u0131\u015f I\u015f\u0131k Y\u00f6ntemi: Stereo kamera ve lazer(hem g\u00f6r\u00fcn\u00fcr \u0131\u015f\u0131k hem IR \u0131\u015f\u0131k i\u00e7in) tabanl\u0131 yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k y\u00f6ntemlerinin birle\u015fimi ile daha y\u00fcksek do\u011fruluk elde edilir. Stereo kameralar derinlik haritas\u0131n\u0131 \u00e7\u0131kar\u0131rken, lazer ile detayl\u0131 y\u00fczey bilgisi sa\u011flan\u0131r.","title":"2.1 \u00dcr\u00fcn Perspektifi"},{"location":"SRD/#23-urun-islevleri","text":"G\u00f6r\u00fcnt\u00fc Yakalama: Kameradan ham g\u00f6r\u00fcnt\u00fclerin al\u0131nmas\u0131. Lazer Tabanl\u0131 Yap\u0131land\u0131r\u0131lm\u0131\u015f I\u015f\u0131k \u0130\u015fleme: Algoritmalarla derinlik bilgisi \u00e7\u0131karma. 3D Modelle\u015ftirme: Derinlik verisini nokta bulutuna ve mesh yap\u0131s\u0131na d\u00f6n\u00fc\u015ft\u00fcrme. Kamera Konumu Belirleme: Marker tabanl\u0131 PnP algoritmas\u0131 kullanarak kameran\u0131n konumunun hesaplanmas\u0131. Yaz\u0131l\u0131m \u00fczerinden kullan\u0131c\u0131n\u0131n i\u015flevlere sahip olmas\u0131n\u0131 sa\u011flama. E\u011fer birden fazla kamera mod\u00fcl\u00fc bir sisteme tak\u0131l\u0131ysa bunlar aras\u0131nda kolerasyon kurulmas\u0131. Dosya D\u0131\u015fa Aktarma: Sonu\u00e7lar\u0131 end\u00fcstri standard\u0131 3D dosya formatlar\u0131nda kaydetme. Kullan\u0131c\u0131 Aray\u00fcz\u00fc: Tarama ba\u015flatma, durdurma ve dosya y\u00f6netimi gibi \u00f6zellikler sunma.","title":"2.3 \u00dcr\u00fcn \u0130\u015flevleri"},{"location":"SRD/#23-kullanc-ozellikleri","text":"","title":"2.3 Kullan\u0131c\u0131 \u00d6zellikleri"},{"location":"SRD/#24-genel-snrlamalar","text":"Yaz\u0131l\u0131m sadece uyumlu kamera ve lazer donan\u0131m\u0131 ile \u00e7al\u0131\u015facakt\u0131r. Ger\u00e7ek zamanl\u0131 veri i\u015fleme i\u00e7in belirli bir sistem konfig\u00fcrasyonu (\u00f6rn. minimum i7 i\u015flemci, 32GB RAM ya da Nvidia CUDA) gereklidir. I\u015f\u0131k ko\u015fullar\u0131, tarama kalitesini etkileyebilir. Yetersiz ayd\u0131nlatma durumlar\u0131nda tarama do\u011frulu\u011fu azalabilir. Bu tarz tespitler ile sistem mod\u00fclleri aras\u0131na ek \u00fcr\u00fcnler geli\u015ftirilecektir. Ba\u015flang\u0131\u00e7ta yaln\u0131zca Ubuntu 22.04 i\u015fletim sistemi \u00fczerinde \u00e7al\u0131\u015facakt\u0131r. Ard\u0131ndan Python/C++ SDK ile di\u011fer sistemlerde de \u00e7al\u0131\u015fabilir hale getirilecektir.","title":"2.4 Genel S\u0131n\u0131rlamalar"},{"location":"SRD/#25-varsaymlar-ve-bagmllklar","text":"Tarama i\u015flemi i\u00e7in uyumlu bir kamera ve lazer kayna\u011f\u0131 gereklidir. Kamera konumu, marker tabanl\u0131 PnP algoritmas\u0131 kullan\u0131larak tespit edilecektir. G\u00f6r\u00fcnt\u00fc ve 3D i\u015flemleme i\u00e7in OpenCV ve PCL gibi harici k\u00fct\u00fcphaneler kullan\u0131lacakt\u0131r. Birden fazla kamera kullan\u0131lan durumlarda kameralar\u0131n birbirlerine g\u00f6re konumu hassas olarak girilmesi beklenebilir.","title":"2.5 Varsay\u0131mlar ve Ba\u011f\u0131ml\u0131l\u0131klar\u0131"},{"location":"SRD/#3-ozel-gereksinimler","text":"","title":"3. \u00d6zel Gereksinimler"},{"location":"SRD/#31-ds-arabirimi-gereksinimleri","text":"","title":"3.1 D\u0131\u015f Arabirimi Gereksinimleri"},{"location":"SRD/#311-kullanc-arayuzleri","text":"Ana ekran: Tarama ba\u015flatma, durdurma ve ayarlar\u0131 bar\u0131nd\u0131r\u0131r. \u00d6nizleme alan\u0131: Ger\u00e7ek zamanl\u0131 g\u00f6r\u00fcnt\u00fc ak\u0131\u015f\u0131 ve olu\u015fturulan 3D modelin \u00f6nizlemesi g\u00f6sterilir. Ayarlar paneli: Kalibrasyon verileri, \u00e7\u00f6z\u00fcn\u00fcrl\u00fck ve \u00e7\u0131kt\u0131 format\u0131 gibi ayarlar yap\u0131l\u0131r. \u00c7\u0131kt\u0131 ekran\u0131: Tarama sonucu 3D modelin kaydedilece\u011fi format ve konum se\u00e7ilir.","title":"3.1.1 Kullan\u0131c\u0131 Aray\u00fczleri"},{"location":"SRD/#312-donanm-arabirimleri","text":"2 adet USB 3.0 ba\u011flant\u0131 noktas\u0131 (stereo kamera i\u00e7in) Lazer taray\u0131c\u0131 i\u00e7in harici g\u00fc\u00e7 ba\u011flant\u0131s\u0131(\u015eimdilik) Donan\u0131m tetikleyici (opsiyonel) ile senkron g\u00f6r\u00fcnt\u00fc alma deste\u011fi \u0130leriki modellerde geni\u015f bant \u00fczerinden veri aktar\u0131m\u0131n\u0131 sa\u011flayabilmek i\u00e7in ETH, Fiber kablo ya da Wi-Fi d\u00fc\u015f\u00fcn\u00fclmektedir. Mod\u00fcl \u00fczerinde dahili batarya","title":"3.1.2 Donan\u0131m Arabirimleri"},{"location":"SRD/#313-yazlm-arabirimleri","text":"OpenCV: G\u00f6r\u00fcnt\u00fc i\u015fleme ve kamera kalibrasyonu i\u00e7in PCL: Nokta bulutu olu\u015fturma ve i\u015fleme i\u00e7in, 3D g\u00f6rselle\u015ftirme ve \u00e7\u0131kt\u0131 alma i\u015flemleri i\u00e7in USB kamera SDK\u2019s\u0131 (e-con Systems)","title":"3.1.3 Yaz\u0131l\u0131m Arabirimleri"},{"location":"SRD/#314-iletisim-arabirimleri","text":"USB 3.0 \u00fczerinden kamera veri ak\u0131\u015f\u0131","title":"3.1.4 \u0130leti\u015fim Arabirimleri"},{"location":"SRD/#32-fonksiyonel-gereksinimleri","text":"ID Gereksinim A\u00e7\u0131klamas\u0131 FG-1 Sistem ba\u011fl\u0131 kameradan g\u00f6r\u00fcnt\u00fc yakalayabilmelidir. FG-2 Yaz\u0131l\u0131m lazer tabanl\u0131 yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k desenlerini alg\u0131lay\u0131p analiz edebilmelidir. FG-3 Sistem yakalanan g\u00f6r\u00fcnt\u00fclerden 3D nokta bulutu olu\u015fturabilmelidir. FG-4 Kullan\u0131c\u0131 tarama \u00e7\u00f6z\u00fcn\u00fcrl\u00fc\u011f\u00fcn\u00fc ve parametreleri ayarlayabilmelidir. FG-5 Sistem 3D modelleri STL, OBJ ve PLY formatlar\u0131nda d\u0131\u015fa aktarabilmelidir. FG-6 Kullan\u0131c\u0131 aray\u00fcz\u00fc, tarama ba\u015flatma, durdurma ve kaydetme i\u015flemlerine izin vermelidir. FG-7 Kamera konumu, i\u015faret tabanl\u0131 PnP algoritmas\u0131 ile tespit edilmelidir. FG-8 Nokta bulutlar\u0131 \u00fczerinde denenilecek olan algoritmalar i\u00e7in \u00f6ncesi ve sonras\u0131 \u015feklinde g\u00f6r\u00fcnt\u00fcler vermelidir. FG-9 G\u00f6r\u00fcnt\u00fc hem dinamik olarak hem de kullan\u0131c\u0131n\u0131n iste\u011fine g\u00f6re \u201cspace\u201d tu\u015funa bast\u0131k\u00e7a kameradan g\u00f6r\u00fcnt\u00fc alacak \u015fekilde iki se\u00e7enekli olmal\u0131d\u0131r. FG-10 \u0130\u015faret\u00e7i takibi kaybedildi\u011fi zaman kullan\u0131c\u0131y\u0131 bilgilendirmek i\u00e7in ekranda uyar\u0131 vermeli ve kamera konumu belirlenene kadar tarama durdurulmal\u0131d\u0131r.","title":"3.2 Fonksiyonel Gereksinimleri"},{"location":"SRD/#321-fonksiyonel-gereksinim-1-goruntu-yakalama-ve-tarama","text":"Giri\u015f: Stereo kamera g\u00f6r\u00fcnt\u00fcleri Giri\u015fler: Kalibrasyon verileri (K1, D1, K2, D2) \u0130\u015fleme: Stereo e\u015fleme algoritmas\u0131 ile derinlik haritas\u0131 \u00fcretimi \u00c7\u0131k\u0131\u015flar: 3D nokta bulutu Hata i\u015fleme: Kalibrasyon eksikse uyar\u0131 verilir, d\u00fc\u015f\u00fck e\u015fle\u015fme kalitesi tespit edilirse kullan\u0131c\u0131ya bildirim yap\u0131l\u0131r.","title":"3.2.1 Fonksiyonel Gereksinim #1: G\u00f6r\u00fcnt\u00fc Yakalama ve Tarama"},{"location":"SRD/#322-fonksiyonel-gereksinim-2-3d-modelin-olusturulmas-ve-dsa-aktarm","text":"Giri\u015f: Nokta bulutu, kullan\u0131c\u0131 taraf\u0131ndan se\u00e7ilen parametreler \u0130\u015fleme: Noktalar mesh'e d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr, gerekli dosya format\u0131 olu\u015fturulur \u00c7\u0131k\u0131\u015flar: STL, OBJ, PLY format\u0131nda dosyalar Hata \u0130\u015fleme: Yazma izni olmayan klas\u00f6r se\u00e7ilirse kullan\u0131c\u0131 uyar\u0131l\u0131r, bo\u015f tarama verisi varsa i\u015flem durdurulur.","title":"3.2.2 Fonksiyonel Gereksinim #2: 3D Modelin Olu\u015fturulmas\u0131 ve D\u0131\u015fa Aktar\u0131m\u0131"},{"location":"SRD/#33-kullanm-durumlar","text":"","title":"3.3 Kullan\u0131m Durumlar\u0131"},{"location":"SRD/#331-kullanm-durumu-1-nesne-tabanl-3d-tarama","text":"Ama\u00e7: Ger\u00e7ek d\u00fcnya ortam\u0131ndaki bir nesnenin y\u00fczey geometrisinin y\u00fcksek hassasiyetle taranarak bilgisayar ortam\u0131nda 3B model olarak elde edilmesi. Akt\u00f6rler: Kullan\u0131c\u0131 (operat\u00f6r) \u00d6n Ko\u015fullar: Kamera ve lazer sistemi d\u00fczg\u00fcn \u00e7al\u0131\u015f\u0131yor olmal\u0131 Kalibrasyon tamamlanm\u0131\u015f olmal\u0131 Marker\u2019lar sistemin g\u00f6rebilece\u011fi \u015fekilde d\u00fczg\u00fcn konumland\u0131r\u0131lm\u0131\u015f olmal\u0131 Marker tan\u0131mlar\u0131 yaz\u0131l\u0131ma \u00f6nceden tan\u0131t\u0131lm\u0131\u015f olmal\u0131 Senaryo: Kullan\u0131c\u0131 sistemi ba\u015flat\u0131r. Marker\u2019lar kameralar taraf\u0131ndan alg\u0131lan\u0131r ve PnP algoritmas\u0131 ile pozisyon tespiti yap\u0131l\u0131r. Kamera ve lazer otomatik olarak senkronize \u00e7al\u0131\u015fmaya ba\u015flar. Kullan\u0131c\u0131 nesneyi sabit konumda yerle\u015ftirir. Sistem g\u00f6r\u00fcnt\u00fcleri yakalar, i\u015fleyip nokta bulutu olu\u015fturur. Nokta bulutu 3B modele d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr. Kullan\u0131c\u0131 \u00e7\u0131kt\u0131y\u0131 .STL veya .PLY format\u0131nda kaydeder. Sonu\u00e7: Tarama ba\u015far\u0131yla tamamlan\u0131r ve 3D model elde edilir.","title":"3.3.1 Kullan\u0131m Durumu #1: Nesne Tabanl\u0131 3D Tarama"},{"location":"SRD/#332-kullanm-durumu-2-medikal-tarama-uzuv-modelleme","text":"Ama\u00e7: Medikal sekt\u00f6r\u00fcnde kullan\u0131lmak \u00fczere insan uzuvlar\u0131n\u0131n hassas \u015fekilde taranarak dijital ortama aktar\u0131lmas\u0131. Akt\u00f6rler: Kullan\u0131c\u0131 (teknisyen), hasta \u00d6n Ko\u015fullar: Ki\u015fi hareketsiz pozisyonda durmal\u0131 Kalibrasyon dosyalar\u0131 \u00f6nceden haz\u0131rlanm\u0131\u015f olmal\u0131 Marker\u2019lar sistem g\u00f6r\u00fc\u015f alan\u0131nda net \u015fekilde sabitlenmi\u015f olmal\u0131 Ortam \u0131\u015f\u0131\u011f\u0131 yetersiz de\u011filse ek ayd\u0131nlatma sa\u011flanmal\u0131 Senaryo: Kullan\u0131c\u0131 hastay\u0131 tarama alan\u0131na yerle\u015ftirir. Marker'lar alg\u0131lan\u0131r, sistem pozisyonunu do\u011frular. Tarama \u00e7\u00f6z\u00fcn\u00fcrl\u00fc\u011f\u00fc \u201cy\u00fcksek\u201d olarak se\u00e7ilir. Sistem birka\u00e7 saniyelik g\u00f6r\u00fcnt\u00fc al\u0131m\u0131 yapar. Elde edilen nokta bulutu y\u00fczey yumu\u015fatma ile optimize edilir. Model, ortopedik kal\u0131p \u00fcretimi i\u00e7in d\u0131\u015fa aktar\u0131l\u0131r. Sonu\u00e7: Hasta uzvunun dijital modeli al\u0131nm\u0131\u015f ve \u00fcretime haz\u0131r h\u00e2le getirilmi\u015ftir.","title":"3.3.2 Kullan\u0131m Durumu #2: Medikal Tarama \u2013 Uzuv Modelleme"},{"location":"SRD/#333-kullanm-durumu-3-algoritma-karslastrma-modu-test-arayuzu","text":"Ama\u00e7: Yeni nokta bulutu filtreleme veya y\u00fczey iyile\u015ftirme algoritmalar\u0131n\u0131 test etmek ve etkilerini g\u00f6rsel olarak kar\u015f\u0131la\u015ft\u0131rmak. Akt\u00f6rler: Geli\u015ftirici veya ara\u015ft\u0131rmac\u0131 kullan\u0131c\u0131 \u00d6n Ko\u015fullar: Marker\u2019lar yaz\u0131l\u0131mda tan\u0131t\u0131lm\u0131\u015f olmal\u0131 (e\u011fer canl\u0131 tarama yap\u0131lacaksa) Mevcut veya \u00f6nceden taranm\u0131\u015f nokta bulutu verisi sisteme y\u00fcklenebilir olmal\u0131 Senaryo: Kullan\u0131c\u0131 mevcut bir nokta bulutunu yaz\u0131l\u0131ma y\u00fckler. Farkl\u0131 filtreleme algoritmalar\u0131 listeden se\u00e7ilir. Yaz\u0131l\u0131m ayn\u0131 veri \u00fczerinde \u00f6nce/sonra kar\u015f\u0131la\u015ft\u0131rmas\u0131 yapar. Kullan\u0131c\u0131 g\u00f6rsel \u00e7\u0131kt\u0131lar \u00fczerinden karar verir. Sonu\u00e7: Algoritmalar\u0131n performans\u0131 test edilmi\u015f olur, ileri geli\u015ftirmeler yap\u0131labilir.","title":"3.3.3 Kullan\u0131m Durumu #3: Algoritma Kar\u015f\u0131la\u015ft\u0131rma Modu (Test Aray\u00fcz\u00fc)"},{"location":"SRD/#34-snflar-nesneler","text":"","title":"3.4 S\u0131n\u0131flar / Nesneler"},{"location":"SRD/#341-snf-nesne-1-kameramodulu","text":"\u00d6znitelikler: ID, \u00e7\u00f6z\u00fcn\u00fcrl\u00fck, fps, kalibrasyon parametreleri \u0130\u015flevler: G\u00f6r\u00fcnt\u00fcAl(), KalibrasyonY\u00fckle(), VideoAk\u0131\u015f\u0131Ba\u015flat() Referans: FG-1, FG-7","title":"3.4.1 S\u0131n\u0131f / Nesne #1: KameraMod\u00fcl\u00fc"},{"location":"SRD/#342-snf-nesne-2-nokta-bulutu-isleyici","text":"\u00d6znitelikler: Nokta listesi, filtreleme parametreleri \u0130\u015flevler: Olu\u015ftur(), Filtrele(), Kaydet() Referans: FG-3, FG-5, FG-8","title":"3.4.2 S\u0131n\u0131f / Nesne #2: Nokta Bulutu \u0130\u015fleyici"},{"location":"SRD/#35-islevsel-olmayan-gereksinimler","text":"","title":"3.5 \u0130\u015flevsel Olmayan Gereksinimler"},{"location":"SRD/#351-performans","text":"Kamera ve yap\u0131sal \u0131\u015f\u0131ktan elde edilecek nokta bulutlar\u0131 sistem \u00fczerinden donma olmadan ak\u0131c\u0131 bir \u015fekilde minimum 15 fps\u2019te g\u00f6r\u00fcnt\u00fcleyebilmelidir.","title":"3.5.1 Performans"},{"location":"SRD/#352-guvenilirlik","text":"Elde edilen nokta bulutlar\u0131n\u0131n kusursuza yak\u0131n olmas\u0131 ve taramada elde edilen obje ile ger\u00e7ek d\u00fcnyadaki objenin ayn\u0131 boyutta olmas\u0131 hedeflenmektedir.","title":"3.5.2 G\u00fcvenilirlik"},{"location":"SRD/#353-kullanlabilirlik","text":"Kullan\u0131c\u0131 aray\u00fcz\u00fc sade ve sezgisel olacak \u015fekilde tasarlanmal\u0131d\u0131r. Kullan\u0131c\u0131lar, temel e\u011fitimle t\u00fcm tarama i\u015flemlerini ger\u00e7ekle\u015ftirebilecektir.","title":"3.5.3 Kullan\u0131labilirlik"},{"location":"SRD/#354-guvenlik","text":"Yaz\u0131l\u0131m, kullan\u0131c\u0131 eri\u015fim kontrol\u00fc sa\u011flamasa da yaln\u0131zca yerel sistemde \u00e7al\u0131\u015f\u0131r. Hassas veriler \u015fifreli bi\u00e7imde saklanmaz.","title":"3.5.4 G\u00fcvenlik"},{"location":"SRD/#355-surdurulebilirlik","text":"Yaz\u0131l\u0131m a\u00e7\u0131k kaynak kodlu olarak geli\u015ftirilecek, topluluk katk\u0131lar\u0131 ile g\u00fcncellemeler s\u00fcrd\u00fcr\u00fclebilecektir.","title":"3.5.5 S\u00fcrd\u00fcr\u00fclebilirlik"},{"location":"SRD/#356-tasnabilirlik","text":"Kodlar platformdan ba\u011f\u0131ms\u0131z olarak C++ ve Python ile yaz\u0131lacak, ancak ba\u015flang\u0131\u00e7ta yaln\u0131zca Ubuntu 22.04 i\u015fletim sisteminde \u00e7al\u0131\u015facakt\u0131r.","title":"3.5.6 Ta\u015f\u0131nabilirlik"},{"location":"SRD/#36-ters-gereksinimleri","text":"Yaz\u0131l\u0131m \u00e7evrimd\u0131\u015f\u0131 \u00e7al\u0131\u015facak, bulut ba\u011flant\u0131s\u0131 olmadan t\u00fcm i\u015flevlerini ger\u00e7ekle\u015ftirecektir.","title":"3.6 Ters Gereksinimleri"},{"location":"SRD/#37-tasarm-kstlamalar","text":"Bu yaz\u0131l\u0131m projesini etkileyen baz\u0131 tasar\u0131m k\u0131s\u0131tlamalar\u0131 a\u015fa\u011f\u0131da belirtilmi\u015ftir: Donan\u0131m Kaynak S\u0131n\u0131rlamalar\u0131: Cihaz\u0131n \u00e7al\u0131\u015fabilmesi i\u00e7in minimum donan\u0131m gereksinimleri vard\u0131r. \u00d6zellikle y\u00fcksek \u00e7\u00f6z\u00fcn\u00fcrl\u00fckl\u00fc stereo g\u00f6r\u00fcnt\u00fclerin i\u015flenmesi ve 3D nokta bulutu olu\u015fturma s\u00fcre\u00e7leri y\u00fcksek i\u015flem g\u00fcc\u00fc ve bellek gerektirdi\u011finden, sistemin en az Intel i7 i\u015flemci, 32GB RAM ve SSD depolama alan\u0131na sahip olmas\u0131 beklenmektedir. Ger\u00e7ek Zamanl\u0131 \u0130\u015fleme K\u0131s\u0131tlamas\u0131: Kameralardan gelen veri ak\u0131\u015f\u0131n\u0131n e\u015f zamanl\u0131 olarak i\u015flenebilmesi i\u00e7in i\u015flem gecikmelerinin minimumda tutulmas\u0131 gerekmektedir. Bu durum yaz\u0131l\u0131m\u0131n mod\u00fcler ve h\u0131zl\u0131 \u00e7al\u0131\u015fan algoritmalarla geli\u015ftirilmesini zorunlu k\u0131lar. Kamera Uyumlulu\u011fu: Yaz\u0131l\u0131m yaln\u0131zca belirli USB 3.0 stereo kameralarla (\u00f6r. e-con Systems IMX900) uyumlu olacak \u015fekilde geli\u015ftirilecektir. Di\u011fer marka/model kameralarla uyumluluk garanti edilmemektedir. \u0130\u015fletim Sistemi Uyumlulu\u011fu: Yaz\u0131l\u0131m sadece Ubuntu 22.04 LTS i\u015fletim sistemi \u00fczerinde test edilip \u00e7al\u0131\u015ft\u0131r\u0131lacakt\u0131r. Di\u011fer i\u015fletim sistemleri i\u00e7in destek sa\u011flanmamaktad\u0131r. \u00c7evrimd\u0131\u015f\u0131 \u00c7al\u0131\u015fma: Uygulama tamamen \u00e7evrimd\u0131\u015f\u0131 \u00e7al\u0131\u015facak \u015fekilde tasarland\u0131\u011f\u0131ndan, bulut tabanl\u0131 depolama veya i\u015flem hizmetleri kullan\u0131lmayacakt\u0131r.","title":"3.7 Tasar\u0131m K\u0131s\u0131tlamalar\u0131"},{"location":"SRD/#38-mantksal-veritaban-gereksinimleri","text":"Bu sistemde merkezi bir veritaban\u0131 kullan\u0131lmayacakt\u0131r. Ancak yap\u0131lan tarama i\u015flemlerine ait metadata\u2019lar JSON format\u0131nda klas\u00f6rlerde saklanacakt\u0131r. Dosya yap\u0131s\u0131 hiyerar\u015fik olacakt\u0131r.","title":"3.8 Mant\u0131ksal Veritaban\u0131 Gereksinimleri"},{"location":"SRD/#39-diger-gereksinimler","text":"Yaz\u0131l\u0131m a\u00e7\u0131k kaynak lisans (MIT veya GPL) ile yay\u0131nlanacakt\u0131r. T\u00fcm \u00e7\u0131kt\u0131lar kullan\u0131c\u0131 dizinine otomatik olarak kaydedilecek, i\u015flem sonunda otomatik olarak klas\u00f6r a\u00e7\u0131lacakt\u0131r. Uygulama terminal \u00e7\u0131kt\u0131lar\u0131 ile hata mesajlar\u0131 ve debug bilgilerini kullan\u0131c\u0131ya g\u00f6sterecektir.","title":"3.9 Di\u011fer Gereksinimler"},{"location":"SRD/#4-analiz-modelleri","text":"","title":"4. Analiz Modelleri"},{"location":"SRD/#41-aktivite-diyagramlar","text":"Kamera Pozisyonun Bulunmas\u0131 flowchart TD A[\"Kamera Kalibrasyonu - \u0130\u00e7 parametreler: K, D\"] --> B[\"Kamera G\u00f6r\u00fcnt\u00fcs\u00fc - Ger\u00e7ek zamanl\u0131 video\"] B --> C[\"G\u00f6r\u00fcnt\u00fc \u00d6n \u0130\u015fleme - Griye \u00e7evirme, Gauss bulan\u0131kla\u015ft\u0131rma, E\u015fikleme / Canny\"] C --> D[\"Daire Alg\u0131lama - HoughCircles veya Blob\"] D --> E[\"Dairelerin Merkezi ve Yar\u0131\u00e7ap Bilgisi\"] E --> F[\"Marker ID Atama - Opsiyonel, Konum, boyut, desen ile\"] F --> G[\"PnP ile Pozisyon Tahmini - 3D - 2D e\u015fleme, solvePnP\"] G --> H[\"Kamera Pozisyonu - R, t ve Takip G\u00fcncellemesi\"] Genel Yaz\u0131l\u0131m Mimarisi \u2026","title":"4.1 Aktivite Diyagramlar\u0131"},{"location":"SRD/#42-sequence-diyagramlar","text":"sequenceDiagram participant Kullan\u0131c\u0131 participant UI participant Kamera participant G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici participant PnP Algoritmas\u0131 Kullan\u0131c\u0131 ->> UI: Tarama Ba\u015flat UI ->> Kamera: Kamera Ba\u015flat Kamera ->> G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici: G\u00f6r\u00fcnt\u00fc G\u00f6nder G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici ->> PnP Algoritmas\u0131: \u0130\u015flem Yap PnP Algoritmas\u0131 ->> G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici: Pozisyon Hesapla G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici ->> UI: Veriyi UI'ye G\u00f6nder UI ->> Kullan\u0131c\u0131: Model G\u00f6ster","title":"4.2 Sequence Diyagramlar\u0131"},{"location":"SRD/#43-veri-aks-diyagramlar","text":"graph TD A[Kamera-Ham G\u00f6r\u00fcnt\u00fc] --> B[Kalibrasyon - Kalibrasyon Verisi] B --> C[G\u00f6r\u00fcnt\u00fc \u0130\u015fleme - \u0130\u015flenmi\u015f G\u00f6r\u00fcnt] C --> D[Derinlik Hesaplama - Derinlik Verisi] C --> E[Nokta Bulutu] D --> F[Nokta Bulutu] E --> F[3D Model Olu\u015fturucu]","title":"4.3 Veri Ak\u0131\u015f Diyagramlar\u0131"},{"location":"SRD/#44-durum-gecisi-diyagramlar","text":"stateDiagram-v2 [*] --> Ba\u015flang\u0131\u00e7 Ba\u015flang\u0131\u00e7 --> Kalibrasyon_Y\u00fckleniyor Kalibrasyon_Y\u00fckleniyor --> Haz\u0131r Haz\u0131r --> Tarama_Yap\u0131l\u0131yor Tarama_Yap\u0131l\u0131yor --> \u0130\u015fleniyor \u0130\u015fleniyor --> Kaydedildi \u0130\u015fleniyor --> Hata_Durumu Hata_Durumu --> Tarama_Yap\u0131l\u0131yor","title":"4.4 Durum Ge\u00e7i\u015fi Diyagramlar\u0131"},{"location":"SRD/#5-degisiklik-yonetimi-sureci","text":"Bu yaz\u0131l\u0131m gereksinimleri dok\u00fcman\u0131nda yap\u0131lacak her t\u00fcrl\u00fc de\u011fi\u015fiklik, kontroll\u00fc ve izlenebilir bir s\u00fcre\u00e7 \u00e7er\u00e7evesinde y\u00fcr\u00fct\u00fclecektir. A\u015fa\u011f\u0131da bu s\u00fcrecin detaylar\u0131 yer almaktad\u0131r:","title":"5. De\u011fi\u015fiklik Y\u00f6netimi S\u00fcreci"},{"location":"SRD/#51-degisiklik-talebi","text":"Herhangi bir ekip \u00fcyesi, m\u00fc\u015fteri ya da payda\u015f sistem gereksinimlerinde de\u011fi\u015fiklik \u00f6nerisinde bulunabilir. De\u011fi\u015fiklik talepleri yaz\u0131l\u0131 olarak ve gerek\u00e7esiyle birlikte De\u011fi\u015fiklik Talep Formu (veya GitHub Issues \u00fczerinden) ile sunulmal\u0131d\u0131r.","title":"5.1 De\u011fi\u015fiklik Talebi"},{"location":"SRD/#52-degerlendirme-ve-etki-analizi","text":"De\u011fi\u015fiklik talepleri, proje y\u00f6neticisi ve teknik ekip taraf\u0131ndan de\u011ferlendirilir. Her de\u011fi\u015fikli\u011fin teknik fizibilitesi, zaman/maliyet etkisi ve mevcut sistem \u00fczerindeki etkisi analiz edilir. Gerekirse, m\u00fc\u015fteriyle tekrar ileti\u015fime ge\u00e7ilerek kapsam netle\u015ftirilir.","title":"5.2 De\u011ferlendirme ve Etki Analizi"},{"location":"SRD/#53-onay-ve-uygulama","text":"Uygun bulunan de\u011fi\u015fiklikler, proje y\u00f6neticisi taraf\u0131ndan onaylanarak resmi revizyonlara dahil edilir. \u0130lgili yaz\u0131l\u0131m bile\u015fenleri, test planlar\u0131 ve dok\u00fcmantasyon bu de\u011fi\u015fikli\u011fe g\u00f6re g\u00fcncellenir.","title":"5.3 Onay ve Uygulama"},{"location":"SRD/#54-versiyonlama-ve-kayt","text":"Her de\u011fi\u015fiklik dok\u00fcmana revizyon numaras\u0131, tarih, yazar ve a\u00e7\u0131klama ile birlikte kaydedilir. De\u011fi\u015fiklik ge\u00e7mi\u015fi \u201cRevizyon Ge\u00e7mi\u015fi\u201d b\u00f6l\u00fcm\u00fcnde tutulur. Git \u00fczerinden s\u00fcr\u00fcm kontrol\u00fc sa\u011flan\u0131r (\u00f6rn. v1.1, v1.2-beta gibi).","title":"5.4 Versiyonlama ve Kay\u0131t"},{"location":"SRD/#55-iletisim-ve-paylasm","text":"Onaylanan de\u011fi\u015fiklikler ilgili t\u00fcm ekip \u00fcyeleriyle payla\u015f\u0131l\u0131r. Yeni versiyonlar yaz\u0131l\u0131m deposunda ve proje belgelerinde a\u00e7\u0131k\u00e7a belirtilir.","title":"5.5 \u0130leti\u015fim ve Payla\u015f\u0131m"},{"location":"SRD/#a-ekler","text":"Ekler, ilave ve yararl\u0131 bilgi sa\u011flamak i\u00e7in kullan\u0131labilir. Varsa, belirtim a\u00e7\u0131k\u00e7a ekinde yer alan bilgilerin belirtimde ifade edilen gereksinimlerin bir par\u00e7as\u0131 olarak dikkate al\u0131nmas\u0131 gerekiyor belirtilmelidir. \u00d6rnek Ekler (ilk) yaz\u0131l\u0131m projesi i\u00e7in kavramsal belgeler, pazarlama materyalleri, m\u00fc\u015fteri ler ile toplant\u0131lar\u0131n i\u00e7eri\u011fini vs.i\u00e7erebilir.","title":"A. Ekler"},{"location":"SRD/#a1-ek-1","text":"","title":"A.1 Ek 1"},{"location":"SRD/#etkilesimli-diyagramlar","text":"GitHub Pages'de Mermaid diyagramlar\u0131 kullanabilirsiniz. \u00d6rnek: graph TD A[Kamera Mod\u00fcl\u00fc] -->|G\u00f6r\u00fcnt\u00fc Yakala| B[G\u00f6r\u00fcnt\u00fc \u0130\u015fleme] B --> C[Nokta Bulutu Olu\u015fturma] C --> D[Mesh Olu\u015fturma] D --> E[3D Model D\u0131\u015fa Aktarma] B --> F[Marker Tespiti] F --> G[PnP ile Kamera Pozisyonu]","title":"Etkile\u015fimli Diyagramlar"},{"location":"SRD/#proje-ilerleme-takibi","text":"Gereksinimlerin Belirlenmesi : Tamamland\u0131 (2 Nisan 2025) Mimari Tasar\u0131m : Devam Ediyor Prototip Geli\u015ftirme : Planlanan (15 May\u0131s 2025)","title":"Proje \u0130lerleme Takibi"},{"location":"SRD/#kod-degisikligi-guncellemeleri","text":"","title":"Kod De\u011fi\u015fikli\u011fi G\u00fcncellemeleri"},{"location":"SRD/#2025-04-02-1155-tarihli-kod-degisiklikleri","text":"Commit: 43ffc96 - Add System Requirements Document (SRD) and update project progress tracking","title":"2025-04-02 11:55 Tarihli Kod De\u011fi\u015fiklikleri"},{"location":"SRD/#degistirilen-dosyalar","text":"","title":"De\u011fi\u015ftirilen Dosyalar"},{"location":"diagram-example/","text":"Diyagram \u00d6rnekleri Bu sayfa Mermaid.js kullan\u0131larak olu\u015fturulmu\u015f diyagram \u00f6rneklerini g\u00f6sterir. Ak\u0131\u015f Diyagram\u0131 graph TD A[Ba\u015fla] --> B[Kamera Haz\u0131rla] B --> C{Marker G\u00f6r\u00fcn\u00fcr m\u00fc?} C -- Evet --> D[PnP ile Konum Hesapla] C -- Hay\u0131r --> E[Kullan\u0131c\u0131y\u0131 Uyar] D --> F[Taramay\u0131 Ba\u015flat] E --> B Sequence Diyagram\u0131 sequenceDiagram participant K as Kullan\u0131c\u0131 participant S as Sistem participant KM as Kamera K->>S: Tarama Ba\u015flat S->>KM: G\u00f6r\u00fcnt\u00fc \u0130ste KM-->>S: G\u00f6r\u00fcnt\u00fc G\u00f6nder S->>S: \u0130\u015fle S-->>K: Sonu\u00e7 G\u00f6ster Durum Diyagram\u0131 stateDiagram-v2 [*] --> Haz\u0131r Haz\u0131r --> Taran\u0131yor: Ba\u015flat Taran\u0131yor --> \u0130\u015fleniyor: Tamamland\u0131 \u0130\u015fleniyor --> Kaydedildi: Ba\u015far\u0131l\u0131 \u0130\u015fleniyor --> Hata: Ba\u015far\u0131s\u0131z Hata --> Haz\u0131r: Yeniden Dene Kaydedildi --> Haz\u0131r: Yeni Tarama","title":"Diyagram \u00d6rnekleri"},{"location":"diagram-example/#diyagram-ornekleri","text":"Bu sayfa Mermaid.js kullan\u0131larak olu\u015fturulmu\u015f diyagram \u00f6rneklerini g\u00f6sterir.","title":"Diyagram \u00d6rnekleri"},{"location":"diagram-example/#aks-diyagram","text":"graph TD A[Ba\u015fla] --> B[Kamera Haz\u0131rla] B --> C{Marker G\u00f6r\u00fcn\u00fcr m\u00fc?} C -- Evet --> D[PnP ile Konum Hesapla] C -- Hay\u0131r --> E[Kullan\u0131c\u0131y\u0131 Uyar] D --> F[Taramay\u0131 Ba\u015flat] E --> B","title":"Ak\u0131\u015f Diyagram\u0131"},{"location":"diagram-example/#sequence-diyagram","text":"sequenceDiagram participant K as Kullan\u0131c\u0131 participant S as Sistem participant KM as Kamera K->>S: Tarama Ba\u015flat S->>KM: G\u00f6r\u00fcnt\u00fc \u0130ste KM-->>S: G\u00f6r\u00fcnt\u00fc G\u00f6nder S->>S: \u0130\u015fle S-->>K: Sonu\u00e7 G\u00f6ster","title":"Sequence Diyagram\u0131"},{"location":"diagram-example/#durum-diyagram","text":"stateDiagram-v2 [*] --> Haz\u0131r Haz\u0131r --> Taran\u0131yor: Ba\u015flat Taran\u0131yor --> \u0130\u015fleniyor: Tamamland\u0131 \u0130\u015fleniyor --> Kaydedildi: Ba\u015far\u0131l\u0131 \u0130\u015fleniyor --> Hata: Ba\u015far\u0131s\u0131z Hata --> Haz\u0131r: Yeniden Dene Kaydedildi --> Haz\u0131r: Yeni Tarama","title":"Durum Diyagram\u0131"},{"location":"document/","text":"Yaz\u0131l\u0131m Tasar\u0131m Dok\u00fcman\u0131: Clonify Labs Proje Ad\u0131 Medikal Sekt\u00f6rde 3 Boyutlu Tarama ile Ki\u015fiye \u00d6zel H\u0131zl\u0131 Kal\u0131p \u00dcretimi \u00dcr\u00fcn Ad\u0131 Clonify Labs Modelleme Yaz\u0131l\u0131m\u0131 Versiyon 2.0 (Planlanan) Tarih 08.08.2025 \u015eirket Clonify Labs \u0130\u00e7indekiler Giri\u015f 1.1. Dok\u00fcman\u0131n Amac\u0131 1.2. Projenin Kapsam\u0131 1.3. Tan\u0131mlar ve K\u0131saltmalar Sistem Mimarisi 2.1. Mimari Yakla\u015f\u0131m: Katmanl\u0131 Mimari 2.2. Katmanlar\u0131n Detayl\u0131 Analizi 2.3. Mimari \u015eemas\u0131 ve Veri Ak\u0131\u015f\u0131 Kullan\u0131lan Teknolojiler ve K\u00fct\u00fcphaneler Ana Bile\u015fenlerin Tasar\u0131m\u0131 ve Sorumluluklar\u0131 4.1. Kontrol Katman\u0131: MainWindow 4.2. Aray\u00fcz Katman\u0131: ui Mod\u00fclleri 4.3. Ara\u00e7 Katman\u0131: tools Mod\u00fclleri B\u00f6l\u00fcm 1: Giri\u015f 1.1. Dok\u00fcman\u0131n Amac\u0131 Bu dok\u00fcman\u0131n temel amac\u0131, QClonifyCad yaz\u0131l\u0131m\u0131n\u0131n teknik mimarisini, tasar\u0131m kararlar\u0131n\u0131, temel bile\u015fenlerini ve bu bile\u015fenler aras\u0131ndaki etkile\u015fimi detayl\u0131 bir \u015fekilde a\u00e7\u0131klamakt\u0131r. Bu belge, projenin mevcut ve gelecekteki geli\u015ftiricileri i\u00e7in bir referans kayna\u011f\u0131 olarak hizmet edecek, kodun s\u00fcrd\u00fcr\u00fclebilirli\u011fini ve geni\u015fletilebilirli\u011fini sa\u011flamak i\u00e7in bir yol haritas\u0131 sunacakt\u0131r. 1.2. Projenin Kapsam\u0131 Bu dok\u00fcman, yaz\u0131l\u0131m\u0131n a\u015fa\u011f\u0131daki \u00e7ekirdek i\u015flevselliklerini ve planlanan mod\u00fcllerini kapsar: - Mevcut \u00d6zellikler: - STL format\u0131nda 3D model y\u00fckleme ve g\u00f6rselle\u015ftirme. - \u00c7oklu pencerede (multi-view) anatomik hizalama. - 2D se\u00e7imle 3D g\u00fcr\u00fclt\u00fc temizleme. - Planlanan \u00d6zellikler: - Model y\u00fczeyindeki deliklerin otomatik doldurulmas\u0131. - Etkile\u015fimli kesit bantlar\u0131 ile radyal deformasyon. - \"Bulge/Smooth\" f\u0131r\u00e7alar\u0131 ile serbest form modelleme. - Geri Al/\u0130leri Al (Undo/Redo) yetene\u011fi. 1.3. Tan\u0131mlar ve K\u0131saltmalar GUI: Grafiksel Kullan\u0131c\u0131 Aray\u00fcz\u00fc (Graphical User Interface) VTK: The Visualization Toolkit STL: Stereolithography (3D dosya format\u0131) PolyData: VTK'da poligon a\u011f\u0131n\u0131 (noktalar, h\u00fccreler) temsil eden temel veri yap\u0131s\u0131. Pipeline: Veri ak\u0131\u015f hatt\u0131. VTK'da verinin bir dizi filtreden ge\u00e7erek i\u015flenmesi. Frustum: Kesik piramit. 3D'de bir kamera g\u00f6r\u00fc\u015f alan\u0131n\u0131 tan\u0131mlayan geometrik hacim. B\u00f6l\u00fcm 2: Sistem Mimarisi 2.1. Mimari Yakla\u015f\u0131m: Katmanl\u0131 Mimari Yaz\u0131l\u0131m, kodun y\u00f6netilebilirli\u011fini ve mod\u00fclerli\u011fini sa\u011flamak amac\u0131yla, g\u00f6revleri net bir \u015fekilde ayr\u0131\u015ft\u0131ran \u00fc\u00e7 katmanl\u0131 bir mimari \u00fczerine in\u015fa edilmi\u015ftir. Bu yap\u0131, Model-View-Controller (MVC) tasar\u0131m deseninden g\u00fc\u00e7l\u00fc bir \u015fekilde ilham alm\u0131\u015ft\u0131r. 2.2. Katmanlar\u0131n Detayl\u0131 Analizi Aray\u00fcz Katman\u0131 (View): PyQt5 ile olu\u015fturulmu\u015ftur. Sadece g\u00f6rsel elemanlar\u0131 bar\u0131nd\u0131r\u0131r ve kullan\u0131c\u0131 etkile\u015fimlerini sinyallere d\u00f6n\u00fc\u015ft\u00fcr\u00fcr. main.py 'deki veriyi g\u00f6rselle\u015ftirir ancak kendi i\u00e7inde mant\u0131k veya durum bar\u0131nd\u0131rmaz. Kontrol/Mant\u0131k Katman\u0131 (Controller): main.py dosyas\u0131ndaki MainWindow s\u0131n\u0131f\u0131d\u0131r. Uygulaman\u0131n beyni olarak \u00e7al\u0131\u015f\u0131r. Aray\u00fczden gelen sinyalleri i\u015fler, uygulama durumunu ( state ) y\u00f6netir ve 3D Ara\u00e7lar katman\u0131na komutlar g\u00f6nderir. 3D \u00c7ekirdek ve Ara\u00e7lar Katman\u0131 (Model): VTK ve tools klas\u00f6r\u00fcndeki s\u0131n\u0131flardan olu\u015fur. T\u00fcm 3D veri i\u015fleme, filtreleme ve karma\u015f\u0131k etkile\u015fim mant\u0131\u011f\u0131 bu katmanda yer al\u0131r. Bu katmandaki ara\u00e7lar, Kontrol Katman\u0131'ndan ba\u011f\u0131ms\u0131z, yeniden kullan\u0131labilir bile\u015fenlerdir. B\u00f6l\u00fcm 3: Kullan\u0131lan Teknolojiler ve K\u00fct\u00fcphaneler Projenin geli\u015ftirilmesinde, a\u00e7\u0131k kaynak kodlu, end\u00fcstri standard\u0131, y\u00fcksek performansl\u0131 ve geni\u015f topluluk deste\u011fine sahip teknolojiler tercih edilmi\u015ftir. Bu se\u00e7imler, projenin hem h\u0131zl\u0131 bir \u015fekilde geli\u015ftirilmesini hem de gelecekteki bak\u0131m ve geni\u015fletme s\u00fcre\u00e7lerinin verimli olmas\u0131n\u0131 sa\u011flamay\u0131 ama\u00e7lamaktad\u0131r. 3.1. Ana Programlama Dili: Python 3.x Python, h\u0131zl\u0131 prototipleme yetene\u011fi, temiz ve okunabilir s\u00f6zdizimi (syntax) ve zengin standart k\u00fct\u00fcphanesi sayesinde projenin ana geli\u015ftirme dili olarak se\u00e7ilmi\u015ftir. \u00d6zellikle bilimsel hesaplama, veri analizi ve yapay zeka alanlar\u0131ndaki g\u00fcc\u00fc, projenin medikal veri i\u015fleme do\u011fas\u0131yla m\u00fckemmel bir \u015fekilde \u00f6rt\u00fc\u015fmektedir. Python'un \"glue language\" (yap\u0131\u015ft\u0131r\u0131c\u0131 dil) \u00f6zelli\u011fi, C++ gibi y\u00fcksek performansl\u0131 dillerle yaz\u0131lm\u0131\u015f VTK gibi k\u00fct\u00fcphanelerin kolayca entegre edilmesini sa\u011flam\u0131\u015ft\u0131r. 3.2. Grafiksel Kullan\u0131c\u0131 Aray\u00fcz\u00fc (GUI): PyQt5 PyQt5, platformdan ba\u011f\u0131ms\u0131z (Windows, macOS, Linux) masa\u00fcst\u00fc uygulamalar\u0131 geli\u015ftirmek i\u00e7in kullan\u0131lan, end\u00fcstri standard\u0131 Qt C++ k\u00fct\u00fcphanesinin Python versiyonudur. - Se\u00e7im nedenleri \u015funlard\u0131r: - Olgunluk ve Kararl\u0131l\u0131k: Qt, y\u0131llard\u0131r geli\u015ftirilen, son derece kararl\u0131 ve g\u00fcvenilir bir aray\u00fcz \u00e7at\u0131s\u0131d\u0131r. - Sinyal ve Slot Mekanizmas\u0131: Aray\u00fcz elemanlar\u0131 (View) ile program mant\u0131\u011f\u0131 (Controller) aras\u0131nda esnek, g\u00fcvenli ve ayr\u0131\u015ft\u0131r\u0131lm\u0131\u015f (decoupled) bir ileti\u015fim sa\u011flar. Bu, mimarimizin temel ta\u015flar\u0131ndan biridir. - Geni\u015f Widget Seti: Butonlar, listeler, paneller, men\u00fcler ve QDockWidget gibi geli\u015fmi\u015f yerle\u015fim ara\u00e7lar\u0131, karma\u015f\u0131k ve profesyonel bir kullan\u0131c\u0131 aray\u00fcz\u00fcn\u00fcn h\u0131zl\u0131ca olu\u015fturulmas\u0131na olanak tan\u0131r. - VTK Entegrasyonu: QVTKRenderWindowInteractor widget'\u0131 sayesinde, VTK'n\u0131n y\u00fcksek performansl\u0131 3D render pencerelerinin bir Qt uygulamas\u0131 i\u00e7ine sorunsuz bir \u015fekilde g\u00f6m\u00fclmesini ve olay d\u00f6ng\u00fclerinin (event loop) entegre \u00e7al\u0131\u015fmas\u0131n\u0131 sa\u011flar. 3.3. 3D G\u00f6rselle\u015ftirme ve \u0130\u015fleme Motoru:** VTK (The Visualization Toolkit) VTK, bilimsel ve medikal verilerin 3 boyutlu olarak i\u015flenmesi, g\u00f6rselle\u015ftirilmesi ve analizi i\u00e7in tasarlanm\u0131\u015f, C++ tabanl\u0131, y\u00fcksek performansl\u0131 bir k\u00fct\u00fcphanedir. Projenin 3D ile ilgili t\u00fcm a\u011f\u0131r i\u015flerini VTK \u00fcstlenir. - Veri Ak\u0131\u015f Hatt\u0131 Mimarisi (Pipeline Architecture): VTK'n\u0131n temel g\u00fcc\u00fc, Source -> Filter -> Mapper -> Actor \u015feklindeki veri ak\u0131\u015f modelidir. Bu yap\u0131, karma\u015f\u0131k 3D veri i\u015fleme zincirlerinin mod\u00fcler ve verimli bir \u015fekilde olu\u015fturulmas\u0131n\u0131 sa\u011flar. Bellek y\u00f6netimi ve g\u00fcncellemeler bu pipeline \u00fczerinden otomatik olarak y\u00f6netilir. - Zengin Filtre K\u00fct\u00fcphanesi: Projemizde aktif olarak kulland\u0131\u011f\u0131m\u0131z vtkClipPolyData (kesme), vtkTransformPolyDataFilter (d\u00f6nd\u00fcrme/ta\u015f\u0131ma) ve vtkSTLReader gibi y\u00fczlerce haz\u0131r algoritma i\u00e7erir. Gelecekteki mod\u00fcller i\u00e7in vtkFillHolesFilter, vtkSmoothPolyDataFilter gibi filtreler de kullan\u0131lacakt\u0131r. - Geli\u015fmi\u015f Etkile\u015fim Mekanizmalar\u0131: vtkRenderWindowInteractor ve vtkInteractorStyle alt s\u0131n\u0131flar\u0131, fare ve klavye ile 3D sahne \u00fczerinde, sadece kamera kontrol\u00fc de\u011fil, ayn\u0131 zamanda nesne se\u00e7imi (vtkPointPicker), alan \u00e7izimi (vtkInteractorStyleRubberBand2D) ve \u00f6zel ara\u00e7 davran\u0131\u015flar\u0131 gibi karma\u015f\u0131k etkile\u015fimler olu\u015fturmak i\u00e7in g\u00fc\u00e7l\u00fc bir altyap\u0131 sunar. 3.4. Matematiksel ve Bilimsel Hesaplama:** NumPy NumPy, Python'da bilimsel hesaplamalar i\u00e7in temel pakettir. \u00d6zellikle \u00e7ok boyutlu diziler (array) \u00fczerinde y\u00fcksek performansl\u0131 matematiksel i\u015flemler i\u00e7in kullan\u0131l\u0131r. - Performans: Vekt\u00f6r ve matris gibi veri yap\u0131lar\u0131 \u00fczerinde yap\u0131lan i\u015flemler, derlenmi\u015f C koduna yak\u0131n bir h\u0131zda ger\u00e7ekle\u015ftirilir. Bu, binlerce noktadan olu\u015fan 3D modellerin deformasyonu gibi hesaplama-yo\u011fun i\u015flemlerde kritik \u00f6neme sahiptir. - Vekt\u00f6r Matemati\u011fi: Anatomik hizalama algoritmas\u0131nda, normal vekt\u00f6rlerin ve eksenlerin hesaplanmas\u0131 i\u00e7in np.cross (\u00e7apraz \u00e7arp\u0131m) ve np.linalg.norm (vekt\u00f6r uzunlu\u011fu) gibi fonksiyonlar vazge\u00e7ilmezdir. - VTK Uyumlulu\u011fu: vtk.util.numpy_support mod\u00fcl\u00fc, NumPy dizileri ile VTK'n\u0131n kendi veri dizileri aras\u0131nda s\u0131f\u0131r-kopya (zero-copy) veya minimum-kopya ile veri al\u0131\u015fveri\u015fi yap\u0131lmas\u0131n\u0131 sa\u011flar. Bu, on binlerce noktan\u0131n koordinatlar\u0131n\u0131 Python'da i\u015fleyip tekrar VTK'ya verimli bir \u015fekilde geri g\u00f6ndermemize olanak tan\u0131r. B\u00f6l\u00fcm 4: Ana Bile\u015fenlerin Tasar\u0131m\u0131 ve Sorumluluklar\u0131 4.1. Kontrol Katman\u0131 (Controller) Uygulaman\u0131n ana pencere s\u0131n\u0131f\u0131 bu rol\u00fc \u00fcstlenir. - Sorumluluklar: - Uygulaman\u0131n genel durumunu (state) y\u00f6netmek. - Aray\u00fczden gelen sinyalleri i\u015fleyip Model katman\u0131na komut g\u00f6ndermek. - Model'den gelen g\u00fcncellemeleri al\u0131p aray\u00fcz\u00fcn yenilenmesini sa\u011flamak. - Hangi arac\u0131n aktif oldu\u011funu y\u00f6netmek ve kullan\u0131c\u0131 etkile\u015fim modlar\u0131n\u0131 de\u011fi\u015ftirmek. 4.2. G\u00f6r\u00fcn\u00fcm Katman\u0131 (View) T\u00fcm PyQt widget'lar\u0131 ve pencerelerinden olu\u015fur. - Sorumluluklar: - G\u00f6rsel elemanlar\u0131 ekranda \u00e7izmek. - Kullan\u0131c\u0131 girdilerini (t\u0131klama, s\u00fcr\u00fckleme vb.) sinyallere d\u00f6n\u00fc\u015ft\u00fcrmek. - Controller'dan gelen veriyle 3D sahneyi ve di\u011fer aray\u00fcz elemanlar\u0131n\u0131 g\u00fcncellemek. 4.3. Model Katman\u0131 Veri yap\u0131lar\u0131 ve bu veriler \u00fczerinde \u00e7al\u0131\u015fan fonksiyon/s\u0131n\u0131f koleksiyonlar\u0131ndan olu\u015fur. - Sorumluluklar: - 3D geometriyi PolyData olarak saklamak. - Controller'dan gelen komutlara g\u00f6re 3D veri \u00fczerinde algoritmik i\u015flemler (kesme, d\u00f6nd\u00fcrme vb.) ger\u00e7ekle\u015ftirmek. - \u0130\u015flem sonucunda olu\u015fan yeni veri durumunu olu\u015fturmak. B\u00f6l\u00fcm 5: Veri Y\u00f6netimi Mimarisi 5.1. Ana Veri Yap\u0131s\u0131 Uygulama i\u00e7indeki t\u00fcm 3D geometrik veriler, VTK'n\u0131n PolyData nesnesi ile temsil edilir. Bu yap\u0131, bir 3D modeli olu\u015fturan noktalar\u0131, bu noktalar\u0131 birle\u015ftiren poligonlar\u0131 ve bu geometrik elemanlara atanm\u0131\u015f ek verileri (renk, normal vekt\u00f6rleri vb.) bir arada tutar. 5.2. Durum Y\u00f6netimi (State Management) Uygulaman\u0131n kararl\u0131l\u0131\u011f\u0131 ve geri alma (Undo) gibi \u00f6zelliklerin \u00e7al\u0131\u015fabilmesi i\u00e7in merkezi ve reaktif bir durum y\u00f6netimi benimsenmi\u015ftir. Controller, uygulaman\u0131n t\u00fcm ge\u00e7mi\u015fini ve mevcut durumunu y\u00f6netir. - Orijinal Veri: Y\u00fcklenen 3D modelin de\u011fi\u015ftirilmemi\u015f bir kopyas\u0131 her zaman saklan\u0131r. - Aktif Veri: Ekranda g\u00f6sterilen ve \u00fczerinde anl\u0131k olarak \u00e7al\u0131\u015f\u0131lan model verisi. - \u0130\u015flem Y\u0131\u011f\u0131n\u0131 (Undo/Redo Stack): Kullan\u0131c\u0131n\u0131n yapt\u0131\u011f\u0131 her geri al\u0131nabilir de\u011fi\u015fiklik, bir i\u015flem olarak y\u0131\u011f\u0131na eklenir. Geri alma istendi\u011finde, y\u0131\u011f\u0131ndan son i\u015flem \u00e7\u0131kar\u0131l\u0131r ve \u00f6nceki duruma d\u00f6n\u00fcl\u00fcr. Bu yap\u0131, veri tutarl\u0131l\u0131\u011f\u0131n\u0131 garanti eder. B\u00f6l\u00fcm 6: \u00c7ekirdek Fonksiyonlar\u0131n Mant\u0131ksal Ak\u0131\u015f\u0131 6.1. Fonksiyon: Tarama Temizleme Ama\u00e7: Kullan\u0131c\u0131n\u0131n 2D bir se\u00e7imle 3D modelin istenmeyen k\u0131s\u0131mlar\u0131n\u0131 silmesi. Mant\u0131ksal Ak\u0131\u015f: Kullan\u0131c\u0131, 2D ekranda bir alan se\u00e7er. Sistem, bu 2D alan\u0131 3D uzayda bir se\u00e7im hacmine (frustum) d\u00f6n\u00fc\u015ft\u00fcr\u00fcr. Bu hacmin i\u00e7inde veya d\u0131\u015f\u0131nda kalan t\u00fcm 3D geometri, modelden \u00e7\u0131kar\u0131l\u0131r. Modelin temizlenmi\u015f hali, yeni \"Aktif Veri\" olarak ayarlan\u0131r. 6.2. Fonksiyon: Anatomik Hizalama Ama\u00e7: Modeli, standart bir anatomik koordinat sistemine g\u00f6re yeniden y\u00f6nlendirmek. Mant\u0131ksal Ak\u0131\u015f: Kullan\u0131c\u0131, model \u00fczerinde stratejik anatomik referans noktalar\u0131 i\u015faretler. Sistem, bu noktalardan yola \u00e7\u0131karak yeni bir koordinat sistemi (yeni X, Y, Z eksenleri) hesaplar. Modelin mevcut koordinat sisteminden bu yeni sisteme ge\u00e7i\u015fini sa\u011flayacak bir rotasyon matrisi olu\u015fturulur. T\u00fcm model, bu matris kullan\u0131larak d\u00f6nd\u00fcr\u00fcl\u00fcr ve hizalanm\u0131\u015f olur. 6.3. Fonksiyon: Hacimsel Deformasyon Ama\u00e7: Modelin belirli b\u00f6lgelerinde, \u00f6l\u00e7\u00fcleri hassas bir \u015fekilde art\u0131r\u0131p azaltmak (rektifikasyon). Mant\u0131ksal Ak\u0131\u015f: Kullan\u0131c\u0131, model \u00fczerinde \u00e7al\u0131\u015fmak istedi\u011fi bir b\u00f6lgeyi ve etki alan\u0131n\u0131 tan\u0131mlar (\u00f6rn: bir \"kesit band\u0131\" ile). Sistem, bu etki alan\u0131ndaki t\u00fcm 3D noktalar\u0131 belirler. Kullan\u0131c\u0131 bir deformasyon de\u011feri (+/- mm) girdi\u011finde, sistem bu b\u00f6lgedeki noktalar\u0131, b\u00f6lgenin merkezinden uza\u011fa veya merkeze do\u011fru, belirlenen miktar kadar kayd\u0131r\u0131r. Bu kayd\u0131rma i\u015flemi, yumu\u015fak ve organik bir ge\u00e7i\u015f sa\u011flamak i\u00e7in etki alan\u0131n\u0131n kenarlar\u0131na do\u011fru azal\u0131r. B\u00f6l\u00fcm 7: Kullan\u0131c\u0131 Etkile\u015fim Tasar\u0131m\u0131 7.1. Mod\u00fcler Etkile\u015fim Stilleri Uygulama, farkl\u0131 g\u00f6revler i\u00e7in farkl\u0131 fare ve klavye davran\u0131\u015flar\u0131 gerektirir. Bu, monolitik bir yap\u0131 yerine, \"Etkile\u015fim Stilleri\" ad\u0131 verilen de\u011fi\u015ftirilebilir mod\u00fcllerle y\u00f6netilir. - Kamera Stili: Varsay\u0131lan mod. Sahneyi d\u00f6nd\u00fcrme, kayd\u0131rma. - Se\u00e7im Stili: Temizleme arac\u0131 aktifken, 2D alan se\u00e7imi yapmay\u0131 sa\u011flar. - \u0130\u015faretleme Stili: Hizalama arac\u0131 aktifken, model \u00fczerinde 3D nokta se\u00e7meyi sa\u011flar. Controller, kullan\u0131c\u0131n\u0131n se\u00e7ti\u011fi araca g\u00f6re bu stiller aras\u0131nda dinamik olarak ge\u00e7i\u015f yapar. 7.2. \u0130leti\u015fim Desenleri Sinyal/Slot (View -> Controller): Aray\u00fczden gelen kullan\u0131c\u0131 eylemlerini Controller'a bildirmek i\u00e7in kullan\u0131l\u0131r. Bu, aray\u00fcz\u00fcn i\u015f mant\u0131\u011f\u0131ndan tamamen habersiz olmas\u0131n\u0131 sa\u011flar. G\u00f6zlemci Deseni (Model/VTK -> Controller): 3D sahnedeki olaylar\u0131 (fare t\u0131klamas\u0131 vb.) yakalamak i\u00e7in kullan\u0131l\u0131r. Controller, 3D motorundaki olaylar\u0131 \"dinler\" ve bunlara tepki verir. B\u00f6l\u00fcm 8: Gelecek Geli\u015ftirmeler i\u00e7in Mimari Haz\u0131rl\u0131k Mevcut MVC mimarisi, gelecekte eklenecek yeni \u00f6zellikler i\u00e7in sa\u011flam ve geni\u015fletilebilir bir temel sunmaktad\u0131r. - Yapay Zeka Entegrasyonu: E\u011fitilmi\u015f bir model, \"Model\" katman\u0131na yeni bir algoritma olarak kolayca eklenebilir ve Controller taraf\u0131ndan \u00e7a\u011fr\u0131labilir. \u00d6rne\u011fin, anatomik noktalar\u0131 otomatik bulan bir yapay zeka mod\u00fcl\u00fc. - Bas\u0131n\u00e7 Analizi (FEA): Bir sonlu elemanlar analizi \u00e7\u00f6z\u00fcc\u00fcs\u00fc, yine \"Model\" katman\u0131nda, deforme edilmi\u015f bir geometriyi girdi olarak al\u0131p bir bas\u0131n\u00e7 haritas\u0131 \u00fcreten bir fonksiyon olarak entegre edilebilir. - Proje Kaydetme/Y\u00fckleme: Controller, \"Durum Y\u00f6netimi\" b\u00f6l\u00fcm\u00fcnde tan\u0131mlanan t\u00fcm durumu (aktif veri, bant parametreleri vb.) tek bir dosyaya serile\u015ftirip (serialize) daha sonra bu dosyadan durumu geri y\u00fckleyebilir. Mimari bu \u00f6zelli\u011fe tamamen haz\u0131rd\u0131r. 9. Modifikasyon Ara\u00e7lar\u0131 Mimarisi (Rectification Tools Architecture) Bu b\u00f6l\u00fcm, protez soketinin dijital olarak \u015fekillendirildi\u011fi, klinik olarak en \u00f6nemli ad\u0131mlar\u0131 i\u00e7eren ara\u00e7 setinin mimarisini tan\u0131mlar. Bu ara\u00e7lar, kullan\u0131c\u0131n\u0131n ad\u0131m ad\u0131m ilerledi\u011fi bir i\u015f ak\u0131\u015f\u0131 ( workflow ) i\u00e7inde sunulur. T\u00fcm modifikasyon ara\u00e7lar\u0131, merkezi bir ModificationEngine taraf\u0131ndan y\u00f6netilir ve ayn\u0131 temel prensipleri payla\u015f\u0131r: - Tahribats\u0131z \u0130\u015flem: T\u00fcm modifikasyonlar, active_poly_data \u00fczerinde yap\u0131l\u0131r ve HistoryStack 'e kaydedilir. - Merkezi Kontrol: MainWindow (Controller), hangi arac\u0131n aktif oldu\u011funu, arac\u0131n parametrelerini (f\u0131r\u00e7a boyutu, azaltma y\u00fczdesi vb.) ve Aray\u00fcz ile Ara\u00e7lar (Model) katman\u0131 aras\u0131ndaki veri ak\u0131\u015f\u0131n\u0131 y\u00f6netir. - Mod\u00fcler Ara\u00e7 Tasar\u0131m\u0131: Her bir modifikasyon arac\u0131 ( R\u00e9duction , Lissage vb.), tools klas\u00f6r\u00fcnde kendi s\u0131n\u0131f\u0131na sahip olacak \u015fekilde tasarlanacakt\u0131r. 9.1. Ara\u00e7 1: R\u00e9duction (Hacim Azaltma) Ama\u00e7: Protez soketinin genel hacmini k\u00fc\u00e7\u00fclterek veya belirli b\u00f6lgelerde lokal bask\u0131 olu\u015fturarak daha s\u0131k\u0131 bir uyum (fit) sa\u011flamak. Aray\u00fcz Bile\u015fenleri (View): \"Global Azaltma\" ve \"Lokal Azaltma\" modlar\u0131n\u0131 se\u00e7mek i\u00e7in QRadioButton veya QPushButton grubu. Global azaltma i\u00e7in y\u00fczde (%) de\u011ferinin girilece\u011fi bir QSlider veya QSpinBox . Lokal azaltma i\u00e7in f\u0131r\u00e7a boyutunu ve etki g\u00fcc\u00fcn\u00fc ayarlayan QSlider 'lar. Kontrol Mant\u0131\u011f\u0131 ( MainWindow ): current_mode 'u 'REDUCTION_GLOBAL' veya 'REDUCTION_LOCAL' olarak ayarlar. Slider'lardan gelen y\u00fczde veya f\u0131r\u00e7a parametrelerini yakalar. Global modda \"Uygula\" butonuna bas\u0131ld\u0131\u011f\u0131nda veya lokal modda fare s\u00fcr\u00fcklenirken ReductionTool \u00fczerindeki ilgili metotlar\u0131 \u00e7a\u011f\u0131r\u0131r. Ara\u00e7 Tasar\u0131m\u0131 ( tools/ReductionTool.py ): ```python class ReductionTool: def apply_global_reduction(self, poly_data, percentage): # 1. Modelin a\u011f\u0131rl\u0131k merkezini (centroid) hesapla. # 2. 'vtkTransform' kullanarak modeli merkeze do\u011fru 'percentage' oran\u0131nda \u00f6l\u00e7ekle. # 3. De\u011fi\u015ftirilmi\u015f poly_data'y\u0131 geri d\u00f6nd\u00fcr. ... def apply_local_reduction(self, poly_data, brush_center, radius, strength): # 1. F\u0131r\u00e7a merkezine 'radius' mesafesindeki noktalar\u0131 (vertices) bul. # 2. Her bir nokta i\u00e7in, kendi normal vekt\u00f6r\u00fc y\u00f6n\u00fcnde i\u00e7eri do\u011fru hareket ettir. # 3. Hareket mesafesi, 'strength' ve merkeze olan uzakl\u0131\u011fa g\u00f6re (falloff) belirlenir. ... ``` 9.2. Ara\u00e7 2: Creuser / Recharger (Oyma / Ekleme - Sculpting) Ama\u00e7: Serbest formda, hassas b\u00f6lgelerdeki (\u00f6rn: kemik \u00e7\u0131k\u0131nt\u0131lar\u0131) bas\u0131nc\u0131 azaltmak i\u00e7in materyal oymak (Creuser) veya zay\u0131f doku alanlar\u0131n\u0131 desteklemek i\u00e7in materyal eklemek (Recharger). Aray\u00fcz Bile\u015fenleri (View): \"Oy\" (Dig) ve \"Ekle\" (Bulge) modlar\u0131 aras\u0131nda ge\u00e7i\u015f yapan butonlar. F\u0131r\u00e7a Boyutu ve Etki G\u00fcc\u00fc i\u00e7in QSlider 'lar. Fare imlecinin model \u00fczerindeki izd\u00fc\u015f\u00fcm\u00fcn\u00fc g\u00f6steren anl\u0131k bir f\u0131r\u00e7a g\u00f6stergesi. Kontrol Mant\u0131\u011f\u0131 ( MainWindow ): Aktif f\u0131r\u00e7a modunu ( 'DIG' veya 'BULGE' ) ve f\u0131r\u00e7a parametrelerini SculptingTool 'a iletir. Fare model \u00fczerinde s\u00fcr\u00fcklendi\u011fi s\u00fcrece, mouseMoveEvent olay\u0131ndan elde edilen 3D koordinatlar\u0131 anl\u0131k olarak SculptingTool 'a g\u00f6nderir. Ara\u00e7 Tasar\u0131m\u0131 ( tools/SculptingTool.py ): python class SculptingTool: def deform(self, poly_data, brush_center, radius, strength, mode): # 1. F\u0131r\u00e7a etki alan\u0131ndaki noktalar\u0131 bul. # 2. Her nokta i\u00e7in, normal vekt\u00f6r\u00fcn\u00fc al. # 3. if mode == 'BULGE': Noktay\u0131 normal y\u00f6n\u00fcnde d\u0131\u015far\u0131 ta\u015f\u0131. # 4. if mode == 'DIG': Noktay\u0131 normal y\u00f6n\u00fcnde i\u00e7eri ta\u015f\u0131. # 5. Ta\u015f\u0131ma miktar\u0131n\u0131 'strength' ve yumu\u015fak bir ge\u00e7i\u015f i\u00e7in 'falloff' fonksiyonu ile ayarla. ... 9.3. Ara\u00e7 3: Lissage (Yumu\u015fatma) Ama\u00e7: \u00d6nceki ad\u0131mlarda olu\u015fan p\u00fcr\u00fczl\u00fc veya keskin y\u00fczeyleri yumu\u015fatarak daha p\u00fcr\u00fczs\u00fcz ve konforlu bir i\u00e7 y\u00fczey elde etmek. Aray\u00fcz Bile\u015fenleri (View): F\u0131r\u00e7a Boyutu ve Yumu\u015fatma Miktar\u0131 i\u00e7in QSlider 'lar. Kontrol Mant\u0131\u011f\u0131 ( MainWindow ): SculptingTool 'a benzer \u015fekilde, fare hareketlerini SmoothingTool 'a y\u00f6nlendirir. Ara\u00e7 Tasar\u0131m\u0131 ( tools/SmoothingTool.py ): ```python class SmoothingTool: def init (self): # VTK'n\u0131n yerle\u015fik yumu\u015fatma filtresi kullan\u0131l\u0131r. self.smoother = vtk.vtkSmoothPolyDataFilter() def smooth_area(self, poly_data, brush_center, radius, iterations): # 1. F\u0131r\u00e7a alan\u0131ndaki noktalar\u0131 belirle. # 2. Yaln\u0131zca bu noktalar\u0131 etkileyecek \u015fekilde 'vtkSmoothPolyDataFilter'\u0131 \u00e7al\u0131\u015ft\u0131r. # 3. 'iterations' (d\u00f6ng\u00fc say\u0131s\u0131), aray\u00fczdeki yumu\u015fatma miktar\u0131na ba\u011flan\u0131r. ... ``` Protez Soketi Modifikasyon Ara\u00e7lar\u0131 \u00c9paisseur (Kal\u0131nl\u0131k) Ama\u00e7: Protez soketinin \u00fcretim i\u00e7in gerekli olan duvar kal\u0131nl\u0131\u011f\u0131n\u0131 ayarlamak. Genellikle t\u00fcm sokete tek tip bir kal\u0131nl\u0131k uygulan\u0131r. Teknoloji: - vtkPolyDataNormals ile normal vekt\u00f6rleri hesaplan\u0131r. - Noktalar, normal y\u00f6nleri boyunca belirli bir mesafede kayd\u0131r\u0131larak yeni bir d\u0131\u015f y\u00fczey olu\u015fturulur. - vtkBooleanOperationPolyDataFilter ile i\u00e7 ve d\u0131\u015f y\u00fczey birle\u015ftirilebilir. \u00c9vas\u00e9s (Kenar \u015eekillendirme / Flare) Ama\u00e7: Protez soketinin \u00fcst kenarlar\u0131n\u0131, hastan\u0131n uzvuna daha iyi oturacak ve kenar tahri\u015fini \u00f6nleyecek \u015fekilde i\u00e7eri veya d\u0131\u015far\u0131 do\u011fru \u015fekillendirmek. G\u00f6r\u00fcnt\u00fcdeki renk \u00e7ark\u0131, b\u00f6lgesel kontrol\u00fcn \u00f6nemini vurgular. Teknoloji: - Soketin \u00fcst kenar\u0131ndaki poligon halkalar\u0131 (edge loops) se\u00e7ilir. - Bu halkalar\u0131n noktalar\u0131, y\u00fczey normali veya kenar normali boyunca, b\u00f6lgesel olarak belirlenen miktarlarda hareket ettirilir. - Ge\u00e7i\u015fleri yumu\u015fatmak i\u00e7in vtkSmoothPolyDataFilter veya \u00f6zel deformasyon algoritmalar\u0131 kullan\u0131labilir. Prise Distale (Distal Tutu\u015f / Aray\u00fcz) Ama\u00e7: Ampute uzvun distal ucu ile protez soketi aras\u0131ndaki ba\u011flant\u0131 noktas\u0131n\u0131 \u015fekillendirmek ve buraya uygun ba\u011flant\u0131 elemanlar\u0131n\u0131 (adapt\u00f6r, kilit mekanizmas\u0131) dijital olarak yerle\u015ftirmek. Teknoloji: - Distal u\u00e7 b\u00f6lgesinde \u00f6zel bir deformasyon ve/veya kesme i\u015flemi yap\u0131l\u0131r. - Kullan\u0131c\u0131, STL format\u0131nda \u00f6nceden y\u00fcklenmi\u015f distal ba\u011flant\u0131 eleman\u0131 modellerinden birini se\u00e7ebilir ve bunu soketin distal ucuna yerle\u015ftirebilir. - Konumland\u0131rma ve y\u00f6nlendirme i\u00e7in vtkTransformWidget gibi manip\u00fclat\u00f6rler kullan\u0131l\u0131r. Alignement (Hizalama) Ama\u00e7: Protez soketinin, t\u00fcm protez sisteminin (diz eklemi, ayak, pelvik b\u00f6lge) anatomik ve biyomekanik olarak do\u011fru hizalanmas\u0131n\u0131 sa\u011flamak. Teknoloji: - vtkAssembly veya vtkProp ile sanal bir hizalama stand\u0131 olu\u015fturulur. - Soket, diz eklemi ve ayak gibi bile\u015fenler bu stand \u00fczerinde konumland\u0131r\u0131l\u0131r. - Kullan\u0131c\u0131, rotasyon (\u00f6n-arka, i\u00e7-d\u0131\u015f) ve translasyon (y\u00fckseklik, yanlara kayd\u0131rma) ayarlamalar\u0131 yapabilir. - vtkTransform ve vtkMatrix4x4 bu d\u00f6n\u00fc\u015f\u00fcmleri y\u00f6netir. Finalisation (Sonland\u0131rma) Ama\u00e7: T\u00fcm modelleme ve rektifikasyon ad\u0131mlar\u0131 tamamland\u0131ktan sonra, protez kal\u0131b\u0131n\u0131 \u00fcretime haz\u0131r hale getirmek ve \u00e7\u0131kt\u0131 almak. Teknoloji: - Model Do\u011frulama: Son vtkPolyData \u00fczerinde topolojik kontroller (delik kontrol\u00fc, kesi\u015fen \u00fc\u00e7genler). - D\u0131\u015fa Aktarma: vtkSTLWriter ile nihai model STL format\u0131nda kaydedilir. -","title":"Yaz\u0131l\u0131m Tasar\u0131m Dok\u00fcman\u0131"},{"location":"document/#yazlm-tasarm-dokuman-clonify-labs","text":"Proje Ad\u0131 Medikal Sekt\u00f6rde 3 Boyutlu Tarama ile Ki\u015fiye \u00d6zel H\u0131zl\u0131 Kal\u0131p \u00dcretimi \u00dcr\u00fcn Ad\u0131 Clonify Labs Modelleme Yaz\u0131l\u0131m\u0131 Versiyon 2.0 (Planlanan) Tarih 08.08.2025 \u015eirket Clonify Labs","title":"Yaz\u0131l\u0131m Tasar\u0131m Dok\u00fcman\u0131: Clonify Labs"},{"location":"document/#icindekiler","text":"Giri\u015f 1.1. Dok\u00fcman\u0131n Amac\u0131 1.2. Projenin Kapsam\u0131 1.3. Tan\u0131mlar ve K\u0131saltmalar Sistem Mimarisi 2.1. Mimari Yakla\u015f\u0131m: Katmanl\u0131 Mimari 2.2. Katmanlar\u0131n Detayl\u0131 Analizi 2.3. Mimari \u015eemas\u0131 ve Veri Ak\u0131\u015f\u0131 Kullan\u0131lan Teknolojiler ve K\u00fct\u00fcphaneler Ana Bile\u015fenlerin Tasar\u0131m\u0131 ve Sorumluluklar\u0131 4.1. Kontrol Katman\u0131: MainWindow 4.2. Aray\u00fcz Katman\u0131: ui Mod\u00fclleri 4.3. Ara\u00e7 Katman\u0131: tools Mod\u00fclleri","title":"\u0130\u00e7indekiler"},{"location":"document/#bolum-1-giris","text":"","title":"B\u00f6l\u00fcm 1: Giri\u015f"},{"location":"document/#11-dokumann-amac","text":"Bu dok\u00fcman\u0131n temel amac\u0131, QClonifyCad yaz\u0131l\u0131m\u0131n\u0131n teknik mimarisini, tasar\u0131m kararlar\u0131n\u0131, temel bile\u015fenlerini ve bu bile\u015fenler aras\u0131ndaki etkile\u015fimi detayl\u0131 bir \u015fekilde a\u00e7\u0131klamakt\u0131r. Bu belge, projenin mevcut ve gelecekteki geli\u015ftiricileri i\u00e7in bir referans kayna\u011f\u0131 olarak hizmet edecek, kodun s\u00fcrd\u00fcr\u00fclebilirli\u011fini ve geni\u015fletilebilirli\u011fini sa\u011flamak i\u00e7in bir yol haritas\u0131 sunacakt\u0131r.","title":"1.1. Dok\u00fcman\u0131n Amac\u0131"},{"location":"document/#12-projenin-kapsam","text":"Bu dok\u00fcman, yaz\u0131l\u0131m\u0131n a\u015fa\u011f\u0131daki \u00e7ekirdek i\u015flevselliklerini ve planlanan mod\u00fcllerini kapsar: - Mevcut \u00d6zellikler: - STL format\u0131nda 3D model y\u00fckleme ve g\u00f6rselle\u015ftirme. - \u00c7oklu pencerede (multi-view) anatomik hizalama. - 2D se\u00e7imle 3D g\u00fcr\u00fclt\u00fc temizleme. - Planlanan \u00d6zellikler: - Model y\u00fczeyindeki deliklerin otomatik doldurulmas\u0131. - Etkile\u015fimli kesit bantlar\u0131 ile radyal deformasyon. - \"Bulge/Smooth\" f\u0131r\u00e7alar\u0131 ile serbest form modelleme. - Geri Al/\u0130leri Al (Undo/Redo) yetene\u011fi.","title":"1.2. Projenin Kapsam\u0131"},{"location":"document/#13-tanmlar-ve-ksaltmalar","text":"GUI: Grafiksel Kullan\u0131c\u0131 Aray\u00fcz\u00fc (Graphical User Interface) VTK: The Visualization Toolkit STL: Stereolithography (3D dosya format\u0131) PolyData: VTK'da poligon a\u011f\u0131n\u0131 (noktalar, h\u00fccreler) temsil eden temel veri yap\u0131s\u0131. Pipeline: Veri ak\u0131\u015f hatt\u0131. VTK'da verinin bir dizi filtreden ge\u00e7erek i\u015flenmesi. Frustum: Kesik piramit. 3D'de bir kamera g\u00f6r\u00fc\u015f alan\u0131n\u0131 tan\u0131mlayan geometrik hacim.","title":"1.3. Tan\u0131mlar ve K\u0131saltmalar"},{"location":"document/#bolum-2-sistem-mimarisi","text":"","title":"B\u00f6l\u00fcm 2: Sistem Mimarisi"},{"location":"document/#21-mimari-yaklasm-katmanl-mimari","text":"Yaz\u0131l\u0131m, kodun y\u00f6netilebilirli\u011fini ve mod\u00fclerli\u011fini sa\u011flamak amac\u0131yla, g\u00f6revleri net bir \u015fekilde ayr\u0131\u015ft\u0131ran \u00fc\u00e7 katmanl\u0131 bir mimari \u00fczerine in\u015fa edilmi\u015ftir. Bu yap\u0131, Model-View-Controller (MVC) tasar\u0131m deseninden g\u00fc\u00e7l\u00fc bir \u015fekilde ilham alm\u0131\u015ft\u0131r.","title":"2.1. Mimari Yakla\u015f\u0131m: Katmanl\u0131 Mimari"},{"location":"document/#22-katmanlarn-detayl-analizi","text":"Aray\u00fcz Katman\u0131 (View): PyQt5 ile olu\u015fturulmu\u015ftur. Sadece g\u00f6rsel elemanlar\u0131 bar\u0131nd\u0131r\u0131r ve kullan\u0131c\u0131 etkile\u015fimlerini sinyallere d\u00f6n\u00fc\u015ft\u00fcr\u00fcr. main.py 'deki veriyi g\u00f6rselle\u015ftirir ancak kendi i\u00e7inde mant\u0131k veya durum bar\u0131nd\u0131rmaz. Kontrol/Mant\u0131k Katman\u0131 (Controller): main.py dosyas\u0131ndaki MainWindow s\u0131n\u0131f\u0131d\u0131r. Uygulaman\u0131n beyni olarak \u00e7al\u0131\u015f\u0131r. Aray\u00fczden gelen sinyalleri i\u015fler, uygulama durumunu ( state ) y\u00f6netir ve 3D Ara\u00e7lar katman\u0131na komutlar g\u00f6nderir. 3D \u00c7ekirdek ve Ara\u00e7lar Katman\u0131 (Model): VTK ve tools klas\u00f6r\u00fcndeki s\u0131n\u0131flardan olu\u015fur. T\u00fcm 3D veri i\u015fleme, filtreleme ve karma\u015f\u0131k etkile\u015fim mant\u0131\u011f\u0131 bu katmanda yer al\u0131r. Bu katmandaki ara\u00e7lar, Kontrol Katman\u0131'ndan ba\u011f\u0131ms\u0131z, yeniden kullan\u0131labilir bile\u015fenlerdir.","title":"2.2. Katmanlar\u0131n Detayl\u0131 Analizi"},{"location":"document/#bolum-3-kullanlan-teknolojiler-ve-kutuphaneler","text":"Projenin geli\u015ftirilmesinde, a\u00e7\u0131k kaynak kodlu, end\u00fcstri standard\u0131, y\u00fcksek performansl\u0131 ve geni\u015f topluluk deste\u011fine sahip teknolojiler tercih edilmi\u015ftir. Bu se\u00e7imler, projenin hem h\u0131zl\u0131 bir \u015fekilde geli\u015ftirilmesini hem de gelecekteki bak\u0131m ve geni\u015fletme s\u00fcre\u00e7lerinin verimli olmas\u0131n\u0131 sa\u011flamay\u0131 ama\u00e7lamaktad\u0131r.","title":"B\u00f6l\u00fcm 3: Kullan\u0131lan Teknolojiler ve K\u00fct\u00fcphaneler"},{"location":"document/#31-ana-programlama-dili-python-3x","text":"Python, h\u0131zl\u0131 prototipleme yetene\u011fi, temiz ve okunabilir s\u00f6zdizimi (syntax) ve zengin standart k\u00fct\u00fcphanesi sayesinde projenin ana geli\u015ftirme dili olarak se\u00e7ilmi\u015ftir. \u00d6zellikle bilimsel hesaplama, veri analizi ve yapay zeka alanlar\u0131ndaki g\u00fcc\u00fc, projenin medikal veri i\u015fleme do\u011fas\u0131yla m\u00fckemmel bir \u015fekilde \u00f6rt\u00fc\u015fmektedir. Python'un \"glue language\" (yap\u0131\u015ft\u0131r\u0131c\u0131 dil) \u00f6zelli\u011fi, C++ gibi y\u00fcksek performansl\u0131 dillerle yaz\u0131lm\u0131\u015f VTK gibi k\u00fct\u00fcphanelerin kolayca entegre edilmesini sa\u011flam\u0131\u015ft\u0131r.","title":"3.1. Ana Programlama Dili: Python 3.x"},{"location":"document/#32-grafiksel-kullanc-arayuzu-gui-pyqt5","text":"PyQt5, platformdan ba\u011f\u0131ms\u0131z (Windows, macOS, Linux) masa\u00fcst\u00fc uygulamalar\u0131 geli\u015ftirmek i\u00e7in kullan\u0131lan, end\u00fcstri standard\u0131 Qt C++ k\u00fct\u00fcphanesinin Python versiyonudur. - Se\u00e7im nedenleri \u015funlard\u0131r: - Olgunluk ve Kararl\u0131l\u0131k: Qt, y\u0131llard\u0131r geli\u015ftirilen, son derece kararl\u0131 ve g\u00fcvenilir bir aray\u00fcz \u00e7at\u0131s\u0131d\u0131r. - Sinyal ve Slot Mekanizmas\u0131: Aray\u00fcz elemanlar\u0131 (View) ile program mant\u0131\u011f\u0131 (Controller) aras\u0131nda esnek, g\u00fcvenli ve ayr\u0131\u015ft\u0131r\u0131lm\u0131\u015f (decoupled) bir ileti\u015fim sa\u011flar. Bu, mimarimizin temel ta\u015flar\u0131ndan biridir. - Geni\u015f Widget Seti: Butonlar, listeler, paneller, men\u00fcler ve QDockWidget gibi geli\u015fmi\u015f yerle\u015fim ara\u00e7lar\u0131, karma\u015f\u0131k ve profesyonel bir kullan\u0131c\u0131 aray\u00fcz\u00fcn\u00fcn h\u0131zl\u0131ca olu\u015fturulmas\u0131na olanak tan\u0131r. - VTK Entegrasyonu: QVTKRenderWindowInteractor widget'\u0131 sayesinde, VTK'n\u0131n y\u00fcksek performansl\u0131 3D render pencerelerinin bir Qt uygulamas\u0131 i\u00e7ine sorunsuz bir \u015fekilde g\u00f6m\u00fclmesini ve olay d\u00f6ng\u00fclerinin (event loop) entegre \u00e7al\u0131\u015fmas\u0131n\u0131 sa\u011flar.","title":"3.2. Grafiksel Kullan\u0131c\u0131 Aray\u00fcz\u00fc (GUI): PyQt5"},{"location":"document/#33-3d-gorsellestirme-ve-isleme-motoru","text":"VTK (The Visualization Toolkit) VTK, bilimsel ve medikal verilerin 3 boyutlu olarak i\u015flenmesi, g\u00f6rselle\u015ftirilmesi ve analizi i\u00e7in tasarlanm\u0131\u015f, C++ tabanl\u0131, y\u00fcksek performansl\u0131 bir k\u00fct\u00fcphanedir. Projenin 3D ile ilgili t\u00fcm a\u011f\u0131r i\u015flerini VTK \u00fcstlenir. - Veri Ak\u0131\u015f Hatt\u0131 Mimarisi (Pipeline Architecture): VTK'n\u0131n temel g\u00fcc\u00fc, Source -> Filter -> Mapper -> Actor \u015feklindeki veri ak\u0131\u015f modelidir. Bu yap\u0131, karma\u015f\u0131k 3D veri i\u015fleme zincirlerinin mod\u00fcler ve verimli bir \u015fekilde olu\u015fturulmas\u0131n\u0131 sa\u011flar. Bellek y\u00f6netimi ve g\u00fcncellemeler bu pipeline \u00fczerinden otomatik olarak y\u00f6netilir. - Zengin Filtre K\u00fct\u00fcphanesi: Projemizde aktif olarak kulland\u0131\u011f\u0131m\u0131z vtkClipPolyData (kesme), vtkTransformPolyDataFilter (d\u00f6nd\u00fcrme/ta\u015f\u0131ma) ve vtkSTLReader gibi y\u00fczlerce haz\u0131r algoritma i\u00e7erir. Gelecekteki mod\u00fcller i\u00e7in vtkFillHolesFilter, vtkSmoothPolyDataFilter gibi filtreler de kullan\u0131lacakt\u0131r. - Geli\u015fmi\u015f Etkile\u015fim Mekanizmalar\u0131: vtkRenderWindowInteractor ve vtkInteractorStyle alt s\u0131n\u0131flar\u0131, fare ve klavye ile 3D sahne \u00fczerinde, sadece kamera kontrol\u00fc de\u011fil, ayn\u0131 zamanda nesne se\u00e7imi (vtkPointPicker), alan \u00e7izimi (vtkInteractorStyleRubberBand2D) ve \u00f6zel ara\u00e7 davran\u0131\u015flar\u0131 gibi karma\u015f\u0131k etkile\u015fimler olu\u015fturmak i\u00e7in g\u00fc\u00e7l\u00fc bir altyap\u0131 sunar.","title":"3.3. 3D G\u00f6rselle\u015ftirme ve \u0130\u015fleme Motoru:**"},{"location":"document/#34-matematiksel-ve-bilimsel-hesaplama","text":"NumPy NumPy, Python'da bilimsel hesaplamalar i\u00e7in temel pakettir. \u00d6zellikle \u00e7ok boyutlu diziler (array) \u00fczerinde y\u00fcksek performansl\u0131 matematiksel i\u015flemler i\u00e7in kullan\u0131l\u0131r. - Performans: Vekt\u00f6r ve matris gibi veri yap\u0131lar\u0131 \u00fczerinde yap\u0131lan i\u015flemler, derlenmi\u015f C koduna yak\u0131n bir h\u0131zda ger\u00e7ekle\u015ftirilir. Bu, binlerce noktadan olu\u015fan 3D modellerin deformasyonu gibi hesaplama-yo\u011fun i\u015flemlerde kritik \u00f6neme sahiptir. - Vekt\u00f6r Matemati\u011fi: Anatomik hizalama algoritmas\u0131nda, normal vekt\u00f6rlerin ve eksenlerin hesaplanmas\u0131 i\u00e7in np.cross (\u00e7apraz \u00e7arp\u0131m) ve np.linalg.norm (vekt\u00f6r uzunlu\u011fu) gibi fonksiyonlar vazge\u00e7ilmezdir. - VTK Uyumlulu\u011fu: vtk.util.numpy_support mod\u00fcl\u00fc, NumPy dizileri ile VTK'n\u0131n kendi veri dizileri aras\u0131nda s\u0131f\u0131r-kopya (zero-copy) veya minimum-kopya ile veri al\u0131\u015fveri\u015fi yap\u0131lmas\u0131n\u0131 sa\u011flar. Bu, on binlerce noktan\u0131n koordinatlar\u0131n\u0131 Python'da i\u015fleyip tekrar VTK'ya verimli bir \u015fekilde geri g\u00f6ndermemize olanak tan\u0131r.","title":"3.4. Matematiksel ve Bilimsel Hesaplama:**"},{"location":"document/#bolum-4-ana-bilesenlerin-tasarm-ve-sorumluluklar","text":"","title":"B\u00f6l\u00fcm 4: Ana Bile\u015fenlerin Tasar\u0131m\u0131 ve Sorumluluklar\u0131"},{"location":"document/#41-kontrol-katman-controller","text":"Uygulaman\u0131n ana pencere s\u0131n\u0131f\u0131 bu rol\u00fc \u00fcstlenir. - Sorumluluklar: - Uygulaman\u0131n genel durumunu (state) y\u00f6netmek. - Aray\u00fczden gelen sinyalleri i\u015fleyip Model katman\u0131na komut g\u00f6ndermek. - Model'den gelen g\u00fcncellemeleri al\u0131p aray\u00fcz\u00fcn yenilenmesini sa\u011flamak. - Hangi arac\u0131n aktif oldu\u011funu y\u00f6netmek ve kullan\u0131c\u0131 etkile\u015fim modlar\u0131n\u0131 de\u011fi\u015ftirmek.","title":"4.1. Kontrol Katman\u0131 (Controller)"},{"location":"document/#42-gorunum-katman-view","text":"T\u00fcm PyQt widget'lar\u0131 ve pencerelerinden olu\u015fur. - Sorumluluklar: - G\u00f6rsel elemanlar\u0131 ekranda \u00e7izmek. - Kullan\u0131c\u0131 girdilerini (t\u0131klama, s\u00fcr\u00fckleme vb.) sinyallere d\u00f6n\u00fc\u015ft\u00fcrmek. - Controller'dan gelen veriyle 3D sahneyi ve di\u011fer aray\u00fcz elemanlar\u0131n\u0131 g\u00fcncellemek.","title":"4.2. G\u00f6r\u00fcn\u00fcm Katman\u0131 (View)"},{"location":"document/#43-model-katman","text":"Veri yap\u0131lar\u0131 ve bu veriler \u00fczerinde \u00e7al\u0131\u015fan fonksiyon/s\u0131n\u0131f koleksiyonlar\u0131ndan olu\u015fur. - Sorumluluklar: - 3D geometriyi PolyData olarak saklamak. - Controller'dan gelen komutlara g\u00f6re 3D veri \u00fczerinde algoritmik i\u015flemler (kesme, d\u00f6nd\u00fcrme vb.) ger\u00e7ekle\u015ftirmek. - \u0130\u015flem sonucunda olu\u015fan yeni veri durumunu olu\u015fturmak.","title":"4.3. Model Katman\u0131"},{"location":"document/#bolum-5-veri-yonetimi-mimarisi","text":"","title":"B\u00f6l\u00fcm 5: Veri Y\u00f6netimi Mimarisi"},{"location":"document/#51-ana-veri-yaps","text":"Uygulama i\u00e7indeki t\u00fcm 3D geometrik veriler, VTK'n\u0131n PolyData nesnesi ile temsil edilir. Bu yap\u0131, bir 3D modeli olu\u015fturan noktalar\u0131, bu noktalar\u0131 birle\u015ftiren poligonlar\u0131 ve bu geometrik elemanlara atanm\u0131\u015f ek verileri (renk, normal vekt\u00f6rleri vb.) bir arada tutar.","title":"5.1. Ana Veri Yap\u0131s\u0131"},{"location":"document/#52-durum-yonetimi-state-management","text":"Uygulaman\u0131n kararl\u0131l\u0131\u011f\u0131 ve geri alma (Undo) gibi \u00f6zelliklerin \u00e7al\u0131\u015fabilmesi i\u00e7in merkezi ve reaktif bir durum y\u00f6netimi benimsenmi\u015ftir. Controller, uygulaman\u0131n t\u00fcm ge\u00e7mi\u015fini ve mevcut durumunu y\u00f6netir. - Orijinal Veri: Y\u00fcklenen 3D modelin de\u011fi\u015ftirilmemi\u015f bir kopyas\u0131 her zaman saklan\u0131r. - Aktif Veri: Ekranda g\u00f6sterilen ve \u00fczerinde anl\u0131k olarak \u00e7al\u0131\u015f\u0131lan model verisi. - \u0130\u015flem Y\u0131\u011f\u0131n\u0131 (Undo/Redo Stack): Kullan\u0131c\u0131n\u0131n yapt\u0131\u011f\u0131 her geri al\u0131nabilir de\u011fi\u015fiklik, bir i\u015flem olarak y\u0131\u011f\u0131na eklenir. Geri alma istendi\u011finde, y\u0131\u011f\u0131ndan son i\u015flem \u00e7\u0131kar\u0131l\u0131r ve \u00f6nceki duruma d\u00f6n\u00fcl\u00fcr. Bu yap\u0131, veri tutarl\u0131l\u0131\u011f\u0131n\u0131 garanti eder.","title":"5.2. Durum Y\u00f6netimi (State Management)"},{"location":"document/#bolum-6-cekirdek-fonksiyonlarn-mantksal-aks","text":"","title":"B\u00f6l\u00fcm 6: \u00c7ekirdek Fonksiyonlar\u0131n Mant\u0131ksal Ak\u0131\u015f\u0131"},{"location":"document/#61-fonksiyon-tarama-temizleme","text":"Ama\u00e7: Kullan\u0131c\u0131n\u0131n 2D bir se\u00e7imle 3D modelin istenmeyen k\u0131s\u0131mlar\u0131n\u0131 silmesi. Mant\u0131ksal Ak\u0131\u015f: Kullan\u0131c\u0131, 2D ekranda bir alan se\u00e7er. Sistem, bu 2D alan\u0131 3D uzayda bir se\u00e7im hacmine (frustum) d\u00f6n\u00fc\u015ft\u00fcr\u00fcr. Bu hacmin i\u00e7inde veya d\u0131\u015f\u0131nda kalan t\u00fcm 3D geometri, modelden \u00e7\u0131kar\u0131l\u0131r. Modelin temizlenmi\u015f hali, yeni \"Aktif Veri\" olarak ayarlan\u0131r.","title":"6.1. Fonksiyon: Tarama Temizleme"},{"location":"document/#62-fonksiyon-anatomik-hizalama","text":"Ama\u00e7: Modeli, standart bir anatomik koordinat sistemine g\u00f6re yeniden y\u00f6nlendirmek. Mant\u0131ksal Ak\u0131\u015f: Kullan\u0131c\u0131, model \u00fczerinde stratejik anatomik referans noktalar\u0131 i\u015faretler. Sistem, bu noktalardan yola \u00e7\u0131karak yeni bir koordinat sistemi (yeni X, Y, Z eksenleri) hesaplar. Modelin mevcut koordinat sisteminden bu yeni sisteme ge\u00e7i\u015fini sa\u011flayacak bir rotasyon matrisi olu\u015fturulur. T\u00fcm model, bu matris kullan\u0131larak d\u00f6nd\u00fcr\u00fcl\u00fcr ve hizalanm\u0131\u015f olur.","title":"6.2. Fonksiyon: Anatomik Hizalama"},{"location":"document/#63-fonksiyon-hacimsel-deformasyon","text":"Ama\u00e7: Modelin belirli b\u00f6lgelerinde, \u00f6l\u00e7\u00fcleri hassas bir \u015fekilde art\u0131r\u0131p azaltmak (rektifikasyon). Mant\u0131ksal Ak\u0131\u015f: Kullan\u0131c\u0131, model \u00fczerinde \u00e7al\u0131\u015fmak istedi\u011fi bir b\u00f6lgeyi ve etki alan\u0131n\u0131 tan\u0131mlar (\u00f6rn: bir \"kesit band\u0131\" ile). Sistem, bu etki alan\u0131ndaki t\u00fcm 3D noktalar\u0131 belirler. Kullan\u0131c\u0131 bir deformasyon de\u011feri (+/- mm) girdi\u011finde, sistem bu b\u00f6lgedeki noktalar\u0131, b\u00f6lgenin merkezinden uza\u011fa veya merkeze do\u011fru, belirlenen miktar kadar kayd\u0131r\u0131r. Bu kayd\u0131rma i\u015flemi, yumu\u015fak ve organik bir ge\u00e7i\u015f sa\u011flamak i\u00e7in etki alan\u0131n\u0131n kenarlar\u0131na do\u011fru azal\u0131r.","title":"6.3. Fonksiyon: Hacimsel Deformasyon"},{"location":"document/#bolum-7-kullanc-etkilesim-tasarm","text":"","title":"B\u00f6l\u00fcm 7: Kullan\u0131c\u0131 Etkile\u015fim Tasar\u0131m\u0131"},{"location":"document/#71-moduler-etkilesim-stilleri","text":"Uygulama, farkl\u0131 g\u00f6revler i\u00e7in farkl\u0131 fare ve klavye davran\u0131\u015flar\u0131 gerektirir. Bu, monolitik bir yap\u0131 yerine, \"Etkile\u015fim Stilleri\" ad\u0131 verilen de\u011fi\u015ftirilebilir mod\u00fcllerle y\u00f6netilir. - Kamera Stili: Varsay\u0131lan mod. Sahneyi d\u00f6nd\u00fcrme, kayd\u0131rma. - Se\u00e7im Stili: Temizleme arac\u0131 aktifken, 2D alan se\u00e7imi yapmay\u0131 sa\u011flar. - \u0130\u015faretleme Stili: Hizalama arac\u0131 aktifken, model \u00fczerinde 3D nokta se\u00e7meyi sa\u011flar. Controller, kullan\u0131c\u0131n\u0131n se\u00e7ti\u011fi araca g\u00f6re bu stiller aras\u0131nda dinamik olarak ge\u00e7i\u015f yapar.","title":"7.1. Mod\u00fcler Etkile\u015fim Stilleri"},{"location":"document/#72-iletisim-desenleri","text":"Sinyal/Slot (View -> Controller): Aray\u00fczden gelen kullan\u0131c\u0131 eylemlerini Controller'a bildirmek i\u00e7in kullan\u0131l\u0131r. Bu, aray\u00fcz\u00fcn i\u015f mant\u0131\u011f\u0131ndan tamamen habersiz olmas\u0131n\u0131 sa\u011flar. G\u00f6zlemci Deseni (Model/VTK -> Controller): 3D sahnedeki olaylar\u0131 (fare t\u0131klamas\u0131 vb.) yakalamak i\u00e7in kullan\u0131l\u0131r. Controller, 3D motorundaki olaylar\u0131 \"dinler\" ve bunlara tepki verir.","title":"7.2. \u0130leti\u015fim Desenleri"},{"location":"document/#bolum-8-gelecek-gelistirmeler-icin-mimari-hazrlk","text":"Mevcut MVC mimarisi, gelecekte eklenecek yeni \u00f6zellikler i\u00e7in sa\u011flam ve geni\u015fletilebilir bir temel sunmaktad\u0131r. - Yapay Zeka Entegrasyonu: E\u011fitilmi\u015f bir model, \"Model\" katman\u0131na yeni bir algoritma olarak kolayca eklenebilir ve Controller taraf\u0131ndan \u00e7a\u011fr\u0131labilir. \u00d6rne\u011fin, anatomik noktalar\u0131 otomatik bulan bir yapay zeka mod\u00fcl\u00fc. - Bas\u0131n\u00e7 Analizi (FEA): Bir sonlu elemanlar analizi \u00e7\u00f6z\u00fcc\u00fcs\u00fc, yine \"Model\" katman\u0131nda, deforme edilmi\u015f bir geometriyi girdi olarak al\u0131p bir bas\u0131n\u00e7 haritas\u0131 \u00fcreten bir fonksiyon olarak entegre edilebilir. - Proje Kaydetme/Y\u00fckleme: Controller, \"Durum Y\u00f6netimi\" b\u00f6l\u00fcm\u00fcnde tan\u0131mlanan t\u00fcm durumu (aktif veri, bant parametreleri vb.) tek bir dosyaya serile\u015ftirip (serialize) daha sonra bu dosyadan durumu geri y\u00fckleyebilir. Mimari bu \u00f6zelli\u011fe tamamen haz\u0131rd\u0131r.","title":"B\u00f6l\u00fcm 8: Gelecek Geli\u015ftirmeler i\u00e7in Mimari Haz\u0131rl\u0131k"},{"location":"document/#9-modifikasyon-araclar-mimarisi-rectification-tools-architecture","text":"Bu b\u00f6l\u00fcm, protez soketinin dijital olarak \u015fekillendirildi\u011fi, klinik olarak en \u00f6nemli ad\u0131mlar\u0131 i\u00e7eren ara\u00e7 setinin mimarisini tan\u0131mlar. Bu ara\u00e7lar, kullan\u0131c\u0131n\u0131n ad\u0131m ad\u0131m ilerledi\u011fi bir i\u015f ak\u0131\u015f\u0131 ( workflow ) i\u00e7inde sunulur. T\u00fcm modifikasyon ara\u00e7lar\u0131, merkezi bir ModificationEngine taraf\u0131ndan y\u00f6netilir ve ayn\u0131 temel prensipleri payla\u015f\u0131r: - Tahribats\u0131z \u0130\u015flem: T\u00fcm modifikasyonlar, active_poly_data \u00fczerinde yap\u0131l\u0131r ve HistoryStack 'e kaydedilir. - Merkezi Kontrol: MainWindow (Controller), hangi arac\u0131n aktif oldu\u011funu, arac\u0131n parametrelerini (f\u0131r\u00e7a boyutu, azaltma y\u00fczdesi vb.) ve Aray\u00fcz ile Ara\u00e7lar (Model) katman\u0131 aras\u0131ndaki veri ak\u0131\u015f\u0131n\u0131 y\u00f6netir. - Mod\u00fcler Ara\u00e7 Tasar\u0131m\u0131: Her bir modifikasyon arac\u0131 ( R\u00e9duction , Lissage vb.), tools klas\u00f6r\u00fcnde kendi s\u0131n\u0131f\u0131na sahip olacak \u015fekilde tasarlanacakt\u0131r.","title":"9. Modifikasyon Ara\u00e7lar\u0131 Mimarisi (Rectification Tools Architecture)"},{"location":"document/#91-arac-1-reduction-hacim-azaltma","text":"Ama\u00e7: Protez soketinin genel hacmini k\u00fc\u00e7\u00fclterek veya belirli b\u00f6lgelerde lokal bask\u0131 olu\u015fturarak daha s\u0131k\u0131 bir uyum (fit) sa\u011flamak. Aray\u00fcz Bile\u015fenleri (View): \"Global Azaltma\" ve \"Lokal Azaltma\" modlar\u0131n\u0131 se\u00e7mek i\u00e7in QRadioButton veya QPushButton grubu. Global azaltma i\u00e7in y\u00fczde (%) de\u011ferinin girilece\u011fi bir QSlider veya QSpinBox . Lokal azaltma i\u00e7in f\u0131r\u00e7a boyutunu ve etki g\u00fcc\u00fcn\u00fc ayarlayan QSlider 'lar. Kontrol Mant\u0131\u011f\u0131 ( MainWindow ): current_mode 'u 'REDUCTION_GLOBAL' veya 'REDUCTION_LOCAL' olarak ayarlar. Slider'lardan gelen y\u00fczde veya f\u0131r\u00e7a parametrelerini yakalar. Global modda \"Uygula\" butonuna bas\u0131ld\u0131\u011f\u0131nda veya lokal modda fare s\u00fcr\u00fcklenirken ReductionTool \u00fczerindeki ilgili metotlar\u0131 \u00e7a\u011f\u0131r\u0131r. Ara\u00e7 Tasar\u0131m\u0131 ( tools/ReductionTool.py ): ```python class ReductionTool: def apply_global_reduction(self, poly_data, percentage): # 1. Modelin a\u011f\u0131rl\u0131k merkezini (centroid) hesapla. # 2. 'vtkTransform' kullanarak modeli merkeze do\u011fru 'percentage' oran\u0131nda \u00f6l\u00e7ekle. # 3. De\u011fi\u015ftirilmi\u015f poly_data'y\u0131 geri d\u00f6nd\u00fcr. ... def apply_local_reduction(self, poly_data, brush_center, radius, strength): # 1. F\u0131r\u00e7a merkezine 'radius' mesafesindeki noktalar\u0131 (vertices) bul. # 2. Her bir nokta i\u00e7in, kendi normal vekt\u00f6r\u00fc y\u00f6n\u00fcnde i\u00e7eri do\u011fru hareket ettir. # 3. Hareket mesafesi, 'strength' ve merkeze olan uzakl\u0131\u011fa g\u00f6re (falloff) belirlenir. ... ```","title":"9.1. Ara\u00e7 1: R\u00e9duction (Hacim Azaltma)"},{"location":"document/#92-arac-2-creuser-recharger-oyma-ekleme-sculpting","text":"Ama\u00e7: Serbest formda, hassas b\u00f6lgelerdeki (\u00f6rn: kemik \u00e7\u0131k\u0131nt\u0131lar\u0131) bas\u0131nc\u0131 azaltmak i\u00e7in materyal oymak (Creuser) veya zay\u0131f doku alanlar\u0131n\u0131 desteklemek i\u00e7in materyal eklemek (Recharger). Aray\u00fcz Bile\u015fenleri (View): \"Oy\" (Dig) ve \"Ekle\" (Bulge) modlar\u0131 aras\u0131nda ge\u00e7i\u015f yapan butonlar. F\u0131r\u00e7a Boyutu ve Etki G\u00fcc\u00fc i\u00e7in QSlider 'lar. Fare imlecinin model \u00fczerindeki izd\u00fc\u015f\u00fcm\u00fcn\u00fc g\u00f6steren anl\u0131k bir f\u0131r\u00e7a g\u00f6stergesi. Kontrol Mant\u0131\u011f\u0131 ( MainWindow ): Aktif f\u0131r\u00e7a modunu ( 'DIG' veya 'BULGE' ) ve f\u0131r\u00e7a parametrelerini SculptingTool 'a iletir. Fare model \u00fczerinde s\u00fcr\u00fcklendi\u011fi s\u00fcrece, mouseMoveEvent olay\u0131ndan elde edilen 3D koordinatlar\u0131 anl\u0131k olarak SculptingTool 'a g\u00f6nderir. Ara\u00e7 Tasar\u0131m\u0131 ( tools/SculptingTool.py ): python class SculptingTool: def deform(self, poly_data, brush_center, radius, strength, mode): # 1. F\u0131r\u00e7a etki alan\u0131ndaki noktalar\u0131 bul. # 2. Her nokta i\u00e7in, normal vekt\u00f6r\u00fcn\u00fc al. # 3. if mode == 'BULGE': Noktay\u0131 normal y\u00f6n\u00fcnde d\u0131\u015far\u0131 ta\u015f\u0131. # 4. if mode == 'DIG': Noktay\u0131 normal y\u00f6n\u00fcnde i\u00e7eri ta\u015f\u0131. # 5. Ta\u015f\u0131ma miktar\u0131n\u0131 'strength' ve yumu\u015fak bir ge\u00e7i\u015f i\u00e7in 'falloff' fonksiyonu ile ayarla. ...","title":"9.2. Ara\u00e7 2: Creuser / Recharger (Oyma / Ekleme - Sculpting)"},{"location":"document/#93-arac-3-lissage-yumusatma","text":"Ama\u00e7: \u00d6nceki ad\u0131mlarda olu\u015fan p\u00fcr\u00fczl\u00fc veya keskin y\u00fczeyleri yumu\u015fatarak daha p\u00fcr\u00fczs\u00fcz ve konforlu bir i\u00e7 y\u00fczey elde etmek. Aray\u00fcz Bile\u015fenleri (View): F\u0131r\u00e7a Boyutu ve Yumu\u015fatma Miktar\u0131 i\u00e7in QSlider 'lar. Kontrol Mant\u0131\u011f\u0131 ( MainWindow ): SculptingTool 'a benzer \u015fekilde, fare hareketlerini SmoothingTool 'a y\u00f6nlendirir. Ara\u00e7 Tasar\u0131m\u0131 ( tools/SmoothingTool.py ): ```python class SmoothingTool: def init (self): # VTK'n\u0131n yerle\u015fik yumu\u015fatma filtresi kullan\u0131l\u0131r. self.smoother = vtk.vtkSmoothPolyDataFilter() def smooth_area(self, poly_data, brush_center, radius, iterations): # 1. F\u0131r\u00e7a alan\u0131ndaki noktalar\u0131 belirle. # 2. Yaln\u0131zca bu noktalar\u0131 etkileyecek \u015fekilde 'vtkSmoothPolyDataFilter'\u0131 \u00e7al\u0131\u015ft\u0131r. # 3. 'iterations' (d\u00f6ng\u00fc say\u0131s\u0131), aray\u00fczdeki yumu\u015fatma miktar\u0131na ba\u011flan\u0131r. ...","title":"9.3. Ara\u00e7 3: Lissage (Yumu\u015fatma)"},{"location":"document/#_1","text":"","title":"```"},{"location":"document/#protez-soketi-modifikasyon-araclar","text":"","title":"Protez Soketi Modifikasyon Ara\u00e7lar\u0131"},{"location":"document/#epaisseur-kalnlk","text":"Ama\u00e7: Protez soketinin \u00fcretim i\u00e7in gerekli olan duvar kal\u0131nl\u0131\u011f\u0131n\u0131 ayarlamak. Genellikle t\u00fcm sokete tek tip bir kal\u0131nl\u0131k uygulan\u0131r. Teknoloji: - vtkPolyDataNormals ile normal vekt\u00f6rleri hesaplan\u0131r. - Noktalar, normal y\u00f6nleri boyunca belirli bir mesafede kayd\u0131r\u0131larak yeni bir d\u0131\u015f y\u00fczey olu\u015fturulur. - vtkBooleanOperationPolyDataFilter ile i\u00e7 ve d\u0131\u015f y\u00fczey birle\u015ftirilebilir.","title":"\u00c9paisseur (Kal\u0131nl\u0131k)"},{"location":"document/#evases-kenar-sekillendirme-flare","text":"Ama\u00e7: Protez soketinin \u00fcst kenarlar\u0131n\u0131, hastan\u0131n uzvuna daha iyi oturacak ve kenar tahri\u015fini \u00f6nleyecek \u015fekilde i\u00e7eri veya d\u0131\u015far\u0131 do\u011fru \u015fekillendirmek. G\u00f6r\u00fcnt\u00fcdeki renk \u00e7ark\u0131, b\u00f6lgesel kontrol\u00fcn \u00f6nemini vurgular. Teknoloji: - Soketin \u00fcst kenar\u0131ndaki poligon halkalar\u0131 (edge loops) se\u00e7ilir. - Bu halkalar\u0131n noktalar\u0131, y\u00fczey normali veya kenar normali boyunca, b\u00f6lgesel olarak belirlenen miktarlarda hareket ettirilir. - Ge\u00e7i\u015fleri yumu\u015fatmak i\u00e7in vtkSmoothPolyDataFilter veya \u00f6zel deformasyon algoritmalar\u0131 kullan\u0131labilir.","title":"\u00c9vas\u00e9s (Kenar \u015eekillendirme / Flare)"},{"location":"document/#prise-distale-distal-tutus-arayuz","text":"Ama\u00e7: Ampute uzvun distal ucu ile protez soketi aras\u0131ndaki ba\u011flant\u0131 noktas\u0131n\u0131 \u015fekillendirmek ve buraya uygun ba\u011flant\u0131 elemanlar\u0131n\u0131 (adapt\u00f6r, kilit mekanizmas\u0131) dijital olarak yerle\u015ftirmek. Teknoloji: - Distal u\u00e7 b\u00f6lgesinde \u00f6zel bir deformasyon ve/veya kesme i\u015flemi yap\u0131l\u0131r. - Kullan\u0131c\u0131, STL format\u0131nda \u00f6nceden y\u00fcklenmi\u015f distal ba\u011flant\u0131 eleman\u0131 modellerinden birini se\u00e7ebilir ve bunu soketin distal ucuna yerle\u015ftirebilir. - Konumland\u0131rma ve y\u00f6nlendirme i\u00e7in vtkTransformWidget gibi manip\u00fclat\u00f6rler kullan\u0131l\u0131r.","title":"Prise Distale (Distal Tutu\u015f / Aray\u00fcz)"},{"location":"document/#alignement-hizalama","text":"Ama\u00e7: Protez soketinin, t\u00fcm protez sisteminin (diz eklemi, ayak, pelvik b\u00f6lge) anatomik ve biyomekanik olarak do\u011fru hizalanmas\u0131n\u0131 sa\u011flamak. Teknoloji: - vtkAssembly veya vtkProp ile sanal bir hizalama stand\u0131 olu\u015fturulur. - Soket, diz eklemi ve ayak gibi bile\u015fenler bu stand \u00fczerinde konumland\u0131r\u0131l\u0131r. - Kullan\u0131c\u0131, rotasyon (\u00f6n-arka, i\u00e7-d\u0131\u015f) ve translasyon (y\u00fckseklik, yanlara kayd\u0131rma) ayarlamalar\u0131 yapabilir. - vtkTransform ve vtkMatrix4x4 bu d\u00f6n\u00fc\u015f\u00fcmleri y\u00f6netir.","title":"Alignement (Hizalama)"},{"location":"document/#finalisation-sonlandrma","text":"Ama\u00e7: T\u00fcm modelleme ve rektifikasyon ad\u0131mlar\u0131 tamamland\u0131ktan sonra, protez kal\u0131b\u0131n\u0131 \u00fcretime haz\u0131r hale getirmek ve \u00e7\u0131kt\u0131 almak. Teknoloji: - Model Do\u011frulama: Son vtkPolyData \u00fczerinde topolojik kontroller (delik kontrol\u00fc, kesi\u015fen \u00fc\u00e7genler). - D\u0131\u015fa Aktarma: vtkSTLWriter ile nihai model STL format\u0131nda kaydedilir. -","title":"Finalisation (Sonland\u0131rma)"},{"location":"srd/","text":"Yaz\u0131l\u0131m Gereksinimleri Belirtimi (SRD) Belge T\u00fcr\u00fc : Teknik Dok\u00fcmantasyon Proje : 3B Tarama Cihaz\u0131 Versiyon: 1.1 Tarih: 18.03.2025 Revizyon Ge\u00e7mi\u015fi Tarih A\u00e7\u0131klama Yazar Yorumlar 18.03.2025 V1.0 Ahmet Furkan KARAARSLAN Dok\u00fcman ba\u015flang\u0131\u00e7 2.04.2025 V1.1 Muammer Tiryaki K\u00fc\u00e7\u00fck g\u00fcncellemeler \u0130\u00e7indekiler 1. Giri\u015f 1.1 Ama\u00e7 1.2 Kapsam 1.3 Tan\u0131mlar ve K\u0131saltmalar 1.4 Referanslar 1.5 Genel Bak\u0131\u015f 2. Genel A\u00e7\u0131klama 2.1 \u00dcr\u00fcn Perspektifi 2.3 \u00dcr\u00fcn \u0130\u015flevleri 2.3 Kullan\u0131c\u0131 \u00d6zellikleri 2.4 Genel S\u0131n\u0131rlamalar 2.5 Varsay\u0131mlar ve Ba\u011f\u0131ml\u0131l\u0131klar\u0131 3. \u00d6zel Gereksinimler 3.1 D\u0131\u015f Arabirimi Gereksinimleri 3.2 Fonksiyonel Gereksinimleri 3.3 Kullan\u0131m Durumlar\u0131 3.4 S\u0131n\u0131flar / Nesneler 3.5 \u0130\u015flevsel Olmayan Gereksinimler 3.6 Ters Gereksinimleri 3.7 Tasar\u0131m K\u0131s\u0131tlamalar\u0131 3.8 Mant\u0131ksal Veritaban\u0131 Gereksinimleri 3.9 Di\u011fer Gereksinimler 4. Analiz Modelleri 4.1 Aktivite Diyagramlar\u0131 4.2 Sequence Diyagramlar\u0131 4.3 Veri Ak\u0131\u015f Diyagramlar\u0131 4.4 Durum Ge\u00e7i\u015fi Diyagramlar\u0131 5. De\u011fi\u015fiklik Y\u00f6netimi S\u00fcreci A. Ekler A.1 Ek 1 1. Giri\u015f 1.1 Ama\u00e7 Bu dok\u00fcman, 3D tarama cihaz\u0131 yaz\u0131l\u0131m\u0131n\u0131n i\u015flevsel ve i\u015flevsel olmayan gereksinimlerini tan\u0131mlamaktad\u0131r. Yaz\u0131l\u0131m\u0131n amac\u0131, lazer tabanl\u0131 yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k desenlerini yakalamak, stereo kamera kurulumu kullanarak noktu bulutunu \u00e7\u0131karmak, kamera konumunu belirlemek i\u00e7in marker tabanl\u0131 PnP algoritmas\u0131n\u0131 kullanmak ve g\u00f6r\u00fcnt\u00fcleri i\u015fleyerek hassas 3D modellerin \u00e7\u0131kt\u0131 olarak olu\u015fturulmas\u0131n\u0131 sa\u011flamakt\u0131r. \u00dcretilecek olan yaz\u0131l\u0131m ve donan\u0131m Kickstarter (Fonlama ile sat\u0131\u015f) projesinde farkl\u0131 paketler (Stereo kamera, Structured Light, Stereo Kamera + Structured Light, Infrared Light, Infrared Light+ Stereo kamera veya hepsi i\u00e7in mono kamera) \u015feklinde piyasaya s\u00fcr\u00fclecektir. Proje i\u00e7erisinde elektronik tasar\u0131m ve yaz\u0131l\u0131m tasar\u0131m\u0131 olarak ikiye ayr\u0131lmaktad\u0131r. Tasarlanan yaz\u0131l\u0131m\u0131n SDK (Software Development Kit) \u015feklinde a\u00e7\u0131k kaynak olarak yay\u0131nlanarak geri d\u00f6n\u00fc\u015fler alarak yaz\u0131l\u0131m\u0131n geli\u015ftirilmesi hedeflenmektedir. Elektronik tasar\u0131m ise SDK ile b\u00fct\u00fcnle\u015fik \u00e7al\u0131\u015f\u0131p kapal\u0131 kaynak benimsenmesi sa\u011flanacakt\u0131r. 1.2 Kapsam Bu yaz\u0131l\u0131m a\u015fa\u011f\u0131daki i\u015flevleri sa\u011flayacakt\u0131r: Lazer tarama sistemi ve kamera ile y\u00fcksek \u00e7\u00f6z\u00fcn\u00fcrl\u00fckl\u00fc g\u00f6r\u00fcnt\u00fcler yakalama. \u0130ki kamera (stereo kamera) kullan\u0131larak derinlik bilgisi elde edilerek nokta bulutu elde etme. Kamera kalibrasyonun yap\u0131labilmesi. G\u00f6r\u00fcnt\u00fc i\u015fleme algoritmalar\u0131n\u0131 kullanarak 3D nokta bulutlar\u0131 olu\u015fturma. Kamera konumlar\u0131n\u0131n i\u015faret\u00e7i tabanl\u0131 PnP algoritmas\u0131 ile belirlenmesi. Tarama ve veri d\u0131\u015fa aktarma i\u015flemleri i\u00e7in etkile\u015fimli bir kullan\u0131c\u0131 aray\u00fcz\u00fc sa\u011flama. Birden fazla \u00e7\u0131kt\u0131 format\u0131n\u0131 destekleme (PCL, STL, OBJ, PLY). Tarama h\u0131z\u0131 ve do\u011frulu\u011funu optimize etme. Elde edilen nokta bulutlar\u0131 \u00fczerinde farkl\u0131 algoritmalar\u0131n\u0131n denenmesi ve denenilen algoritmalar\u0131n etkisinin kontrol edilmesi i\u00e7in test aray\u00fcz\u00fcn\u00fcn olu\u015fturulmas\u0131, algoritma nokta bulutuna uyguland\u0131ktan sonra algoritman\u0131n etkisinin g\u00f6zle kontrol edilmesi. Python SDK ile kullan\u0131c\u0131lar\u0131n hem ham g\u00f6r\u00fcnt\u00fc verilerini hem de \u00f6n i\u015flemden ge\u00e7mi\u015f en az\u0131ndan PCL olarak i\u015flenmi\u015f verileri alabilmesi hedeflenmektedir. Bu elektronik sistem a\u015fa\u011f\u0131daki i\u015flevleri sa\u011flayacakt\u0131r: Birbirinden ba\u011f\u0131ms\u0131z noktada kitler bulunmas\u0131 hedeflenmektedir. Kit ana bilgisayara ya da hesaplama birimine kablolu ya da kablosuz olarak ba\u011flanacakt\u0131r. \u00c7e\u015fitli mod\u00fcller e\u015f zamanl\u0131 piyasaya s\u00fcr\u00fclecektir: Kamera Kaynak Sens\u00f6r Haberle\u015fme FPGA ya da SOM Mod\u00fcl 1 mono RGB IR led pattern IMU kablolu var Mod\u00fcl 2 mono RGB MAV\u0130 pattern IMU kablosuz var Mod\u00fcl 3 stereo RGB IR pattern IMU kablolu yok Mod\u00fcl 4 stereo Monokrome K\u0131rm\u0131z\u0131 pattern IMU kablosuz yok Bu mod\u00fcl kombinasyonu daha sonra belirlenecektir. Mod\u00fcller \u00fczerinde bulunabilecek ISP ve dahili FPGA/SOM gibi yap\u0131lar ara\u015ft\u0131r\u0131lacakt\u0131r. Mod\u00fcller e\u011fer kablosuz tasarlanabiliyorsa batarya mod\u00fcl\u00fc de eklenecektir. 1.3 Tan\u0131mlar ve K\u0131saltmalar Lazer Tarama: Bir nesneye belirli lazer desenlerinin yans\u0131t\u0131lmas\u0131 ve kameradan al\u0131nan g\u00f6r\u00fcnt\u00fclerin analiz edilerek 3D model olu\u015fturulmas\u0131 tekni\u011fi. Stereo Kamera: Derinlik alg\u0131s\u0131 olu\u015fturmak i\u00e7in iki farkl\u0131 a\u00e7\u0131dan g\u00f6r\u00fcnt\u00fc yakalayan \u00e7ift kamera sistemi. PnP (Perspective-n-Point): Kameran\u0131n 3D uzaydaki konumunu belirlemek i\u00e7in marker tabanl\u0131 konumland\u0131rma y\u00f6ntemi. Nokta Bulutu: Tarama y\u00fczeyini temsil eden 3D veri noktalar\u0131ndan olu\u015fan yap\u0131. STL (Stereolithography): CAD ve 3D bask\u0131 i\u00e7in yayg\u0131n olarak kullan\u0131lan bir 3D dosya format\u0131. Structured Light: Yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k, \u00fc\u00e7 boyutlu bir nesnenin \u015feklini ve derinli\u011fini, nesnenin y\u00fczeyine bir \u0131\u015f\u0131k deseni yans\u0131tarak \u00f6l\u00e7en bir y\u00f6ntemdir. Desen \u015feritler, \u0131zgaralar veya noktalar olabilir. Mono kamera: Tekli kamera kurulumu. IMU: Kameralar\u0131n konum lokasyon takibi yapabilmesi ve birbirlerine g\u00f6re referanslanabilmesini sa\u011flayacakt\u0131r. FPGA ya da SOM: E\u011fer gerekirse mod\u00fcller \u00fczerinde dahili i\u015flem birimi ile PCL verilerinin aktar\u0131labilmesi sa\u011flanacakt\u0131r. 1.4 Referanslar OpenCV Dok\u00fcmantasyonu (G\u00f6r\u00fcnt\u00fc i\u015fleme i\u00e7in) Kamera Kalibrasyonu https://docs.opencv.org/4.x/dc/dbb/tutorial_py_calibration.html PCL (Point Cloud Library) Dok\u00fcmantasyonu Agile Yaz\u0131l\u0131m Geli\u015ftirme \u0130lkeleri Open3D Dok\u00fcmantasyonu Kickstarter Kullan\u0131lacak kamera e-con system'e ait monochroma ve RGB kameralard\u0131r. 1.5 Genel Bak\u0131\u015f Bu belge, 3B tarama cihaz\u0131 yaz\u0131l\u0131m\u0131n\u0131n i\u015flevsel ve i\u015flevsel olmayan t\u00fcm gereksinimlerini ayr\u0131nt\u0131l\u0131 bi\u00e7imde a\u00e7\u0131klar. Belge, yaz\u0131l\u0131m\u0131n amac\u0131n\u0131, kapsam\u0131n\u0131, teknik altyap\u0131s\u0131n\u0131, kullan\u0131c\u0131 aray\u00fczlerini, donan\u0131m ve yaz\u0131l\u0131m arabirimlerini, kullan\u0131m senaryolar\u0131n\u0131, s\u0131n\u0131f ve nesne yap\u0131s\u0131n\u0131, performans beklentilerini ve tasar\u0131m k\u0131s\u0131tlar\u0131n\u0131 i\u00e7ermektedir. Dok\u00fcman a\u015fa\u011f\u0131daki b\u00f6l\u00fcmlerden olu\u015fmaktad\u0131r: Giri\u015f: Projenin amac\u0131, kapsam\u0131, terminolojisi Genel A\u00e7\u0131klama: \u00dcr\u00fcn\u00fcn genel yap\u0131s\u0131 ve kullan\u0131m alanlar\u0131 \u00d6zel Gereksinimler: Fonksiyonel ve i\u015flevsel olmayan gereksinimler Analiz Modelleri: Diyagramlar ve i\u015f ak\u0131\u015flar\u0131 De\u011fi\u015fiklik Y\u00f6netimi: Gereksinimlerin nas\u0131l g\u00fcncellenece\u011fi 2. Genel A\u00e7\u0131klama 2.1 \u00dcr\u00fcn Perspektifi Yaz\u0131l\u0131m, harici donan\u0131mlarla (kameralar, lazer kayna\u011f\u0131) etkile\u015fime giren ba\u011f\u0131ms\u0131z bir uygulama ve donan\u0131m olarak tasarlanacakt\u0131r ve kullan\u0131c\u0131ya ger\u00e7ek zamanl\u0131 geri bildirim sa\u011flayacakt\u0131r. Yaz\u0131l\u0131m, \u00fc\u00e7 farkl\u0131 3D tarama y\u00f6ntemi i\u00e7in destek sa\u011flayacakt\u0131r: Stereo Kamera Y\u00f6ntemi: \u0130ki farkl\u0131 kameradan al\u0131nan g\u00f6r\u00fcnt\u00fcler aras\u0131ndaki paralaks fark\u0131 kullan\u0131larak derinlik bilgisi elde edilir. Lazer Tabanl\u0131 Yap\u0131land\u0131r\u0131lm\u0131\u015f I\u015f\u0131k Y\u00f6ntemi: Bir projeksiyon kayna\u011f\u0131 arac\u0131l\u0131\u011f\u0131yla nesne \u00fczerine belirli desenler yans\u0131t\u0131larak, kameradan bu desenlerin deformasyonu analiz edilir ve 3D model olu\u015fturulur. Stereo Kamera + Lazer Tabanl\u0131 Yap\u0131land\u0131r\u0131lm\u0131\u015f I\u015f\u0131k Y\u00f6ntemi: Stereo kamera ve lazer(hem g\u00f6r\u00fcn\u00fcr \u0131\u015f\u0131k hem IR \u0131\u015f\u0131k i\u00e7in) tabanl\u0131 yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k y\u00f6ntemlerinin birle\u015fimi ile daha y\u00fcksek do\u011fruluk elde edilir. Stereo kameralar derinlik haritas\u0131n\u0131 \u00e7\u0131kar\u0131rken, lazer ile detayl\u0131 y\u00fczey bilgisi sa\u011flan\u0131r. 2.3 \u00dcr\u00fcn \u0130\u015flevleri G\u00f6r\u00fcnt\u00fc Yakalama: Kameradan ham g\u00f6r\u00fcnt\u00fclerin al\u0131nmas\u0131. Lazer Tabanl\u0131 Yap\u0131land\u0131r\u0131lm\u0131\u015f I\u015f\u0131k \u0130\u015fleme: Algoritmalarla derinlik bilgisi \u00e7\u0131karma. 3D Modelle\u015ftirme: Derinlik verisini nokta bulutuna ve mesh yap\u0131s\u0131na d\u00f6n\u00fc\u015ft\u00fcrme. Kamera Konumu Belirleme: Marker tabanl\u0131 PnP algoritmas\u0131 kullanarak kameran\u0131n konumunun hesaplanmas\u0131. Yaz\u0131l\u0131m \u00fczerinden kullan\u0131c\u0131n\u0131n i\u015flevlere sahip olmas\u0131n\u0131 sa\u011flama. E\u011fer birden fazla kamera mod\u00fcl\u00fc bir sisteme tak\u0131l\u0131ysa bunlar aras\u0131nda kolerasyon kurulmas\u0131. Dosya D\u0131\u015fa Aktarma: Sonu\u00e7lar\u0131 end\u00fcstri standard\u0131 3D dosya formatlar\u0131nda kaydetme. Kullan\u0131c\u0131 Aray\u00fcz\u00fc: Tarama ba\u015flatma, durdurma ve dosya y\u00f6netimi gibi \u00f6zellikler sunma. 2.3 Kullan\u0131c\u0131 \u00d6zellikleri 2.4 Genel S\u0131n\u0131rlamalar Yaz\u0131l\u0131m sadece uyumlu kamera ve lazer donan\u0131m\u0131 ile \u00e7al\u0131\u015facakt\u0131r. Ger\u00e7ek zamanl\u0131 veri i\u015fleme i\u00e7in belirli bir sistem konfig\u00fcrasyonu (\u00f6rn. minimum i7 i\u015flemci, 32GB RAM ya da Nvidia CUDA) gereklidir. I\u015f\u0131k ko\u015fullar\u0131, tarama kalitesini etkileyebilir. Yetersiz ayd\u0131nlatma durumlar\u0131nda tarama do\u011frulu\u011fu azalabilir. Bu tarz tespitler ile sistem mod\u00fclleri aras\u0131na ek \u00fcr\u00fcnler geli\u015ftirilecektir. Ba\u015flang\u0131\u00e7ta yaln\u0131zca Ubuntu 22.04 i\u015fletim sistemi \u00fczerinde \u00e7al\u0131\u015facakt\u0131r. Ard\u0131ndan Python/C++ SDK ile di\u011fer sistemlerde de \u00e7al\u0131\u015fabilir hale getirilecektir. 2.5 Varsay\u0131mlar ve Ba\u011f\u0131ml\u0131l\u0131klar\u0131 Tarama i\u015flemi i\u00e7in uyumlu bir kamera ve lazer kayna\u011f\u0131 gereklidir. Kamera konumu, marker tabanl\u0131 PnP algoritmas\u0131 kullan\u0131larak tespit edilecektir. G\u00f6r\u00fcnt\u00fc ve 3D i\u015flemleme i\u00e7in OpenCV ve PCL gibi harici k\u00fct\u00fcphaneler kullan\u0131lacakt\u0131r. Birden fazla kamera kullan\u0131lan durumlarda kameralar\u0131n birbirlerine g\u00f6re konumu hassas olarak girilmesi beklenebilir. 3. \u00d6zel Gereksinimler 3.1 D\u0131\u015f Arabirimi Gereksinimleri 3.1.1 Kullan\u0131c\u0131 Aray\u00fczleri Ana ekran: Tarama ba\u015flatma, durdurma ve ayarlar\u0131 bar\u0131nd\u0131r\u0131r. \u00d6nizleme alan\u0131: Ger\u00e7ek zamanl\u0131 g\u00f6r\u00fcnt\u00fc ak\u0131\u015f\u0131 ve olu\u015fturulan 3D modelin \u00f6nizlemesi g\u00f6sterilir. Ayarlar paneli: Kalibrasyon verileri, \u00e7\u00f6z\u00fcn\u00fcrl\u00fck ve \u00e7\u0131kt\u0131 format\u0131 gibi ayarlar yap\u0131l\u0131r. \u00c7\u0131kt\u0131 ekran\u0131: Tarama sonucu 3D modelin kaydedilece\u011fi format ve konum se\u00e7ilir. 3.1.2 Donan\u0131m Arabirimleri 2 adet USB 3.0 ba\u011flant\u0131 noktas\u0131 (stereo kamera i\u00e7in) Lazer taray\u0131c\u0131 i\u00e7in harici g\u00fc\u00e7 ba\u011flant\u0131s\u0131(\u015eimdilik) Donan\u0131m tetikleyici (opsiyonel) ile senkron g\u00f6r\u00fcnt\u00fc alma deste\u011fi \u0130leriki modellerde geni\u015f bant \u00fczerinden veri aktar\u0131m\u0131n\u0131 sa\u011flayabilmek i\u00e7in ETH, Fiber kablo ya da Wi-Fi d\u00fc\u015f\u00fcn\u00fclmektedir. Mod\u00fcl \u00fczerinde dahili batarya 3.1.3 Yaz\u0131l\u0131m Arabirimleri OpenCV: G\u00f6r\u00fcnt\u00fc i\u015fleme ve kamera kalibrasyonu i\u00e7in PCL: Nokta bulutu olu\u015fturma ve i\u015fleme i\u00e7in, 3D g\u00f6rselle\u015ftirme ve \u00e7\u0131kt\u0131 alma i\u015flemleri i\u00e7in USB kamera SDK\u2019s\u0131 (e-con Systems) 3.1.4 \u0130leti\u015fim Arabirimleri USB 3.0 \u00fczerinden kamera veri ak\u0131\u015f\u0131 3.2 Fonksiyonel Gereksinimleri ID Gereksinim A\u00e7\u0131klamas\u0131 FG-1 Sistem ba\u011fl\u0131 kameradan g\u00f6r\u00fcnt\u00fc yakalayabilmelidir. FG-2 Yaz\u0131l\u0131m lazer tabanl\u0131 yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k desenlerini alg\u0131lay\u0131p analiz edebilmelidir. FG-3 Sistem yakalanan g\u00f6r\u00fcnt\u00fclerden 3D nokta bulutu olu\u015fturabilmelidir. FG-4 Kullan\u0131c\u0131 tarama \u00e7\u00f6z\u00fcn\u00fcrl\u00fc\u011f\u00fcn\u00fc ve parametreleri ayarlayabilmelidir. FG-5 Sistem 3D modelleri STL, OBJ ve PLY formatlar\u0131nda d\u0131\u015fa aktarabilmelidir. FG-6 Kullan\u0131c\u0131 aray\u00fcz\u00fc, tarama ba\u015flatma, durdurma ve kaydetme i\u015flemlerine izin vermelidir. FG-7 Kamera konumu, i\u015faret tabanl\u0131 PnP algoritmas\u0131 ile tespit edilmelidir. FG-8 Nokta bulutlar\u0131 \u00fczerinde denenilecek olan algoritmalar i\u00e7in \u00f6ncesi ve sonras\u0131 \u015feklinde g\u00f6r\u00fcnt\u00fcler vermelidir. FG-9 G\u00f6r\u00fcnt\u00fc hem dinamik olarak hem de kullan\u0131c\u0131n\u0131n iste\u011fine g\u00f6re \u201cspace\u201d tu\u015funa bast\u0131k\u00e7a kameradan g\u00f6r\u00fcnt\u00fc alacak \u015fekilde iki se\u00e7enekli olmal\u0131d\u0131r. FG-10 \u0130\u015faret\u00e7i takibi kaybedildi\u011fi zaman kullan\u0131c\u0131y\u0131 bilgilendirmek i\u00e7in ekranda uyar\u0131 vermeli ve kamera konumu belirlenene kadar tarama durdurulmal\u0131d\u0131r. 3.2.1 Fonksiyonel Gereksinim #1: G\u00f6r\u00fcnt\u00fc Yakalama ve Tarama Giri\u015f: Stereo kamera g\u00f6r\u00fcnt\u00fcleri Giri\u015fler: Kalibrasyon verileri (K1, D1, K2, D2) \u0130\u015fleme: Stereo e\u015fleme algoritmas\u0131 ile derinlik haritas\u0131 \u00fcretimi \u00c7\u0131k\u0131\u015flar: 3D nokta bulutu Hata i\u015fleme: Kalibrasyon eksikse uyar\u0131 verilir, d\u00fc\u015f\u00fck e\u015fle\u015fme kalitesi tespit edilirse kullan\u0131c\u0131ya bildirim yap\u0131l\u0131r. 3.2.2 Fonksiyonel Gereksinim #2: 3D Modelin Olu\u015fturulmas\u0131 ve D\u0131\u015fa Aktar\u0131m\u0131 Giri\u015f: Nokta bulutu, kullan\u0131c\u0131 taraf\u0131ndan se\u00e7ilen parametreler \u0130\u015fleme: Noktalar mesh'e d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr, gerekli dosya format\u0131 olu\u015fturulur \u00c7\u0131k\u0131\u015flar: STL, OBJ, PLY format\u0131nda dosyalar Hata \u0130\u015fleme: Yazma izni olmayan klas\u00f6r se\u00e7ilirse kullan\u0131c\u0131 uyar\u0131l\u0131r, bo\u015f tarama verisi varsa i\u015flem durdurulur. 3.3 Kullan\u0131m Durumlar\u0131 3.3.1 Kullan\u0131m Durumu #1: Nesne Tabanl\u0131 3D Tarama Ama\u00e7: Ger\u00e7ek d\u00fcnya ortam\u0131ndaki bir nesnenin y\u00fczey geometrisinin y\u00fcksek hassasiyetle taranarak bilgisayar ortam\u0131nda 3B model olarak elde edilmesi. Akt\u00f6rler: Kullan\u0131c\u0131 (operat\u00f6r) \u00d6n Ko\u015fullar: Kamera ve lazer sistemi d\u00fczg\u00fcn \u00e7al\u0131\u015f\u0131yor olmal\u0131 Kalibrasyon tamamlanm\u0131\u015f olmal\u0131 Marker\u2019lar sistemin g\u00f6rebilece\u011fi \u015fekilde d\u00fczg\u00fcn konumland\u0131r\u0131lm\u0131\u015f olmal\u0131 Marker tan\u0131mlar\u0131 yaz\u0131l\u0131ma \u00f6nceden tan\u0131t\u0131lm\u0131\u015f olmal\u0131 Senaryo: Kullan\u0131c\u0131 sistemi ba\u015flat\u0131r. Marker\u2019lar kameralar taraf\u0131ndan alg\u0131lan\u0131r ve PnP algoritmas\u0131 ile pozisyon tespiti yap\u0131l\u0131r. Kamera ve lazer otomatik olarak senkronize \u00e7al\u0131\u015fmaya ba\u015flar. Kullan\u0131c\u0131 nesneyi sabit konumda yerle\u015ftirir. Sistem g\u00f6r\u00fcnt\u00fcleri yakalar, i\u015fleyip nokta bulutu olu\u015fturur. Nokta bulutu 3B modele d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr. Kullan\u0131c\u0131 \u00e7\u0131kt\u0131y\u0131 .STL veya .PLY format\u0131nda kaydeder. Sonu\u00e7: Tarama ba\u015far\u0131yla tamamlan\u0131r ve 3D model elde edilir. 3.3.2 Kullan\u0131m Durumu #2: Medikal Tarama \u2013 Uzuv Modelleme Ama\u00e7: Medikal sekt\u00f6r\u00fcnde kullan\u0131lmak \u00fczere insan uzuvlar\u0131n\u0131n hassas \u015fekilde taranarak dijital ortama aktar\u0131lmas\u0131. Akt\u00f6rler: Kullan\u0131c\u0131 (teknisyen), hasta \u00d6n Ko\u015fullar: Ki\u015fi hareketsiz pozisyonda durmal\u0131 Kalibrasyon dosyalar\u0131 \u00f6nceden haz\u0131rlanm\u0131\u015f olmal\u0131 Marker\u2019lar sistem g\u00f6r\u00fc\u015f alan\u0131nda net \u015fekilde sabitlenmi\u015f olmal\u0131 Ortam \u0131\u015f\u0131\u011f\u0131 yetersiz de\u011filse ek ayd\u0131nlatma sa\u011flanmal\u0131 Senaryo: Kullan\u0131c\u0131 hastay\u0131 tarama alan\u0131na yerle\u015ftirir. Marker'lar alg\u0131lan\u0131r, sistem pozisyonunu do\u011frular. Tarama \u00e7\u00f6z\u00fcn\u00fcrl\u00fc\u011f\u00fc \u201cy\u00fcksek\u201d olarak se\u00e7ilir. Sistem birka\u00e7 saniyelik g\u00f6r\u00fcnt\u00fc al\u0131m\u0131 yapar. Elde edilen nokta bulutu y\u00fczey yumu\u015fatma ile optimize edilir. Model, ortopedik kal\u0131p \u00fcretimi i\u00e7in d\u0131\u015fa aktar\u0131l\u0131r. Sonu\u00e7: Hasta uzvunun dijital modeli al\u0131nm\u0131\u015f ve \u00fcretime haz\u0131r h\u00e2le getirilmi\u015ftir. 3.3.3 Kullan\u0131m Durumu #3: Algoritma Kar\u015f\u0131la\u015ft\u0131rma Modu (Test Aray\u00fcz\u00fc) Ama\u00e7: Yeni nokta bulutu filtreleme veya y\u00fczey iyile\u015ftirme algoritmalar\u0131n\u0131 test etmek ve etkilerini g\u00f6rsel olarak kar\u015f\u0131la\u015ft\u0131rmak. Akt\u00f6rler: Geli\u015ftirici veya ara\u015ft\u0131rmac\u0131 kullan\u0131c\u0131 \u00d6n Ko\u015fullar: Marker\u2019lar yaz\u0131l\u0131mda tan\u0131t\u0131lm\u0131\u015f olmal\u0131 (e\u011fer canl\u0131 tarama yap\u0131lacaksa) Mevcut veya \u00f6nceden taranm\u0131\u015f nokta bulutu verisi sisteme y\u00fcklenebilir olmal\u0131 Senaryo: Kullan\u0131c\u0131 mevcut bir nokta bulutunu yaz\u0131l\u0131ma y\u00fckler. Farkl\u0131 filtreleme algoritmalar\u0131 listeden se\u00e7ilir. Yaz\u0131l\u0131m ayn\u0131 veri \u00fczerinde \u00f6nce/sonra kar\u015f\u0131la\u015ft\u0131rmas\u0131 yapar. Kullan\u0131c\u0131 g\u00f6rsel \u00e7\u0131kt\u0131lar \u00fczerinden karar verir. Sonu\u00e7: Algoritmalar\u0131n performans\u0131 test edilmi\u015f olur, ileri geli\u015ftirmeler yap\u0131labilir. 3.4 S\u0131n\u0131flar / Nesneler 3.4.1 S\u0131n\u0131f / Nesne #1: KameraMod\u00fcl\u00fc \u00d6znitelikler: ID, \u00e7\u00f6z\u00fcn\u00fcrl\u00fck, fps, kalibrasyon parametreleri \u0130\u015flevler: G\u00f6r\u00fcnt\u00fcAl(), KalibrasyonY\u00fckle(), VideoAk\u0131\u015f\u0131Ba\u015flat() Referans: FG-1, FG-7 3.4.2 S\u0131n\u0131f / Nesne #2: Nokta Bulutu \u0130\u015fleyici \u00d6znitelikler: Nokta listesi, filtreleme parametreleri \u0130\u015flevler: Olu\u015ftur(), Filtrele(), Kaydet() Referans: FG-3, FG-5, FG-8 3.5 \u0130\u015flevsel Olmayan Gereksinimler 3.5.1 Performans Kamera ve yap\u0131sal \u0131\u015f\u0131ktan elde edilecek nokta bulutlar\u0131 sistem \u00fczerinden donma olmadan ak\u0131c\u0131 bir \u015fekilde minimum 15 fps\u2019te g\u00f6r\u00fcnt\u00fcleyebilmelidir. 3.5.2 G\u00fcvenilirlik Elde edilen nokta bulutlar\u0131n\u0131n kusursuza yak\u0131n olmas\u0131 ve taramada elde edilen obje ile ger\u00e7ek d\u00fcnyadaki objenin ayn\u0131 boyutta olmas\u0131 hedeflenmektedir. 3.5.3 Kullan\u0131labilirlik Kullan\u0131c\u0131 aray\u00fcz\u00fc sade ve sezgisel olacak \u015fekilde tasarlanmal\u0131d\u0131r. Kullan\u0131c\u0131lar, temel e\u011fitimle t\u00fcm tarama i\u015flemlerini ger\u00e7ekle\u015ftirebilecektir. 3.5.4 G\u00fcvenlik Yaz\u0131l\u0131m, kullan\u0131c\u0131 eri\u015fim kontrol\u00fc sa\u011flamasa da yaln\u0131zca yerel sistemde \u00e7al\u0131\u015f\u0131r. Hassas veriler \u015fifreli bi\u00e7imde saklanmaz. 3.5.5 S\u00fcrd\u00fcr\u00fclebilirlik Yaz\u0131l\u0131m a\u00e7\u0131k kaynak kodlu olarak geli\u015ftirilecek, topluluk katk\u0131lar\u0131 ile g\u00fcncellemeler s\u00fcrd\u00fcr\u00fclebilecektir. 3.5.6 Ta\u015f\u0131nabilirlik Kodlar platformdan ba\u011f\u0131ms\u0131z olarak C++ ve Python ile yaz\u0131lacak, ancak ba\u015flang\u0131\u00e7ta yaln\u0131zca Ubuntu 22.04 i\u015fletim sisteminde \u00e7al\u0131\u015facakt\u0131r. 3.6 Ters Gereksinimleri Yaz\u0131l\u0131m \u00e7evrimd\u0131\u015f\u0131 \u00e7al\u0131\u015facak, bulut ba\u011flant\u0131s\u0131 olmadan t\u00fcm i\u015flevlerini ger\u00e7ekle\u015ftirecektir. 3.7 Tasar\u0131m K\u0131s\u0131tlamalar\u0131 Bu yaz\u0131l\u0131m projesini etkileyen baz\u0131 tasar\u0131m k\u0131s\u0131tlamalar\u0131 a\u015fa\u011f\u0131da belirtilmi\u015ftir: Donan\u0131m Kaynak S\u0131n\u0131rlamalar\u0131: Cihaz\u0131n \u00e7al\u0131\u015fabilmesi i\u00e7in minimum donan\u0131m gereksinimleri vard\u0131r. \u00d6zellikle y\u00fcksek \u00e7\u00f6z\u00fcn\u00fcrl\u00fckl\u00fc stereo g\u00f6r\u00fcnt\u00fclerin i\u015flenmesi ve 3D nokta bulutu olu\u015fturma s\u00fcre\u00e7leri y\u00fcksek i\u015flem g\u00fcc\u00fc ve bellek gerektirdi\u011finden, sistemin en az Intel i7 i\u015flemci, 32GB RAM ve SSD depolama alan\u0131na sahip olmas\u0131 beklenmektedir. Ger\u00e7ek Zamanl\u0131 \u0130\u015fleme K\u0131s\u0131tlamas\u0131: Kameralardan gelen veri ak\u0131\u015f\u0131n\u0131n e\u015f zamanl\u0131 olarak i\u015flenebilmesi i\u00e7in i\u015flem gecikmelerinin minimumda tutulmas\u0131 gerekmektedir. Bu durum yaz\u0131l\u0131m\u0131n mod\u00fcler ve h\u0131zl\u0131 \u00e7al\u0131\u015fan algoritmalarla geli\u015ftirilmesini zorunlu k\u0131lar. Kamera Uyumlulu\u011fu: Yaz\u0131l\u0131m yaln\u0131zca belirli USB 3.0 stereo kameralarla (\u00f6r. e-con Systems IMX900) uyumlu olacak \u015fekilde geli\u015ftirilecektir. Di\u011fer marka/model kameralarla uyumluluk garanti edilmemektedir. \u0130\u015fletim Sistemi Uyumlulu\u011fu: Yaz\u0131l\u0131m sadece Ubuntu 22.04 LTS i\u015fletim sistemi \u00fczerinde test edilip \u00e7al\u0131\u015ft\u0131r\u0131lacakt\u0131r. Di\u011fer i\u015fletim sistemleri i\u00e7in destek sa\u011flanmamaktad\u0131r. \u00c7evrimd\u0131\u015f\u0131 \u00c7al\u0131\u015fma: Uygulama tamamen \u00e7evrimd\u0131\u015f\u0131 \u00e7al\u0131\u015facak \u015fekilde tasarland\u0131\u011f\u0131ndan, bulut tabanl\u0131 depolama veya i\u015flem hizmetleri kullan\u0131lmayacakt\u0131r. 3.8 Mant\u0131ksal Veritaban\u0131 Gereksinimleri Bu sistemde merkezi bir veritaban\u0131 kullan\u0131lmayacakt\u0131r. Ancak yap\u0131lan tarama i\u015flemlerine ait metadata\u2019lar JSON format\u0131nda klas\u00f6rlerde saklanacakt\u0131r. Dosya yap\u0131s\u0131 hiyerar\u015fik olacakt\u0131r. 3.9 Di\u011fer Gereksinimler Yaz\u0131l\u0131m a\u00e7\u0131k kaynak lisans (MIT veya GPL) ile yay\u0131nlanacakt\u0131r. T\u00fcm \u00e7\u0131kt\u0131lar kullan\u0131c\u0131 dizinine otomatik olarak kaydedilecek, i\u015flem sonunda otomatik olarak klas\u00f6r a\u00e7\u0131lacakt\u0131r. Uygulama terminal \u00e7\u0131kt\u0131lar\u0131 ile hata mesajlar\u0131 ve debug bilgilerini kullan\u0131c\u0131ya g\u00f6sterecektir. 4. Analiz Modelleri 4.1 Aktivite Diyagramlar\u0131 Kamera Pozisyonun Bulunmas\u0131 flowchart TD A[\"Kamera Kalibrasyonu - \u0130\u00e7 parametreler: K, D\"] --> B[\"Kamera G\u00f6r\u00fcnt\u00fcs\u00fc - Ger\u00e7ek zamanl\u0131 video\"] B --> C[\"G\u00f6r\u00fcnt\u00fc \u00d6n \u0130\u015fleme - Griye \u00e7evirme, Gauss bulan\u0131kla\u015ft\u0131rma, E\u015fikleme / Canny\"] C --> D[\"Daire Alg\u0131lama - HoughCircles veya Blob\"] D --> E[\"Dairelerin Merkezi ve Yar\u0131\u00e7ap Bilgisi\"] E --> F[\"Marker ID Atama - Opsiyonel, Konum, boyut, desen ile\"] F --> G[\"PnP ile Pozisyon Tahmini - 3D - 2D e\u015fleme, solvePnP\"] G --> H[\"Kamera Pozisyonu - R, t ve Takip G\u00fcncellemesi\"] Genel Yaz\u0131l\u0131m Mimarisi \u2026 4.2 Sequence Diyagramlar\u0131 sequenceDiagram participant Kullan\u0131c\u0131 participant UI participant Kamera participant G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici participant PnP Algoritmas\u0131 Kullan\u0131c\u0131 ->> UI: Tarama Ba\u015flat UI ->> Kamera: Kamera Ba\u015flat Kamera ->> G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici: G\u00f6r\u00fcnt\u00fc G\u00f6nder G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici ->> PnP Algoritmas\u0131: \u0130\u015flem Yap PnP Algoritmas\u0131 ->> G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici: Pozisyon Hesapla G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici ->> UI: Veriyi UI'ye G\u00f6nder UI ->> Kullan\u0131c\u0131: Model G\u00f6ster 4.3 Veri Ak\u0131\u015f Diyagramlar\u0131 graph TD A[Kamera-Ham G\u00f6r\u00fcnt\u00fc] --> B[Kalibrasyon - Kalibrasyon Verisi] B --> C[G\u00f6r\u00fcnt\u00fc \u0130\u015fleme - \u0130\u015flenmi\u015f G\u00f6r\u00fcnt] C --> D[Derinlik Hesaplama - Derinlik Verisi] C --> E[Nokta Bulutu] D --> F[Nokta Bulutu] E --> F[3D Model Olu\u015fturucu] 4.4 Durum Ge\u00e7i\u015fi Diyagramlar\u0131 stateDiagram-v2 [*] --> Ba\u015flang\u0131\u00e7 Ba\u015flang\u0131\u00e7 --> Kalibrasyon_Y\u00fckleniyor Kalibrasyon_Y\u00fckleniyor --> Haz\u0131r Haz\u0131r --> Tarama_Yap\u0131l\u0131yor Tarama_Yap\u0131l\u0131yor --> \u0130\u015fleniyor \u0130\u015fleniyor --> Kaydedildi \u0130\u015fleniyor --> Hata_Durumu Hata_Durumu --> Tarama_Yap\u0131l\u0131yor 5. De\u011fi\u015fiklik Y\u00f6netimi S\u00fcreci Bu yaz\u0131l\u0131m gereksinimleri dok\u00fcman\u0131nda yap\u0131lacak her t\u00fcrl\u00fc de\u011fi\u015fiklik, kontroll\u00fc ve izlenebilir bir s\u00fcre\u00e7 \u00e7er\u00e7evesinde y\u00fcr\u00fct\u00fclecektir. A\u015fa\u011f\u0131da bu s\u00fcrecin detaylar\u0131 yer almaktad\u0131r: 5.1 De\u011fi\u015fiklik Talebi Herhangi bir ekip \u00fcyesi, m\u00fc\u015fteri ya da payda\u015f sistem gereksinimlerinde de\u011fi\u015fiklik \u00f6nerisinde bulunabilir. De\u011fi\u015fiklik talepleri yaz\u0131l\u0131 olarak ve gerek\u00e7esiyle birlikte De\u011fi\u015fiklik Talep Formu (veya GitHub Issues \u00fczerinden) ile sunulmal\u0131d\u0131r. 5.2 De\u011ferlendirme ve Etki Analizi De\u011fi\u015fiklik talepleri, proje y\u00f6neticisi ve teknik ekip taraf\u0131ndan de\u011ferlendirilir. Her de\u011fi\u015fikli\u011fin teknik fizibilitesi, zaman/maliyet etkisi ve mevcut sistem \u00fczerindeki etkisi analiz edilir. Gerekirse, m\u00fc\u015fteriyle tekrar ileti\u015fime ge\u00e7ilerek kapsam netle\u015ftirilir. 5.3 Onay ve Uygulama Uygun bulunan de\u011fi\u015fiklikler, proje y\u00f6neticisi taraf\u0131ndan onaylanarak resmi revizyonlara dahil edilir. \u0130lgili yaz\u0131l\u0131m bile\u015fenleri, test planlar\u0131 ve dok\u00fcmantasyon bu de\u011fi\u015fikli\u011fe g\u00f6re g\u00fcncellenir. 5.4 Versiyonlama ve Kay\u0131t Her de\u011fi\u015fiklik dok\u00fcmana revizyon numaras\u0131, tarih, yazar ve a\u00e7\u0131klama ile birlikte kaydedilir. De\u011fi\u015fiklik ge\u00e7mi\u015fi \u201cRevizyon Ge\u00e7mi\u015fi\u201d b\u00f6l\u00fcm\u00fcnde tutulur. Git \u00fczerinden s\u00fcr\u00fcm kontrol\u00fc sa\u011flan\u0131r (\u00f6rn. v1.1, v1.2-beta gibi). 5.5 \u0130leti\u015fim ve Payla\u015f\u0131m Onaylanan de\u011fi\u015fiklikler ilgili t\u00fcm ekip \u00fcyeleriyle payla\u015f\u0131l\u0131r. Yeni versiyonlar yaz\u0131l\u0131m deposunda ve proje belgelerinde a\u00e7\u0131k\u00e7a belirtilir. A. Ekler Ekler, ilave ve yararl\u0131 bilgi sa\u011flamak i\u00e7in kullan\u0131labilir. Varsa, belirtim a\u00e7\u0131k\u00e7a ekinde yer alan bilgilerin belirtimde ifade edilen gereksinimlerin bir par\u00e7as\u0131 olarak dikkate al\u0131nmas\u0131 gerekiyor belirtilmelidir. \u00d6rnek Ekler (ilk) yaz\u0131l\u0131m projesi i\u00e7in kavramsal belgeler, pazarlama materyalleri, m\u00fc\u015fteri ler ile toplant\u0131lar\u0131n i\u00e7eri\u011fini vs.i\u00e7erebilir. A.1 Ek 1 Etkile\u015fimli Diyagramlar GitHub Pages'de Mermaid diyagramlar\u0131 kullanabilirsiniz. \u00d6rnek: graph TD A[Kamera Mod\u00fcl\u00fc] -->|G\u00f6r\u00fcnt\u00fc Yakala| B[G\u00f6r\u00fcnt\u00fc \u0130\u015fleme] B --> C[Nokta Bulutu Olu\u015fturma] C --> D[Mesh Olu\u015fturma] D --> E[3D Model D\u0131\u015fa Aktarma] B --> F[Marker Tespiti] F --> G[PnP ile Kamera Pozisyonu] Proje \u0130lerleme Takibi Gereksinimlerin Belirlenmesi : Tamamland\u0131 (2 Nisan 2025) Mimari Tasar\u0131m : Devam Ediyor Prototip Geli\u015ftirme : Planlanan (15 May\u0131s 2025) Kod De\u011fi\u015fikli\u011fi G\u00fcncellemeleri 2025-04-02 11:55 Tarihli Kod De\u011fi\u015fiklikleri Commit: 43ffc96 - Add System Requirements Document (SRD) and update project progress tracking De\u011fi\u015ftirilen Dosyalar","title":"Yaz\u0131l\u0131m Gereksinimleri Belirtimi (SRD)"},{"location":"srd/#yazlm-gereksinimleri-belirtimi-srd","text":"Belge T\u00fcr\u00fc : Teknik Dok\u00fcmantasyon Proje : 3B Tarama Cihaz\u0131 Versiyon: 1.1 Tarih: 18.03.2025","title":"Yaz\u0131l\u0131m Gereksinimleri Belirtimi (SRD)"},{"location":"srd/#revizyon-gecmisi","text":"Tarih A\u00e7\u0131klama Yazar Yorumlar 18.03.2025 V1.0 Ahmet Furkan KARAARSLAN Dok\u00fcman ba\u015flang\u0131\u00e7 2.04.2025 V1.1 Muammer Tiryaki K\u00fc\u00e7\u00fck g\u00fcncellemeler","title":"Revizyon Ge\u00e7mi\u015fi"},{"location":"srd/#icindekiler","text":"1. Giri\u015f 1.1 Ama\u00e7 1.2 Kapsam 1.3 Tan\u0131mlar ve K\u0131saltmalar 1.4 Referanslar 1.5 Genel Bak\u0131\u015f 2. Genel A\u00e7\u0131klama 2.1 \u00dcr\u00fcn Perspektifi 2.3 \u00dcr\u00fcn \u0130\u015flevleri 2.3 Kullan\u0131c\u0131 \u00d6zellikleri 2.4 Genel S\u0131n\u0131rlamalar 2.5 Varsay\u0131mlar ve Ba\u011f\u0131ml\u0131l\u0131klar\u0131 3. \u00d6zel Gereksinimler 3.1 D\u0131\u015f Arabirimi Gereksinimleri 3.2 Fonksiyonel Gereksinimleri 3.3 Kullan\u0131m Durumlar\u0131 3.4 S\u0131n\u0131flar / Nesneler 3.5 \u0130\u015flevsel Olmayan Gereksinimler 3.6 Ters Gereksinimleri 3.7 Tasar\u0131m K\u0131s\u0131tlamalar\u0131 3.8 Mant\u0131ksal Veritaban\u0131 Gereksinimleri 3.9 Di\u011fer Gereksinimler 4. Analiz Modelleri 4.1 Aktivite Diyagramlar\u0131 4.2 Sequence Diyagramlar\u0131 4.3 Veri Ak\u0131\u015f Diyagramlar\u0131 4.4 Durum Ge\u00e7i\u015fi Diyagramlar\u0131 5. De\u011fi\u015fiklik Y\u00f6netimi S\u00fcreci A. Ekler A.1 Ek 1","title":"\u0130\u00e7indekiler"},{"location":"srd/#1-giris","text":"","title":"1. Giri\u015f"},{"location":"srd/#11-amac","text":"Bu dok\u00fcman, 3D tarama cihaz\u0131 yaz\u0131l\u0131m\u0131n\u0131n i\u015flevsel ve i\u015flevsel olmayan gereksinimlerini tan\u0131mlamaktad\u0131r. Yaz\u0131l\u0131m\u0131n amac\u0131, lazer tabanl\u0131 yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k desenlerini yakalamak, stereo kamera kurulumu kullanarak noktu bulutunu \u00e7\u0131karmak, kamera konumunu belirlemek i\u00e7in marker tabanl\u0131 PnP algoritmas\u0131n\u0131 kullanmak ve g\u00f6r\u00fcnt\u00fcleri i\u015fleyerek hassas 3D modellerin \u00e7\u0131kt\u0131 olarak olu\u015fturulmas\u0131n\u0131 sa\u011flamakt\u0131r. \u00dcretilecek olan yaz\u0131l\u0131m ve donan\u0131m Kickstarter (Fonlama ile sat\u0131\u015f) projesinde farkl\u0131 paketler (Stereo kamera, Structured Light, Stereo Kamera + Structured Light, Infrared Light, Infrared Light+ Stereo kamera veya hepsi i\u00e7in mono kamera) \u015feklinde piyasaya s\u00fcr\u00fclecektir. Proje i\u00e7erisinde elektronik tasar\u0131m ve yaz\u0131l\u0131m tasar\u0131m\u0131 olarak ikiye ayr\u0131lmaktad\u0131r. Tasarlanan yaz\u0131l\u0131m\u0131n SDK (Software Development Kit) \u015feklinde a\u00e7\u0131k kaynak olarak yay\u0131nlanarak geri d\u00f6n\u00fc\u015fler alarak yaz\u0131l\u0131m\u0131n geli\u015ftirilmesi hedeflenmektedir. Elektronik tasar\u0131m ise SDK ile b\u00fct\u00fcnle\u015fik \u00e7al\u0131\u015f\u0131p kapal\u0131 kaynak benimsenmesi sa\u011flanacakt\u0131r.","title":"1.1 Ama\u00e7"},{"location":"srd/#12-kapsam","text":"Bu yaz\u0131l\u0131m a\u015fa\u011f\u0131daki i\u015flevleri sa\u011flayacakt\u0131r: Lazer tarama sistemi ve kamera ile y\u00fcksek \u00e7\u00f6z\u00fcn\u00fcrl\u00fckl\u00fc g\u00f6r\u00fcnt\u00fcler yakalama. \u0130ki kamera (stereo kamera) kullan\u0131larak derinlik bilgisi elde edilerek nokta bulutu elde etme. Kamera kalibrasyonun yap\u0131labilmesi. G\u00f6r\u00fcnt\u00fc i\u015fleme algoritmalar\u0131n\u0131 kullanarak 3D nokta bulutlar\u0131 olu\u015fturma. Kamera konumlar\u0131n\u0131n i\u015faret\u00e7i tabanl\u0131 PnP algoritmas\u0131 ile belirlenmesi. Tarama ve veri d\u0131\u015fa aktarma i\u015flemleri i\u00e7in etkile\u015fimli bir kullan\u0131c\u0131 aray\u00fcz\u00fc sa\u011flama. Birden fazla \u00e7\u0131kt\u0131 format\u0131n\u0131 destekleme (PCL, STL, OBJ, PLY). Tarama h\u0131z\u0131 ve do\u011frulu\u011funu optimize etme. Elde edilen nokta bulutlar\u0131 \u00fczerinde farkl\u0131 algoritmalar\u0131n\u0131n denenmesi ve denenilen algoritmalar\u0131n etkisinin kontrol edilmesi i\u00e7in test aray\u00fcz\u00fcn\u00fcn olu\u015fturulmas\u0131, algoritma nokta bulutuna uyguland\u0131ktan sonra algoritman\u0131n etkisinin g\u00f6zle kontrol edilmesi. Python SDK ile kullan\u0131c\u0131lar\u0131n hem ham g\u00f6r\u00fcnt\u00fc verilerini hem de \u00f6n i\u015flemden ge\u00e7mi\u015f en az\u0131ndan PCL olarak i\u015flenmi\u015f verileri alabilmesi hedeflenmektedir. Bu elektronik sistem a\u015fa\u011f\u0131daki i\u015flevleri sa\u011flayacakt\u0131r: Birbirinden ba\u011f\u0131ms\u0131z noktada kitler bulunmas\u0131 hedeflenmektedir. Kit ana bilgisayara ya da hesaplama birimine kablolu ya da kablosuz olarak ba\u011flanacakt\u0131r. \u00c7e\u015fitli mod\u00fcller e\u015f zamanl\u0131 piyasaya s\u00fcr\u00fclecektir: Kamera Kaynak Sens\u00f6r Haberle\u015fme FPGA ya da SOM Mod\u00fcl 1 mono RGB IR led pattern IMU kablolu var Mod\u00fcl 2 mono RGB MAV\u0130 pattern IMU kablosuz var Mod\u00fcl 3 stereo RGB IR pattern IMU kablolu yok Mod\u00fcl 4 stereo Monokrome K\u0131rm\u0131z\u0131 pattern IMU kablosuz yok Bu mod\u00fcl kombinasyonu daha sonra belirlenecektir. Mod\u00fcller \u00fczerinde bulunabilecek ISP ve dahili FPGA/SOM gibi yap\u0131lar ara\u015ft\u0131r\u0131lacakt\u0131r. Mod\u00fcller e\u011fer kablosuz tasarlanabiliyorsa batarya mod\u00fcl\u00fc de eklenecektir.","title":"1.2 Kapsam"},{"location":"srd/#13-tanmlar-ve-ksaltmalar","text":"Lazer Tarama: Bir nesneye belirli lazer desenlerinin yans\u0131t\u0131lmas\u0131 ve kameradan al\u0131nan g\u00f6r\u00fcnt\u00fclerin analiz edilerek 3D model olu\u015fturulmas\u0131 tekni\u011fi. Stereo Kamera: Derinlik alg\u0131s\u0131 olu\u015fturmak i\u00e7in iki farkl\u0131 a\u00e7\u0131dan g\u00f6r\u00fcnt\u00fc yakalayan \u00e7ift kamera sistemi. PnP (Perspective-n-Point): Kameran\u0131n 3D uzaydaki konumunu belirlemek i\u00e7in marker tabanl\u0131 konumland\u0131rma y\u00f6ntemi. Nokta Bulutu: Tarama y\u00fczeyini temsil eden 3D veri noktalar\u0131ndan olu\u015fan yap\u0131. STL (Stereolithography): CAD ve 3D bask\u0131 i\u00e7in yayg\u0131n olarak kullan\u0131lan bir 3D dosya format\u0131. Structured Light: Yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k, \u00fc\u00e7 boyutlu bir nesnenin \u015feklini ve derinli\u011fini, nesnenin y\u00fczeyine bir \u0131\u015f\u0131k deseni yans\u0131tarak \u00f6l\u00e7en bir y\u00f6ntemdir. Desen \u015feritler, \u0131zgaralar veya noktalar olabilir. Mono kamera: Tekli kamera kurulumu. IMU: Kameralar\u0131n konum lokasyon takibi yapabilmesi ve birbirlerine g\u00f6re referanslanabilmesini sa\u011flayacakt\u0131r. FPGA ya da SOM: E\u011fer gerekirse mod\u00fcller \u00fczerinde dahili i\u015flem birimi ile PCL verilerinin aktar\u0131labilmesi sa\u011flanacakt\u0131r.","title":"1.3 Tan\u0131mlar ve K\u0131saltmalar"},{"location":"srd/#14-referanslar","text":"OpenCV Dok\u00fcmantasyonu (G\u00f6r\u00fcnt\u00fc i\u015fleme i\u00e7in) Kamera Kalibrasyonu https://docs.opencv.org/4.x/dc/dbb/tutorial_py_calibration.html PCL (Point Cloud Library) Dok\u00fcmantasyonu Agile Yaz\u0131l\u0131m Geli\u015ftirme \u0130lkeleri Open3D Dok\u00fcmantasyonu Kickstarter Kullan\u0131lacak kamera e-con system'e ait monochroma ve RGB kameralard\u0131r.","title":"1.4 Referanslar"},{"location":"srd/#15-genel-baks","text":"Bu belge, 3B tarama cihaz\u0131 yaz\u0131l\u0131m\u0131n\u0131n i\u015flevsel ve i\u015flevsel olmayan t\u00fcm gereksinimlerini ayr\u0131nt\u0131l\u0131 bi\u00e7imde a\u00e7\u0131klar. Belge, yaz\u0131l\u0131m\u0131n amac\u0131n\u0131, kapsam\u0131n\u0131, teknik altyap\u0131s\u0131n\u0131, kullan\u0131c\u0131 aray\u00fczlerini, donan\u0131m ve yaz\u0131l\u0131m arabirimlerini, kullan\u0131m senaryolar\u0131n\u0131, s\u0131n\u0131f ve nesne yap\u0131s\u0131n\u0131, performans beklentilerini ve tasar\u0131m k\u0131s\u0131tlar\u0131n\u0131 i\u00e7ermektedir. Dok\u00fcman a\u015fa\u011f\u0131daki b\u00f6l\u00fcmlerden olu\u015fmaktad\u0131r: Giri\u015f: Projenin amac\u0131, kapsam\u0131, terminolojisi Genel A\u00e7\u0131klama: \u00dcr\u00fcn\u00fcn genel yap\u0131s\u0131 ve kullan\u0131m alanlar\u0131 \u00d6zel Gereksinimler: Fonksiyonel ve i\u015flevsel olmayan gereksinimler Analiz Modelleri: Diyagramlar ve i\u015f ak\u0131\u015flar\u0131 De\u011fi\u015fiklik Y\u00f6netimi: Gereksinimlerin nas\u0131l g\u00fcncellenece\u011fi","title":"1.5 Genel Bak\u0131\u015f"},{"location":"srd/#2-genel-acklama","text":"","title":"2. Genel A\u00e7\u0131klama"},{"location":"srd/#21-urun-perspektifi","text":"Yaz\u0131l\u0131m, harici donan\u0131mlarla (kameralar, lazer kayna\u011f\u0131) etkile\u015fime giren ba\u011f\u0131ms\u0131z bir uygulama ve donan\u0131m olarak tasarlanacakt\u0131r ve kullan\u0131c\u0131ya ger\u00e7ek zamanl\u0131 geri bildirim sa\u011flayacakt\u0131r. Yaz\u0131l\u0131m, \u00fc\u00e7 farkl\u0131 3D tarama y\u00f6ntemi i\u00e7in destek sa\u011flayacakt\u0131r: Stereo Kamera Y\u00f6ntemi: \u0130ki farkl\u0131 kameradan al\u0131nan g\u00f6r\u00fcnt\u00fcler aras\u0131ndaki paralaks fark\u0131 kullan\u0131larak derinlik bilgisi elde edilir. Lazer Tabanl\u0131 Yap\u0131land\u0131r\u0131lm\u0131\u015f I\u015f\u0131k Y\u00f6ntemi: Bir projeksiyon kayna\u011f\u0131 arac\u0131l\u0131\u011f\u0131yla nesne \u00fczerine belirli desenler yans\u0131t\u0131larak, kameradan bu desenlerin deformasyonu analiz edilir ve 3D model olu\u015fturulur. Stereo Kamera + Lazer Tabanl\u0131 Yap\u0131land\u0131r\u0131lm\u0131\u015f I\u015f\u0131k Y\u00f6ntemi: Stereo kamera ve lazer(hem g\u00f6r\u00fcn\u00fcr \u0131\u015f\u0131k hem IR \u0131\u015f\u0131k i\u00e7in) tabanl\u0131 yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k y\u00f6ntemlerinin birle\u015fimi ile daha y\u00fcksek do\u011fruluk elde edilir. Stereo kameralar derinlik haritas\u0131n\u0131 \u00e7\u0131kar\u0131rken, lazer ile detayl\u0131 y\u00fczey bilgisi sa\u011flan\u0131r.","title":"2.1 \u00dcr\u00fcn Perspektifi"},{"location":"srd/#23-urun-islevleri","text":"G\u00f6r\u00fcnt\u00fc Yakalama: Kameradan ham g\u00f6r\u00fcnt\u00fclerin al\u0131nmas\u0131. Lazer Tabanl\u0131 Yap\u0131land\u0131r\u0131lm\u0131\u015f I\u015f\u0131k \u0130\u015fleme: Algoritmalarla derinlik bilgisi \u00e7\u0131karma. 3D Modelle\u015ftirme: Derinlik verisini nokta bulutuna ve mesh yap\u0131s\u0131na d\u00f6n\u00fc\u015ft\u00fcrme. Kamera Konumu Belirleme: Marker tabanl\u0131 PnP algoritmas\u0131 kullanarak kameran\u0131n konumunun hesaplanmas\u0131. Yaz\u0131l\u0131m \u00fczerinden kullan\u0131c\u0131n\u0131n i\u015flevlere sahip olmas\u0131n\u0131 sa\u011flama. E\u011fer birden fazla kamera mod\u00fcl\u00fc bir sisteme tak\u0131l\u0131ysa bunlar aras\u0131nda kolerasyon kurulmas\u0131. Dosya D\u0131\u015fa Aktarma: Sonu\u00e7lar\u0131 end\u00fcstri standard\u0131 3D dosya formatlar\u0131nda kaydetme. Kullan\u0131c\u0131 Aray\u00fcz\u00fc: Tarama ba\u015flatma, durdurma ve dosya y\u00f6netimi gibi \u00f6zellikler sunma.","title":"2.3 \u00dcr\u00fcn \u0130\u015flevleri"},{"location":"srd/#23-kullanc-ozellikleri","text":"","title":"2.3 Kullan\u0131c\u0131 \u00d6zellikleri"},{"location":"srd/#24-genel-snrlamalar","text":"Yaz\u0131l\u0131m sadece uyumlu kamera ve lazer donan\u0131m\u0131 ile \u00e7al\u0131\u015facakt\u0131r. Ger\u00e7ek zamanl\u0131 veri i\u015fleme i\u00e7in belirli bir sistem konfig\u00fcrasyonu (\u00f6rn. minimum i7 i\u015flemci, 32GB RAM ya da Nvidia CUDA) gereklidir. I\u015f\u0131k ko\u015fullar\u0131, tarama kalitesini etkileyebilir. Yetersiz ayd\u0131nlatma durumlar\u0131nda tarama do\u011frulu\u011fu azalabilir. Bu tarz tespitler ile sistem mod\u00fclleri aras\u0131na ek \u00fcr\u00fcnler geli\u015ftirilecektir. Ba\u015flang\u0131\u00e7ta yaln\u0131zca Ubuntu 22.04 i\u015fletim sistemi \u00fczerinde \u00e7al\u0131\u015facakt\u0131r. Ard\u0131ndan Python/C++ SDK ile di\u011fer sistemlerde de \u00e7al\u0131\u015fabilir hale getirilecektir.","title":"2.4 Genel S\u0131n\u0131rlamalar"},{"location":"srd/#25-varsaymlar-ve-bagmllklar","text":"Tarama i\u015flemi i\u00e7in uyumlu bir kamera ve lazer kayna\u011f\u0131 gereklidir. Kamera konumu, marker tabanl\u0131 PnP algoritmas\u0131 kullan\u0131larak tespit edilecektir. G\u00f6r\u00fcnt\u00fc ve 3D i\u015flemleme i\u00e7in OpenCV ve PCL gibi harici k\u00fct\u00fcphaneler kullan\u0131lacakt\u0131r. Birden fazla kamera kullan\u0131lan durumlarda kameralar\u0131n birbirlerine g\u00f6re konumu hassas olarak girilmesi beklenebilir.","title":"2.5 Varsay\u0131mlar ve Ba\u011f\u0131ml\u0131l\u0131klar\u0131"},{"location":"srd/#3-ozel-gereksinimler","text":"","title":"3. \u00d6zel Gereksinimler"},{"location":"srd/#31-ds-arabirimi-gereksinimleri","text":"","title":"3.1 D\u0131\u015f Arabirimi Gereksinimleri"},{"location":"srd/#311-kullanc-arayuzleri","text":"Ana ekran: Tarama ba\u015flatma, durdurma ve ayarlar\u0131 bar\u0131nd\u0131r\u0131r. \u00d6nizleme alan\u0131: Ger\u00e7ek zamanl\u0131 g\u00f6r\u00fcnt\u00fc ak\u0131\u015f\u0131 ve olu\u015fturulan 3D modelin \u00f6nizlemesi g\u00f6sterilir. Ayarlar paneli: Kalibrasyon verileri, \u00e7\u00f6z\u00fcn\u00fcrl\u00fck ve \u00e7\u0131kt\u0131 format\u0131 gibi ayarlar yap\u0131l\u0131r. \u00c7\u0131kt\u0131 ekran\u0131: Tarama sonucu 3D modelin kaydedilece\u011fi format ve konum se\u00e7ilir.","title":"3.1.1 Kullan\u0131c\u0131 Aray\u00fczleri"},{"location":"srd/#312-donanm-arabirimleri","text":"2 adet USB 3.0 ba\u011flant\u0131 noktas\u0131 (stereo kamera i\u00e7in) Lazer taray\u0131c\u0131 i\u00e7in harici g\u00fc\u00e7 ba\u011flant\u0131s\u0131(\u015eimdilik) Donan\u0131m tetikleyici (opsiyonel) ile senkron g\u00f6r\u00fcnt\u00fc alma deste\u011fi \u0130leriki modellerde geni\u015f bant \u00fczerinden veri aktar\u0131m\u0131n\u0131 sa\u011flayabilmek i\u00e7in ETH, Fiber kablo ya da Wi-Fi d\u00fc\u015f\u00fcn\u00fclmektedir. Mod\u00fcl \u00fczerinde dahili batarya","title":"3.1.2 Donan\u0131m Arabirimleri"},{"location":"srd/#313-yazlm-arabirimleri","text":"OpenCV: G\u00f6r\u00fcnt\u00fc i\u015fleme ve kamera kalibrasyonu i\u00e7in PCL: Nokta bulutu olu\u015fturma ve i\u015fleme i\u00e7in, 3D g\u00f6rselle\u015ftirme ve \u00e7\u0131kt\u0131 alma i\u015flemleri i\u00e7in USB kamera SDK\u2019s\u0131 (e-con Systems)","title":"3.1.3 Yaz\u0131l\u0131m Arabirimleri"},{"location":"srd/#314-iletisim-arabirimleri","text":"USB 3.0 \u00fczerinden kamera veri ak\u0131\u015f\u0131","title":"3.1.4 \u0130leti\u015fim Arabirimleri"},{"location":"srd/#32-fonksiyonel-gereksinimleri","text":"ID Gereksinim A\u00e7\u0131klamas\u0131 FG-1 Sistem ba\u011fl\u0131 kameradan g\u00f6r\u00fcnt\u00fc yakalayabilmelidir. FG-2 Yaz\u0131l\u0131m lazer tabanl\u0131 yap\u0131land\u0131r\u0131lm\u0131\u015f \u0131\u015f\u0131k desenlerini alg\u0131lay\u0131p analiz edebilmelidir. FG-3 Sistem yakalanan g\u00f6r\u00fcnt\u00fclerden 3D nokta bulutu olu\u015fturabilmelidir. FG-4 Kullan\u0131c\u0131 tarama \u00e7\u00f6z\u00fcn\u00fcrl\u00fc\u011f\u00fcn\u00fc ve parametreleri ayarlayabilmelidir. FG-5 Sistem 3D modelleri STL, OBJ ve PLY formatlar\u0131nda d\u0131\u015fa aktarabilmelidir. FG-6 Kullan\u0131c\u0131 aray\u00fcz\u00fc, tarama ba\u015flatma, durdurma ve kaydetme i\u015flemlerine izin vermelidir. FG-7 Kamera konumu, i\u015faret tabanl\u0131 PnP algoritmas\u0131 ile tespit edilmelidir. FG-8 Nokta bulutlar\u0131 \u00fczerinde denenilecek olan algoritmalar i\u00e7in \u00f6ncesi ve sonras\u0131 \u015feklinde g\u00f6r\u00fcnt\u00fcler vermelidir. FG-9 G\u00f6r\u00fcnt\u00fc hem dinamik olarak hem de kullan\u0131c\u0131n\u0131n iste\u011fine g\u00f6re \u201cspace\u201d tu\u015funa bast\u0131k\u00e7a kameradan g\u00f6r\u00fcnt\u00fc alacak \u015fekilde iki se\u00e7enekli olmal\u0131d\u0131r. FG-10 \u0130\u015faret\u00e7i takibi kaybedildi\u011fi zaman kullan\u0131c\u0131y\u0131 bilgilendirmek i\u00e7in ekranda uyar\u0131 vermeli ve kamera konumu belirlenene kadar tarama durdurulmal\u0131d\u0131r.","title":"3.2 Fonksiyonel Gereksinimleri"},{"location":"srd/#321-fonksiyonel-gereksinim-1-goruntu-yakalama-ve-tarama","text":"Giri\u015f: Stereo kamera g\u00f6r\u00fcnt\u00fcleri Giri\u015fler: Kalibrasyon verileri (K1, D1, K2, D2) \u0130\u015fleme: Stereo e\u015fleme algoritmas\u0131 ile derinlik haritas\u0131 \u00fcretimi \u00c7\u0131k\u0131\u015flar: 3D nokta bulutu Hata i\u015fleme: Kalibrasyon eksikse uyar\u0131 verilir, d\u00fc\u015f\u00fck e\u015fle\u015fme kalitesi tespit edilirse kullan\u0131c\u0131ya bildirim yap\u0131l\u0131r.","title":"3.2.1 Fonksiyonel Gereksinim #1: G\u00f6r\u00fcnt\u00fc Yakalama ve Tarama"},{"location":"srd/#322-fonksiyonel-gereksinim-2-3d-modelin-olusturulmas-ve-dsa-aktarm","text":"Giri\u015f: Nokta bulutu, kullan\u0131c\u0131 taraf\u0131ndan se\u00e7ilen parametreler \u0130\u015fleme: Noktalar mesh'e d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr, gerekli dosya format\u0131 olu\u015fturulur \u00c7\u0131k\u0131\u015flar: STL, OBJ, PLY format\u0131nda dosyalar Hata \u0130\u015fleme: Yazma izni olmayan klas\u00f6r se\u00e7ilirse kullan\u0131c\u0131 uyar\u0131l\u0131r, bo\u015f tarama verisi varsa i\u015flem durdurulur.","title":"3.2.2 Fonksiyonel Gereksinim #2: 3D Modelin Olu\u015fturulmas\u0131 ve D\u0131\u015fa Aktar\u0131m\u0131"},{"location":"srd/#33-kullanm-durumlar","text":"","title":"3.3 Kullan\u0131m Durumlar\u0131"},{"location":"srd/#331-kullanm-durumu-1-nesne-tabanl-3d-tarama","text":"Ama\u00e7: Ger\u00e7ek d\u00fcnya ortam\u0131ndaki bir nesnenin y\u00fczey geometrisinin y\u00fcksek hassasiyetle taranarak bilgisayar ortam\u0131nda 3B model olarak elde edilmesi. Akt\u00f6rler: Kullan\u0131c\u0131 (operat\u00f6r) \u00d6n Ko\u015fullar: Kamera ve lazer sistemi d\u00fczg\u00fcn \u00e7al\u0131\u015f\u0131yor olmal\u0131 Kalibrasyon tamamlanm\u0131\u015f olmal\u0131 Marker\u2019lar sistemin g\u00f6rebilece\u011fi \u015fekilde d\u00fczg\u00fcn konumland\u0131r\u0131lm\u0131\u015f olmal\u0131 Marker tan\u0131mlar\u0131 yaz\u0131l\u0131ma \u00f6nceden tan\u0131t\u0131lm\u0131\u015f olmal\u0131 Senaryo: Kullan\u0131c\u0131 sistemi ba\u015flat\u0131r. Marker\u2019lar kameralar taraf\u0131ndan alg\u0131lan\u0131r ve PnP algoritmas\u0131 ile pozisyon tespiti yap\u0131l\u0131r. Kamera ve lazer otomatik olarak senkronize \u00e7al\u0131\u015fmaya ba\u015flar. Kullan\u0131c\u0131 nesneyi sabit konumda yerle\u015ftirir. Sistem g\u00f6r\u00fcnt\u00fcleri yakalar, i\u015fleyip nokta bulutu olu\u015fturur. Nokta bulutu 3B modele d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr. Kullan\u0131c\u0131 \u00e7\u0131kt\u0131y\u0131 .STL veya .PLY format\u0131nda kaydeder. Sonu\u00e7: Tarama ba\u015far\u0131yla tamamlan\u0131r ve 3D model elde edilir.","title":"3.3.1 Kullan\u0131m Durumu #1: Nesne Tabanl\u0131 3D Tarama"},{"location":"srd/#332-kullanm-durumu-2-medikal-tarama-uzuv-modelleme","text":"Ama\u00e7: Medikal sekt\u00f6r\u00fcnde kullan\u0131lmak \u00fczere insan uzuvlar\u0131n\u0131n hassas \u015fekilde taranarak dijital ortama aktar\u0131lmas\u0131. Akt\u00f6rler: Kullan\u0131c\u0131 (teknisyen), hasta \u00d6n Ko\u015fullar: Ki\u015fi hareketsiz pozisyonda durmal\u0131 Kalibrasyon dosyalar\u0131 \u00f6nceden haz\u0131rlanm\u0131\u015f olmal\u0131 Marker\u2019lar sistem g\u00f6r\u00fc\u015f alan\u0131nda net \u015fekilde sabitlenmi\u015f olmal\u0131 Ortam \u0131\u015f\u0131\u011f\u0131 yetersiz de\u011filse ek ayd\u0131nlatma sa\u011flanmal\u0131 Senaryo: Kullan\u0131c\u0131 hastay\u0131 tarama alan\u0131na yerle\u015ftirir. Marker'lar alg\u0131lan\u0131r, sistem pozisyonunu do\u011frular. Tarama \u00e7\u00f6z\u00fcn\u00fcrl\u00fc\u011f\u00fc \u201cy\u00fcksek\u201d olarak se\u00e7ilir. Sistem birka\u00e7 saniyelik g\u00f6r\u00fcnt\u00fc al\u0131m\u0131 yapar. Elde edilen nokta bulutu y\u00fczey yumu\u015fatma ile optimize edilir. Model, ortopedik kal\u0131p \u00fcretimi i\u00e7in d\u0131\u015fa aktar\u0131l\u0131r. Sonu\u00e7: Hasta uzvunun dijital modeli al\u0131nm\u0131\u015f ve \u00fcretime haz\u0131r h\u00e2le getirilmi\u015ftir.","title":"3.3.2 Kullan\u0131m Durumu #2: Medikal Tarama \u2013 Uzuv Modelleme"},{"location":"srd/#333-kullanm-durumu-3-algoritma-karslastrma-modu-test-arayuzu","text":"Ama\u00e7: Yeni nokta bulutu filtreleme veya y\u00fczey iyile\u015ftirme algoritmalar\u0131n\u0131 test etmek ve etkilerini g\u00f6rsel olarak kar\u015f\u0131la\u015ft\u0131rmak. Akt\u00f6rler: Geli\u015ftirici veya ara\u015ft\u0131rmac\u0131 kullan\u0131c\u0131 \u00d6n Ko\u015fullar: Marker\u2019lar yaz\u0131l\u0131mda tan\u0131t\u0131lm\u0131\u015f olmal\u0131 (e\u011fer canl\u0131 tarama yap\u0131lacaksa) Mevcut veya \u00f6nceden taranm\u0131\u015f nokta bulutu verisi sisteme y\u00fcklenebilir olmal\u0131 Senaryo: Kullan\u0131c\u0131 mevcut bir nokta bulutunu yaz\u0131l\u0131ma y\u00fckler. Farkl\u0131 filtreleme algoritmalar\u0131 listeden se\u00e7ilir. Yaz\u0131l\u0131m ayn\u0131 veri \u00fczerinde \u00f6nce/sonra kar\u015f\u0131la\u015ft\u0131rmas\u0131 yapar. Kullan\u0131c\u0131 g\u00f6rsel \u00e7\u0131kt\u0131lar \u00fczerinden karar verir. Sonu\u00e7: Algoritmalar\u0131n performans\u0131 test edilmi\u015f olur, ileri geli\u015ftirmeler yap\u0131labilir.","title":"3.3.3 Kullan\u0131m Durumu #3: Algoritma Kar\u015f\u0131la\u015ft\u0131rma Modu (Test Aray\u00fcz\u00fc)"},{"location":"srd/#34-snflar-nesneler","text":"","title":"3.4 S\u0131n\u0131flar / Nesneler"},{"location":"srd/#341-snf-nesne-1-kameramodulu","text":"\u00d6znitelikler: ID, \u00e7\u00f6z\u00fcn\u00fcrl\u00fck, fps, kalibrasyon parametreleri \u0130\u015flevler: G\u00f6r\u00fcnt\u00fcAl(), KalibrasyonY\u00fckle(), VideoAk\u0131\u015f\u0131Ba\u015flat() Referans: FG-1, FG-7","title":"3.4.1 S\u0131n\u0131f / Nesne #1: KameraMod\u00fcl\u00fc"},{"location":"srd/#342-snf-nesne-2-nokta-bulutu-isleyici","text":"\u00d6znitelikler: Nokta listesi, filtreleme parametreleri \u0130\u015flevler: Olu\u015ftur(), Filtrele(), Kaydet() Referans: FG-3, FG-5, FG-8","title":"3.4.2 S\u0131n\u0131f / Nesne #2: Nokta Bulutu \u0130\u015fleyici"},{"location":"srd/#35-islevsel-olmayan-gereksinimler","text":"","title":"3.5 \u0130\u015flevsel Olmayan Gereksinimler"},{"location":"srd/#351-performans","text":"Kamera ve yap\u0131sal \u0131\u015f\u0131ktan elde edilecek nokta bulutlar\u0131 sistem \u00fczerinden donma olmadan ak\u0131c\u0131 bir \u015fekilde minimum 15 fps\u2019te g\u00f6r\u00fcnt\u00fcleyebilmelidir.","title":"3.5.1 Performans"},{"location":"srd/#352-guvenilirlik","text":"Elde edilen nokta bulutlar\u0131n\u0131n kusursuza yak\u0131n olmas\u0131 ve taramada elde edilen obje ile ger\u00e7ek d\u00fcnyadaki objenin ayn\u0131 boyutta olmas\u0131 hedeflenmektedir.","title":"3.5.2 G\u00fcvenilirlik"},{"location":"srd/#353-kullanlabilirlik","text":"Kullan\u0131c\u0131 aray\u00fcz\u00fc sade ve sezgisel olacak \u015fekilde tasarlanmal\u0131d\u0131r. Kullan\u0131c\u0131lar, temel e\u011fitimle t\u00fcm tarama i\u015flemlerini ger\u00e7ekle\u015ftirebilecektir.","title":"3.5.3 Kullan\u0131labilirlik"},{"location":"srd/#354-guvenlik","text":"Yaz\u0131l\u0131m, kullan\u0131c\u0131 eri\u015fim kontrol\u00fc sa\u011flamasa da yaln\u0131zca yerel sistemde \u00e7al\u0131\u015f\u0131r. Hassas veriler \u015fifreli bi\u00e7imde saklanmaz.","title":"3.5.4 G\u00fcvenlik"},{"location":"srd/#355-surdurulebilirlik","text":"Yaz\u0131l\u0131m a\u00e7\u0131k kaynak kodlu olarak geli\u015ftirilecek, topluluk katk\u0131lar\u0131 ile g\u00fcncellemeler s\u00fcrd\u00fcr\u00fclebilecektir.","title":"3.5.5 S\u00fcrd\u00fcr\u00fclebilirlik"},{"location":"srd/#356-tasnabilirlik","text":"Kodlar platformdan ba\u011f\u0131ms\u0131z olarak C++ ve Python ile yaz\u0131lacak, ancak ba\u015flang\u0131\u00e7ta yaln\u0131zca Ubuntu 22.04 i\u015fletim sisteminde \u00e7al\u0131\u015facakt\u0131r.","title":"3.5.6 Ta\u015f\u0131nabilirlik"},{"location":"srd/#36-ters-gereksinimleri","text":"Yaz\u0131l\u0131m \u00e7evrimd\u0131\u015f\u0131 \u00e7al\u0131\u015facak, bulut ba\u011flant\u0131s\u0131 olmadan t\u00fcm i\u015flevlerini ger\u00e7ekle\u015ftirecektir.","title":"3.6 Ters Gereksinimleri"},{"location":"srd/#37-tasarm-kstlamalar","text":"Bu yaz\u0131l\u0131m projesini etkileyen baz\u0131 tasar\u0131m k\u0131s\u0131tlamalar\u0131 a\u015fa\u011f\u0131da belirtilmi\u015ftir: Donan\u0131m Kaynak S\u0131n\u0131rlamalar\u0131: Cihaz\u0131n \u00e7al\u0131\u015fabilmesi i\u00e7in minimum donan\u0131m gereksinimleri vard\u0131r. \u00d6zellikle y\u00fcksek \u00e7\u00f6z\u00fcn\u00fcrl\u00fckl\u00fc stereo g\u00f6r\u00fcnt\u00fclerin i\u015flenmesi ve 3D nokta bulutu olu\u015fturma s\u00fcre\u00e7leri y\u00fcksek i\u015flem g\u00fcc\u00fc ve bellek gerektirdi\u011finden, sistemin en az Intel i7 i\u015flemci, 32GB RAM ve SSD depolama alan\u0131na sahip olmas\u0131 beklenmektedir. Ger\u00e7ek Zamanl\u0131 \u0130\u015fleme K\u0131s\u0131tlamas\u0131: Kameralardan gelen veri ak\u0131\u015f\u0131n\u0131n e\u015f zamanl\u0131 olarak i\u015flenebilmesi i\u00e7in i\u015flem gecikmelerinin minimumda tutulmas\u0131 gerekmektedir. Bu durum yaz\u0131l\u0131m\u0131n mod\u00fcler ve h\u0131zl\u0131 \u00e7al\u0131\u015fan algoritmalarla geli\u015ftirilmesini zorunlu k\u0131lar. Kamera Uyumlulu\u011fu: Yaz\u0131l\u0131m yaln\u0131zca belirli USB 3.0 stereo kameralarla (\u00f6r. e-con Systems IMX900) uyumlu olacak \u015fekilde geli\u015ftirilecektir. Di\u011fer marka/model kameralarla uyumluluk garanti edilmemektedir. \u0130\u015fletim Sistemi Uyumlulu\u011fu: Yaz\u0131l\u0131m sadece Ubuntu 22.04 LTS i\u015fletim sistemi \u00fczerinde test edilip \u00e7al\u0131\u015ft\u0131r\u0131lacakt\u0131r. Di\u011fer i\u015fletim sistemleri i\u00e7in destek sa\u011flanmamaktad\u0131r. \u00c7evrimd\u0131\u015f\u0131 \u00c7al\u0131\u015fma: Uygulama tamamen \u00e7evrimd\u0131\u015f\u0131 \u00e7al\u0131\u015facak \u015fekilde tasarland\u0131\u011f\u0131ndan, bulut tabanl\u0131 depolama veya i\u015flem hizmetleri kullan\u0131lmayacakt\u0131r.","title":"3.7 Tasar\u0131m K\u0131s\u0131tlamalar\u0131"},{"location":"srd/#38-mantksal-veritaban-gereksinimleri","text":"Bu sistemde merkezi bir veritaban\u0131 kullan\u0131lmayacakt\u0131r. Ancak yap\u0131lan tarama i\u015flemlerine ait metadata\u2019lar JSON format\u0131nda klas\u00f6rlerde saklanacakt\u0131r. Dosya yap\u0131s\u0131 hiyerar\u015fik olacakt\u0131r.","title":"3.8 Mant\u0131ksal Veritaban\u0131 Gereksinimleri"},{"location":"srd/#39-diger-gereksinimler","text":"Yaz\u0131l\u0131m a\u00e7\u0131k kaynak lisans (MIT veya GPL) ile yay\u0131nlanacakt\u0131r. T\u00fcm \u00e7\u0131kt\u0131lar kullan\u0131c\u0131 dizinine otomatik olarak kaydedilecek, i\u015flem sonunda otomatik olarak klas\u00f6r a\u00e7\u0131lacakt\u0131r. Uygulama terminal \u00e7\u0131kt\u0131lar\u0131 ile hata mesajlar\u0131 ve debug bilgilerini kullan\u0131c\u0131ya g\u00f6sterecektir.","title":"3.9 Di\u011fer Gereksinimler"},{"location":"srd/#4-analiz-modelleri","text":"","title":"4. Analiz Modelleri"},{"location":"srd/#41-aktivite-diyagramlar","text":"Kamera Pozisyonun Bulunmas\u0131 flowchart TD A[\"Kamera Kalibrasyonu - \u0130\u00e7 parametreler: K, D\"] --> B[\"Kamera G\u00f6r\u00fcnt\u00fcs\u00fc - Ger\u00e7ek zamanl\u0131 video\"] B --> C[\"G\u00f6r\u00fcnt\u00fc \u00d6n \u0130\u015fleme - Griye \u00e7evirme, Gauss bulan\u0131kla\u015ft\u0131rma, E\u015fikleme / Canny\"] C --> D[\"Daire Alg\u0131lama - HoughCircles veya Blob\"] D --> E[\"Dairelerin Merkezi ve Yar\u0131\u00e7ap Bilgisi\"] E --> F[\"Marker ID Atama - Opsiyonel, Konum, boyut, desen ile\"] F --> G[\"PnP ile Pozisyon Tahmini - 3D - 2D e\u015fleme, solvePnP\"] G --> H[\"Kamera Pozisyonu - R, t ve Takip G\u00fcncellemesi\"] Genel Yaz\u0131l\u0131m Mimarisi \u2026","title":"4.1 Aktivite Diyagramlar\u0131"},{"location":"srd/#42-sequence-diyagramlar","text":"sequenceDiagram participant Kullan\u0131c\u0131 participant UI participant Kamera participant G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici participant PnP Algoritmas\u0131 Kullan\u0131c\u0131 ->> UI: Tarama Ba\u015flat UI ->> Kamera: Kamera Ba\u015flat Kamera ->> G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici: G\u00f6r\u00fcnt\u00fc G\u00f6nder G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici ->> PnP Algoritmas\u0131: \u0130\u015flem Yap PnP Algoritmas\u0131 ->> G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici: Pozisyon Hesapla G\u00f6r\u00fcnt\u00fc \u0130\u015fleyici ->> UI: Veriyi UI'ye G\u00f6nder UI ->> Kullan\u0131c\u0131: Model G\u00f6ster","title":"4.2 Sequence Diyagramlar\u0131"},{"location":"srd/#43-veri-aks-diyagramlar","text":"graph TD A[Kamera-Ham G\u00f6r\u00fcnt\u00fc] --> B[Kalibrasyon - Kalibrasyon Verisi] B --> C[G\u00f6r\u00fcnt\u00fc \u0130\u015fleme - \u0130\u015flenmi\u015f G\u00f6r\u00fcnt] C --> D[Derinlik Hesaplama - Derinlik Verisi] C --> E[Nokta Bulutu] D --> F[Nokta Bulutu] E --> F[3D Model Olu\u015fturucu]","title":"4.3 Veri Ak\u0131\u015f Diyagramlar\u0131"},{"location":"srd/#44-durum-gecisi-diyagramlar","text":"stateDiagram-v2 [*] --> Ba\u015flang\u0131\u00e7 Ba\u015flang\u0131\u00e7 --> Kalibrasyon_Y\u00fckleniyor Kalibrasyon_Y\u00fckleniyor --> Haz\u0131r Haz\u0131r --> Tarama_Yap\u0131l\u0131yor Tarama_Yap\u0131l\u0131yor --> \u0130\u015fleniyor \u0130\u015fleniyor --> Kaydedildi \u0130\u015fleniyor --> Hata_Durumu Hata_Durumu --> Tarama_Yap\u0131l\u0131yor","title":"4.4 Durum Ge\u00e7i\u015fi Diyagramlar\u0131"},{"location":"srd/#5-degisiklik-yonetimi-sureci","text":"Bu yaz\u0131l\u0131m gereksinimleri dok\u00fcman\u0131nda yap\u0131lacak her t\u00fcrl\u00fc de\u011fi\u015fiklik, kontroll\u00fc ve izlenebilir bir s\u00fcre\u00e7 \u00e7er\u00e7evesinde y\u00fcr\u00fct\u00fclecektir. A\u015fa\u011f\u0131da bu s\u00fcrecin detaylar\u0131 yer almaktad\u0131r:","title":"5. De\u011fi\u015fiklik Y\u00f6netimi S\u00fcreci"},{"location":"srd/#51-degisiklik-talebi","text":"Herhangi bir ekip \u00fcyesi, m\u00fc\u015fteri ya da payda\u015f sistem gereksinimlerinde de\u011fi\u015fiklik \u00f6nerisinde bulunabilir. De\u011fi\u015fiklik talepleri yaz\u0131l\u0131 olarak ve gerek\u00e7esiyle birlikte De\u011fi\u015fiklik Talep Formu (veya GitHub Issues \u00fczerinden) ile sunulmal\u0131d\u0131r.","title":"5.1 De\u011fi\u015fiklik Talebi"},{"location":"srd/#52-degerlendirme-ve-etki-analizi","text":"De\u011fi\u015fiklik talepleri, proje y\u00f6neticisi ve teknik ekip taraf\u0131ndan de\u011ferlendirilir. Her de\u011fi\u015fikli\u011fin teknik fizibilitesi, zaman/maliyet etkisi ve mevcut sistem \u00fczerindeki etkisi analiz edilir. Gerekirse, m\u00fc\u015fteriyle tekrar ileti\u015fime ge\u00e7ilerek kapsam netle\u015ftirilir.","title":"5.2 De\u011ferlendirme ve Etki Analizi"},{"location":"srd/#53-onay-ve-uygulama","text":"Uygun bulunan de\u011fi\u015fiklikler, proje y\u00f6neticisi taraf\u0131ndan onaylanarak resmi revizyonlara dahil edilir. \u0130lgili yaz\u0131l\u0131m bile\u015fenleri, test planlar\u0131 ve dok\u00fcmantasyon bu de\u011fi\u015fikli\u011fe g\u00f6re g\u00fcncellenir.","title":"5.3 Onay ve Uygulama"},{"location":"srd/#54-versiyonlama-ve-kayt","text":"Her de\u011fi\u015fiklik dok\u00fcmana revizyon numaras\u0131, tarih, yazar ve a\u00e7\u0131klama ile birlikte kaydedilir. De\u011fi\u015fiklik ge\u00e7mi\u015fi \u201cRevizyon Ge\u00e7mi\u015fi\u201d b\u00f6l\u00fcm\u00fcnde tutulur. Git \u00fczerinden s\u00fcr\u00fcm kontrol\u00fc sa\u011flan\u0131r (\u00f6rn. v1.1, v1.2-beta gibi).","title":"5.4 Versiyonlama ve Kay\u0131t"},{"location":"srd/#55-iletisim-ve-paylasm","text":"Onaylanan de\u011fi\u015fiklikler ilgili t\u00fcm ekip \u00fcyeleriyle payla\u015f\u0131l\u0131r. Yeni versiyonlar yaz\u0131l\u0131m deposunda ve proje belgelerinde a\u00e7\u0131k\u00e7a belirtilir.","title":"5.5 \u0130leti\u015fim ve Payla\u015f\u0131m"},{"location":"srd/#a-ekler","text":"Ekler, ilave ve yararl\u0131 bilgi sa\u011flamak i\u00e7in kullan\u0131labilir. Varsa, belirtim a\u00e7\u0131k\u00e7a ekinde yer alan bilgilerin belirtimde ifade edilen gereksinimlerin bir par\u00e7as\u0131 olarak dikkate al\u0131nmas\u0131 gerekiyor belirtilmelidir. \u00d6rnek Ekler (ilk) yaz\u0131l\u0131m projesi i\u00e7in kavramsal belgeler, pazarlama materyalleri, m\u00fc\u015fteri ler ile toplant\u0131lar\u0131n i\u00e7eri\u011fini vs.i\u00e7erebilir.","title":"A. Ekler"},{"location":"srd/#a1-ek-1","text":"","title":"A.1 Ek 1"},{"location":"srd/#etkilesimli-diyagramlar","text":"GitHub Pages'de Mermaid diyagramlar\u0131 kullanabilirsiniz. \u00d6rnek: graph TD A[Kamera Mod\u00fcl\u00fc] -->|G\u00f6r\u00fcnt\u00fc Yakala| B[G\u00f6r\u00fcnt\u00fc \u0130\u015fleme] B --> C[Nokta Bulutu Olu\u015fturma] C --> D[Mesh Olu\u015fturma] D --> E[3D Model D\u0131\u015fa Aktarma] B --> F[Marker Tespiti] F --> G[PnP ile Kamera Pozisyonu]","title":"Etkile\u015fimli Diyagramlar"},{"location":"srd/#proje-ilerleme-takibi","text":"Gereksinimlerin Belirlenmesi : Tamamland\u0131 (2 Nisan 2025) Mimari Tasar\u0131m : Devam Ediyor Prototip Geli\u015ftirme : Planlanan (15 May\u0131s 2025)","title":"Proje \u0130lerleme Takibi"},{"location":"srd/#kod-degisikligi-guncellemeleri","text":"","title":"Kod De\u011fi\u015fikli\u011fi G\u00fcncellemeleri"},{"location":"srd/#2025-04-02-1155-tarihli-kod-degisiklikleri","text":"Commit: 43ffc96 - Add System Requirements Document (SRD) and update project progress tracking","title":"2025-04-02 11:55 Tarihli Kod De\u011fi\u015fiklikleri"},{"location":"srd/#degistirilen-dosyalar","text":"","title":"De\u011fi\u015ftirilen Dosyalar"}]}